---
title: c++ 继承
comments: true
tags:
  - c++
  - 继承
categories:
  - c++
date: 2017-03-05 16:59:34
update: 2017-03-05 16:59:34

---
# 继承与派生：- 保持已有类的特性而构造新类的过程称为继承。- 在已有类的基础上新增自己的特性而产生新类的过程称为派生。- 继承的目的：实现代码重用。- 派生的目的：当新的问题出现，原有程序无法解决（或不能完全解决）时，需要对原有程序进行改造。
#	三种继承方式> 公有继承；私有继承；保护继承   
> 不同继承方式的影响主要体现在:
>
1. 派生类成员对基类成员的访问控制。2. 派生类对象对基类成员的访问控制。
## 1.公有继承：- 继承方式：基类的public和protected成员的访问属性在派生类中保持不变，但基类的private成员不可访问。- 类内： 派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。- 类外：通过派生类的对象只能访问基类的public成员。
## 2.私有继承：- 继承方式：基类的public和protected成员都以private身份出现在派生类中，但基类的private成员不可访问。- 类内：派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。- 类外：通过派生类的对象不能访问基类中的任何成员。
## 3.保护继承：- 继承方式：基类的public和protected成员都以protected身份出现在派生类中，但基类的private成员不可访问。- 类内：派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。- 类外：通过派生类的对象不能访问基类中的任何成员

## 4.protected 成员的特点与作用：-	对建立其所在类对象的模块来说（水平访问时），它与 private 成员的性质相同。-	对于其派生类来说（垂直访问时），它与 public 成员的性质相同。- .	既实现了数据隐藏，又方便继承，实现代码重用；
# 基类与派生类的对应关系- 单继承:	派生类只从一个基类派生。- 多继承：派生类从多个基类派生。- 多重派生: 由一个基类派生出多个不同的派生类。- 多层派生: 派生类又作为基类，继续派生新的类。# 继承时的构造函数1. 	基类的构造函数不被继承，需要在派生类中自行声明。2.	声明构造函数时，只需要对本类中新增成员进行初始化，对继承来的基类成员的初始化由基类完成。
# 多重继承构造函数的调用次序1. 调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。2. 	调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序。3. 	派生类的构造函数体中的内容。
#	 多重继承时的析构函数1.	析构函数也不被继承，派生类自行声明。2. 	声明方法与一般（无继承关系时）类的析构函数相同。3. 	不需要显式地调用基类的析构函数，系统会自动隐式调用。4.	析构函数的调用次序与构造函数相反。
#	 二义性问题
- 在多继承时，基类与派生类之间，或基类之间出现同名成员时，将出现访问时的二义性（不确定性）——采用虚函数或支配（同名覆盖）原则来解决。- 当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性——采用虚基类来解决。（菱形继承）
# 虚基类声明:	以virtual修饰说明基类	

	例：class B1:virtual public B
	作用：
1. 	主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题.2. 为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝>**注意**：在第一级继承时就要将共同基类设计为虚基类。
# 赋值兼容原则一个公有派生类的对象在使用上可以被当作基类的对象，反之则禁止。具体表现在：1. 派生类的对象可以被赋值给基类对象。2. 派生类的对象可以初始化基类的引用。3. 指向基类的指针也可以指向派生类。