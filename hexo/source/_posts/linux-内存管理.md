---
title: linux 内存管理
comments: true
tags:
  - linux
  - 内存管理
categories:
  - linux
date: 2017-03-05 18:00:46
update: 2017-03-05 18:00:46

---
# CPU位数和操作系统位数的关系：操作系统的位数其实是说的CPU的位数。因为计算机的所有功能都是基于CPU的指令集，也就是说，操作系统的所有功能几乎都跟CPU指令集有关系，操作系统的所有功能都会被翻译成一组CPU指令集。64位CPU的指令集是64位的，要想使用64位的功能，那么操作系统也必须是64位的。比如操作系统里的寻址，数据的大小都可以为64位。当然，64位CPU也会保存32位指令集，所以也兼容32位操作系统。 现在来说CPU位数。众所周知，CPU里有8个通用寄存器，AX/BX/CX/DX/SI/DI/BP/SP，也就是说，由于64位CPU指令集会操作64位数据，如果寄存器是32位的，那么64位指令集便没有了可以运行的场所。所以，CPU位数说的是指令集的位数和通用寄存器的位数。下面是两个参考网站位什么要分段分页？> http://www.2cto.com/os/201210/161572.htmlhttp://www.cppblog.com/sixinquan/archive/2012/07/19/184234.html# 分段## 首先看一下分段的引入早期的8086处理器运算单元是16位的，也就是说，处理内存寻址的那部分指令集处理的也是16位的。而地址线是20位的。理论上，20位地址线寻址范围应该是1MB。但是由于指令集是16位的，所以也就不能直接使用这20位地址线。  ### 解决方法有2种- 一种是，给CPU指令集增加一部分20位的指令集用来处理内存寻址，但是这会CPU内部结构不均匀（坏处网上我没搜到，反正肯定不好。我猜应该是，如果当这20位的指令集需要和16位的指令集进行交互时，那么就需要某种方式的映射，这会增加CPU功耗或者是拖慢CPU的速度）。- 另一种解决方法，CPU仍然使用16位指令集，增设一些16位的段寄存器。在把最终地址送上20位地址总线时，它会把某个段寄存器的16位放在地址总线的高16位，然后把指令集得到的16位地址放在低16位，那么相当于重叠了12位。但是，总能在20位的地址上模拟出1MB的访问空间。这就利用简单地加法模拟了一个映射，从而用16位的指令集使用了20位的地址线。这也就是为什么段的引入会加大寻址空间。而80386CPU的指令集是32位，地址线也是32位，按理来说根本不需要分段来增大寻址空间。但是，80386到底是8086的一员，它还得兼容之前的实模式，所以，16位的段寄存器必须保存下来。既然已经不需要分段的空大空间能力，所以，inter处理器的开发商便基于16位寄存器开发出了保护模式。在保护模式下,它的段范围不再受限于64K，可以达到4G。这一下真正解放了软件工程师,他们不必再费尽心思去压缩程序规模，软件功能也因此迅速提升。## 分段实现的功能：1. 扩大寻址空间。2. 实现保护模式	保护模式会实现怎样的功能？  在保护模式下，一个地址空间是否可以被写入？可以被多少优先级的代码写入？是不是允许被执行等问题就显现出来了。例如，在还没有分页机制的时候，也就是没有多个进程利用多套虚拟地址空间使用同一个比如是4G的空间时，多个进程之间是如何共享内存的？如果没有保护，进程A访问了进程B的空间，并且修改了进程B的某个非常重要的参数，那么进程B可能会因此直接gg。程序员需要自己定义一个段，然后不允许其他进程访问。再例如，在面向对象的语言中，你可以把某个类的所有实例都写到一个段里，设置不是本类的成员方法不能对该段进行访问，这样就可以很好地管理一个类。说了半天，也就是，实现一套保护机制十分重要。那么到底是怎么实现的呢？（参考网址 http://www.techbulo.com/708.html）保护模式的实现除了CS,SS,DS,ES,FS,GS这6个段寄存器，还用到了GDT表和LDT表以及跟这两个表对应的两个寄存器：GDTR，LDTR。可能你现在想知道一个段的描述信息到底存放在哪，现在明确告诉你，对于某个段的描述信息来说，在内核中的某个线性地址，有一块连续内存，这块内存的起始地址可以由两个方法确定1. 段寄存器中的段选择子 +  GDTR中的GDT的起始位置 = 一个段的描述信息的描述信息。2. LDTR指向的内存地址。LDT1和LDT2等就是一个段的描述信息。GTD中存放的就是一个段的描述信息的描述信息。GDTＲ中存放GDT的起始地址，ＬＤＴＲ中存放某个段描述信息的起始地址。段寄存器中存放GDT的索引。而某个段描述信息中就有这个段的起始地址，终止地址，访问权限等。保护机制大功告成。但是linux并未使用如此细化的机制（参考网址：http://www.codesec.net/view/199560.html）逻辑地址就是指令中的偏移量，程序使用的都是这个。本来在分段机制下，线性地址是逻辑地址加上由16位段寄存器和GDT找到段描述信息中段起始的值得来的。但linux内逻辑地址和线性地址是一样的，如何做到的呢？那就是，在linux下，使所有的段起始地址都为0，终止地址都为oxfffffff，也就是4GB。所以对于任何用户来说，用户代码段描述符和用户数据段描述符都是一样的，而当切换到内核态时，所有的内核代码段描述符和内核数据段描述符都是一样的。也就是说，所有进程的用户代码段都共享着一个段描述信息（由上面的方法找到），所有的用户数据段也都共享。内核的代码段和数据段也一样。并且，只是通过段描述符中的DPL取值来进行权限管理。比如，内核代码段和数据段的DPL是0，那么就说明只有CPL为0时才能访问。而用户代码段和数据段的DPL为3。权限保护仅此而已，只是区分了内核态和用户态，并没有在多个进程之间进行保护。而进程之间更加细化的保护是页管理中进行的。> 对分段分页的总结：http://blog.sina.com.cn/s/blog_5420e00001013b7o.html这里有一个问题，分页既然能实现更细化的权限访问控制，那么就意味着分段的这点功能分页也完全能实现。那么为什么还非要强行使用分段，把逻辑地址转换为虚拟地址（线性地址），再使用分段，将虚拟地址再转换为物理地址？为什么不直接使用分页机制？因为linux是一个可以兼容多平台的操作系统。其中涉及到了对CPU的兼容。有些CPU，比如Intel的CPU，由于一是为了兼容其以前版本的CPU，二是由于分段存在了很长时间后才出现了分页，所以，CPU指令集中对寻址的指令会有这样一种逻辑：先分段，将逻辑转换为线性，再分页，将线性转换为物理。指令集使用的是逻辑地址，而Intel处理器对逻辑地址的定义是： 【段标识符：段内偏移量】， 也就是说，它硬性地规定了你的程序编译为二进制也就是机器语言后，必定是上面形式的逻辑地址，当程序运行后，它会把段内偏移量和由段标识符找到的段起始地址相加得到线性地址，然后放到地址总线上。也就是必须通过分段机制，才能得到线性地址，然后才能进行页映射。所以，linux为了兼容IntelCPU，也就必须使用分段机制。但是有些CPU，完全没有分段的概念，它的指令集里只有线性地址。那么这种矛盾怎么解决呢？linux巧妙地绕过了分段机制（让所有段起始地址为0，大小为4GB），而且还顺便利用了一下分段机制实现了用户和内核的分离（上面有讲）分页			# 分页管理分页管理其实比分段管理简单，要了解的概念也能少一点。首先，分页管理是将线性地址转换为物理地址。	上面分别是二级映射结构和四级映射结构的寻址方式。这里还是有多个硬件平台需要的映射结构不同。比如i386处理器支持二级映射方式，而有些CPU则需要三级甚至是四级。linux为了兼容各种平台，统一使用四级页表。具体二级和四级是怎么管理的.> 参考：http://blog.sina.com.cn/s/blog_5420e00001013b7o.htmlCPU将线性地址放到地址总线上，但不是直接使用这个线性地址操作内存，它会先经过MMU。ＣＲ３寄存器存放了页目录的起始地址，ＭＭＵ根据页目录的信息，将收到的线性地址转换为物理地址，再放到地址总线上，进行读写内存操作。### 分页实现的更细化的保护：1. 使用页表本身进行越界保护。每个进程只能映射到自己的物理内存。2. 在页表项中设置存取控制位。3. 在页表项中设置访问级别。### 分页的好处：实现了虚拟存储器，可以更高效地管理内存。### 虚拟存储器技术根据程序的局部性原理:1. 时间局部性：由于迭代循环等的存在，在ＣＰＵ访问后的单元在不久之后任然会受到多次循环访问。2. 空间局部性：对进程的某一空间的表或者对战数据进行集中访问。　　　　3. 顺序局部性：对于程序代码的执行，是顺序执行。即便使用了跳转指令跳转到另外一块程序，那么它任然会在跳转到的那块程序顺序访问。也就是说，在某一时间内，程序只会被访问到一部分，那么只需要把这部分装入内存就行了，其他的可以先暂时在磁盘上存放。　　　### 虚拟存储技术需要考虑的点：1. 调入策略：请求页式管理　预调入2. 分配策略：分配空闲内存3. 置换策略：随机淘汰，轮询，先进先出，最近少用# 抖动问题：由于设计问题，给一个进程在内存中分配的页面非常少，内存页面经常出现不足，就需要换出某些页。而如果置换算法设计的方法或者流程不好，则可能刚换出的页马上又要用到，频繁地进行这样的操作，使ＣＰＵ在整个时间片中大部分时间用在了页面换出换入上。这宗现象成为抖动。## 消除方法：1. 根据实际情况，设计出一个合理的工作集。2. 挂起某些进程。3. 缺页频度法：根据缺页发生的频率动态地更改给进程分配的空间。