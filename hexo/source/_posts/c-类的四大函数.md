---
title: c++ 类的四大函数
comments: true
tags:
  - c++
  - 类
categories:
  - c++
date: 2017-03-05 17:33:19
update: 2017-03-05 17:33:19
---

# 类与对象1.	类是用户自定义的一种数据类型，定义类时描述它可以提供的信息及能够执行的操作；即类是一种具有属性和行为的自定义的数据类型；2.	对象就是封装了数据结构，及施加这些数据结构上的操作的封装体；
#	类与对象的关系：类之于对象如同类型之于变量，因此类只是描述了数据格式和方法，而对象则是根据规范创建的实体；换句话说类就像图纸，而对象则是根据图纸盖起的大楼。
#	类与结构体的区别
唯一的区别在于struct的默认访问权限是public,而类是private;
#	C++中的类所占内存分析：
1. 类所占内存的大小是由成员变量（静态变量除外）决定的，成员函数（这是笼统的说，后面会细说）是不计算在内的。成员函数还是以一般的函数一样的存在。a.fun()是通过fun(a.this)来调用的。2. 所谓成员函数只是在名义上是类里的。其实成员函数的大小不在类的对象里面，同一个类的多个对象共享函数代码。而我们访问类的成员函数是通过类里面的一个指针实现，而这个指针指向的是一个table，3. table里面记录的各个成员函数的地址（当然不同的编译可能略有不同的实现）。所以我们访问成员函数是间接获得地址的。所以这样也就增加了一定的时间开销，这也就是为什么我们提倡把一些简短的，调用频率高的函数声明为inline形式（内联函数）。总结：空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。
1. 类内部的成员变量：    普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。    static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。2. 类内部的成员函数：    普通函数：不占用内存。    虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的。#	C++类中的四大函数：构造函数、拷贝构造函数、析构函数和赋值函数:
1.	四个函数一般系统都会默认。但是往往系统默认的并不是我们所期望的，为此我们有必要自己编写符合要求的函数，参看String.cpp;2.	把对象的初始化工作放在构造函数中，当对象被创建时，构造函数被自动执行。3.	把清除工作放在析构函数中。当对象消亡时，析构函数被自动执行，把一切内存垃圾清理，可见他的重要。如果没有析构函数或析构函数不正确就会发生内存泄露等问题，后果非常危险4.	每个类只有一个析构函数和一个赋值函数，但可以有多个构造函数（包含一个拷贝构造函数，其它的称为普通构造函数）。5.	构造函数和赋值函数有着很大的区别，构造函数是在对象创建时调用的；而赋值函数使对象已经创建好了存在之后再赋值时调用的。有时候我们懒得写赋值函数和拷贝构造函数，又不允许别人使用编译器生成的缺省函数，那么我们可以只需将拷贝构造函数和赋值函数声明为私有函数，函数体为空即可；
#	使用对象前正确初始化
1.	并不是所有的编译器都对象对象的内置类型成员会被自动初始化为0。永远在使用对象之前先将它初始化。确保每一个构造函数都将对象的每一个成员初始化。2.	别把赋值错当成初始化。C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前（对于内置类型对象可能不确定），这点对于非内置类型对象来说尤其关键。如果你没有在成员初始化列表（member initialization list）为其初始化，它们将调用自己的默认构造函数，然后才进入构造函数内部（很可能你会在这里给他们赋值）。在成员初始化列表中的初始化只是调用了拷贝构造函数一次，而在构造函数内部再为其赋值则在调用默认构造函数后又调用了一次拷贝构造函数。因此初始化列表将更为高效所以，请用成员初始化列表进行初始化，虽然效率提高只针对于非内置类型成员，但是规定总是在初值列中列出所有成员变量，这样就省的有些未被列出的内置类型成员被忘记初始化。而有些时候，即使成员变量是内置类型，也必须要用成员初始化列表（成员变量为const或者reference，它们一定要有初值，而且不能被赋值）。
#	构造函数
1.	使用构造函数的原因：由于类的封装性,不能象普通变量一样初始化2.	构造函数的作用：是在对象被创建时使用特定的值构造对象，或者说将对象初始化为一个特定的状态。3.	调用时刻：在对象创建时由系统自动调用。如果程序中未声明，则系统自动产生出一个缺省形式的构造函数4.	条件约束：允许为内联函数、重载函数、带缺省形参值的函数；但不允许是虚函数因为在刚开始对象还未被创建，内部什么都没有，更不用说虚表，虚表指针。因此无法调用虚函数。
#	拷贝构造函数（是一种特殊的构造函数，其形参为本类的对象引用）。　作用：使用一个对象（参数指定的对象），去初始化一个正在被建立的同类型对象（如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个拷贝构造函数。）
调用时刻：
1. 	当用类的一个对象去初始化该类的另一个对象时系统自动调用它实现拷贝赋值。2.	若函数的形参为类对象，调用函数时，实参赋值给形参，系统自动调用拷贝构造函数。3.	当函数的返回值是类对象时，系统自动调用拷贝构造函数。#	析构函数作用：完成对象被删除前的一些清理工作。调用时刻：在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间。如果程序中未声明析构函数，编译器将自动产生一个缺省的析构函数。
注意事项：  

1.	析构函数也不被继承，派生类自行声明。2. 声明方法与一般（无继承关系时）类的析构函数相同。3. 不需要显式地调用基类的析构函数，系统会自动隐式调用。4. 析构函数的调用次序与构造函数相反。
#	类组合的构造函数调用1.	构造函数调用顺序：先调用内嵌对象的构造函数（按内嵌时的声明顺序，先声明者先构造）。然后调用本类的构造函数。（析构函数的调用顺序相反）2.	若调用缺省构造函数（即无形参的），则内嵌对象的初始化也将调用相应的缺省构造函数。
# 多继承且有内嵌对象时的构造函数调用次序1.	调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。2.	调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序。
#	静态数据成员
在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。使用静态数据成员可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。
静态数据成员的使用方法和注意事项如下：
1. 静态数据成员在定义或说明时前面加关键字static。2. 静态成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式如下：     <数据类型><类名>::<静态数据成员名>=<值>
     这表明：
1. 初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆。2. 初始化时不加该成员的访问权限控制符private，public等。
3. 初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员。4. 静态数据成员是静态存储的，它是静态生存期，必须对它进行初始化。5. 引用静态数据成员时，采用如下格式：<类名>::<静态成员名>
#	静态成员函数1. 	静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。2.	在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。如果静态成员函数中要引用非静态成员时，可通过对象来引用。3.	调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);4.	类外代码可以使用类名和作用域操作符来调用静态成员函数。
5. 	静态成员函数只能引用属于该类的静态数据成员或静态成员函数。
#	Inline函数
C++ inline函数 ：

	inline int min(int first, int secend) {/****/};
	1. 	inline函数对编译器而言必须是可见的，以便它能够在调用点内展开该函数。与非inline函数不同的是，inline函数必须在调用该函数的每个文本文件中定义。2.	关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。（所以说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。）
#	慎用内联：
内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：
1. 如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。2. 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。
#	内联函数和#define 宏的区别：
内联函数总是对参数只精确地进行一次求值，从而避免了那声名狼藉的宏错误。换句话说，调用内联函数和调用正规函数是等价的，差别仅仅是更快
#	 常函数的调用是这样的：
常量对象只能调用常成员函数，非常量对象即可以调常成员函数，也可以调一般成员函数，但当某个函数有const和非const两个版本时，const对象调const版本，非const对象调非const版本。
#	二义性的问题
1. 	在多继承时，基类与派生类之间，或基类之间出现同名成员时，将出现访问时的二义性（不确定性）——采用虚函数（第8章）或支配（同名覆盖）原则来解决。2.	当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性——采用虚基类来解决。
#	虚基类引入
1. 	用于有共同基类的场合声明2. 	以virtual修饰说明基类	例：class B1:virtual public B
作用：
1. 	主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题.2.	为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝  
**注意：** 在第一级继承时就要将共同基类设计为虚基类。
# 虚基类及其派生类构造函数1.	建立对象时所指定的类称为最（远）派生类。2.	虚基类的成员是由最派生类的构造函数通过调用虚基类的构造函数进行初始化的。3.	在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中给出对虚基类的构造函数的调用。如果未列出，则表示调用该虚基类的缺省构造函数。4.	在建立对象时，只有最派生类的构造函数调用虚基类的构造函数，该派生类的其它基类对虚基类构造函数的调用被忽略。