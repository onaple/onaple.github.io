---
title: c++ 模板
date: 2017-03-05 10:15:38
comments: true
tags:
  - 模板
  - c++
categories:
  - c++
update: 2017-03-05 16:34:59

---
模板是C++支持参数化多态的工具，使用模板可以使用户为类或者函数声明一种一般模式，使得类中的某些数据成员或者成员函数的参数、返回值取得任意类型。
模板是一种对类型进行参数化的工具；通常有两种形式：函数模板和类模板；函数模板针对仅参数类型不同的函数；类模板针对仅数据成员和成员函数类型不同的类。
使用模板的目的：就是能够让程序员编写与类型无关的代码。

注意：模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。
##	 1.函数模板定义格式:	template <class 形参名，class 形参名，......> 返回类型 函数名(参数列表)	{	函数体 }
	> 模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。
## 2.函数模板>1. 函数模板可以用来创建一个通用功能的函数，以支持多种不同形参，进一步简化重载函数的函数体设计。2. 函数模板提供一个种用来自动生成各种类型函数实例的算法，程序员对于函数接口参数和返回类型中的全部或者部分类型进行参数化(parameterize)，而函数体保持不变。  
	**注意**：模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。  
	**注意**：对于函数模板而言不存在 h(int,int) 这样的调用，不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行，即只能进行 h(2,3) 这样的调用，或者int a, b; h(a,b)3. 	函数模板实例化4. 	函数模板只是声明了一个函数的描述即模板，不是一个可以直接执行的函数，只有根据实际情况用实参的数据类型代替类型参数标识符之后，才能产生真正的函数。5.	函数模板的数据类型参数标识符实际上是一个类型形参，在使用函数模板时，要将这个形参实例化为确定的数据类型。将类型形参实例化的参数称为模板实参，用模板实参实例化的函数称为模板函数。模板函数的生成就是将函数模板的类型形参实例化的过程。6.	函数模板在它被调用或取其地址时被实例化7.	模板函数类似于重载函数，但两者有很大区别：函数重载时，每个函数体内可以执行不同的动作，但同一个函数模板实例化后的模板函数都必须执行相同的动作 ## 3.函数模板与同名的非模板函数重载时，应遵循下列调用原则： > 1.	寻找一个参数完全匹配的函数，若找到就调用它。若参数完全匹配的函数多于一个，则这个调用是一个错误的调用。 2.	寻找一个函数模板，若找到就将其实例化生成一个匹配的模板函数并调用它。 3.	若上面两条都失败，则使用函数重载的方法，通过类型转换产生参数匹配，若找到就调用它。4.	若上面三条都失败，还没有找都匹配的函数，则这个调用是一个错误的调用
## 4.类模板定义：	template<class  形参名，class 形参名，…>   	class 类名	{... };
	> 类模板和函数模板都是以template开始后接模板形参列表组成，模板形参不能为空，一但声明了类模板就可以用类模板的形参名声明类中的成员变量和成员函数，即可以在类中使用内置类型的地方都可以使用模板形参名来声明。比如:	
	template<class T> class A{public: T a; T b; T hy(T c, T &d);};## 5.类模板对象的创建：> 1. 比如一个模板类A，则使用类模板创建对象的方法为A<int> m;在类A后面跟上一个<>尖括号并在里面填上相应的类型，这样的话类A中凡是用到模板形参的地方都会被int 所代替。当类模板有两个模板形参时创建对象的方法为A<int, double> m;类型之间用逗号隔开。2. 对于类模板，模板形参的类型必须在类名后的尖括号中明确指定。比如A<2> m;用这种方法把模板形参设置为int是错误的（编译错误：error C2079: 'a' uses undefined class 'A<int>'），类模板形参不存在实参推演的问题。也就是说不能把整型值2推演为int 型传递给模板形参。要把类模板形参调置为int 型必须这样指定A<int> m。## 6.在类模板外部定义成员函数的方法为：	template<模板形参列表> 函数返回类型 类名<模板形参名>::函数名(参数列表){函数体}；> 比如有两个模板形参T1，T2的类A中含有一个void h()函数，则定义该函数的语法为：　

	template<class T1,class T2> void A<T1,T2>::h(){}。
	> 注意：当在类外面定义类的成员时template后面的模板形参应与要定义的类的模板形参一致。## 7.模板的实例化：类模板在引用实际模板类类型时实例化> 1. 定义模板类对象时2. 	通过类指针或引用指向一个类模板实例时，只有当检查这个指针或引用指的那个对象时(访问数据成员或成员函数)，才会实例化3. 	当类模板被实例化时，类模板的成员函数并不自动被实例化。只有该函数被调用或取地址时，才被实例化。4.	静态数据成员只有被使用时才实例化。## 8.类模板和函数模板区别> 1. 函数模板允许重载 ，而类模板不允许重载(类无重载概念，即不存在同名类模板)。2. 类模板可以进行全特化和偏特化，而函数模板仅能够全特化 。3. 类模板支持默认参数，函数模板不支持