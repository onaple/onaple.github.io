<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Talk is cheap, show me the code.  ——Linus Torvalds">
<meta property="og:type" content="website">
<meta property="og:title" content="onaple‘s Blog">
<meta property="og:url" content="http://onaple.duoshuo.com/index.html">
<meta property="og:site_name" content="onaple‘s Blog">
<meta property="og:description" content="Talk is cheap, show me the code.  ——Linus Torvalds">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="onaple‘s Blog">
<meta name="twitter:description" content="Talk is cheap, show me the code.  ——Linus Torvalds">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://onaple.duoshuo.com/"/>





  <title> onaple‘s Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?979c5c7c8651356fd2b2fc892b7537af";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">onaple‘s Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">Good good study, day day up...</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://onaple.duoshuo.com/2017/03/05/x86系统编译原理/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="onaple">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="onaple‘s Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="onaple‘s Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/05/x86系统编译原理/" itemprop="url">
                  x86系统编译原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-05T19:29:07+08:00">
                2017-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/05/x86系统编译原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/05/x86系统编译原理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h1><p>将程序语言的代码转化为其他形式的软件。这个转换过程叫做编译。Eg:c-&gt;(gcc)</p>
<p>Linux可执行的文件通常指符合（ELF）Executable and Linking Format)这种特定形式的文件。ls 、cp 这些命令对应的实体文件都是可执行文件，使用file命令能查看文件是否符合ELF形式。ELF文件包含了程序以及如何运行程序的相关信息（元数据），机器语言是唯一一种cpu能够直接执行的语言，这里的程序或代码就是指机器语言的列表。</p>
<h2 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h2><p>gcc 是将C语言的程序转化为机器语言描述的程序，将机器语言的程序按照ELF这种特定文件格式注入 文件，得到的就是可执行文件。由hello.c这样单个文件来生成可执行文件的过程如下：预处理（.i）侠义的编译(.s)—&gt;汇编(.o)-&gt;链接(.exe)。这个过程统称为build.</p>
<ol>
<li><p>预处理：由编译器对#include和#define进行处理。具体 来说，读入头文件，将所有的宏展开。预处理的内容近似于sed命令和awk命令这样纯文本的操作。</p>
</li>
<li><p>狭义的编译：编译器对预处理器的输出进行编译，生成汇编语言（.s）。</p>
</li>
<li><p>汇编：汇编器将汇编语言的代码转换为机器语言。汇编器的输出文件为目标文件（.o）。linux下目标文件也是ELF文件；目标文件和可执行文件是通过ELF文件中用于提取文件种类的标志。File 命令来查看。</p>
</li>
<li><p>链接：目标文件本身还不能直接使用，无论是直接运行还是作为程序库文件使用都不可以。将目标文件转换为最终可以使用的形式的处理称为链接。使用程序库的情况下，在这个阶段处理程序的加载。通过链接生成的并不一定是可执行文件，也可以是程序库文件。</p>
</li>
</ol>
<h1 id="程序运行的全过程："><a href="#程序运行的全过程：" class="headerlink" title="程序运行的全过程："></a>程序运行的全过程：</h1><p>代码的build-&gt;ELF-&gt;运行加载链接-&gt;进程—&gt;结束</p>
<p>运行环境：链接的话题并非仅出现在build过程。如果使用了共享库，那么在开始运行程序时链接才会发生。动态加载就是一种将所有链接处理放到程序于运行时进行的。</p>
<p>编程语言的运行方式:编译器会对程序进行编译，将其转换为可执行的文件（c/c++）；解释器不将程序转换为别的语言，而直接运行（python）；运行程序的方式不止一种，C语言也可以用解释器来运行，编程语言可以和运行方式自由搭配；编译器、解释器都统称为编程语言的处理器。     根据语言的特点：有静态类型检查，要求较高可靠性的情况下用编译方式；没有静态类型检查，对灵活性要求高于严密性的情况下，则使用解释方式。    静态类检查是指在程序开始运行之前，对函数的返回值以及参数进行检查的功能；在程序运行过程中随时进行类型检查的为动态类型检查。 静态指不运行程序而进行的处理；动态指一边运行程序一边进行某些处理。</p>
<p>狭义的编译过程:语法分析&gt;语义分析&gt;生成中间代码&gt;代码生成。</p>
<p>语法分析 :首先对代码进行解析，将其转化为计算机易于理解的形式，也就是语法树的形式。解析代码的程序模块称为解析器或者语法分析器</p>
<p>语义分析：通过解析语法获得语法树后，接着就要解析语法树，除去多余的内容、添加必要的信息；生成抽象的语法树。</p>
<p>语义分析包括：</p>
<ol>
<li>区分变量为局部变量还是全局变量</li>
<li>解析变量的声明和引用。</li>
<li>变量和表达式的类型检查</li>
<li>检查引用变量之前是否进行了初始化。</li>
<li>检查函数是否按照定义返回了结果</li>
</ol>
<p>语法分析只是对代码的表象进行分析；语义分析是对表象之外的部分级进行分析。语法分析生成的语法树只是将代码的构造照搬过来。而语义分析生成的抽象语法树还包含了语义信息。比如，在变量的引用和定义之间添加链接；适当的增加类型转换命令，是表达式的类型一致；另外语法树中的表达式外侧的括号行末的分号在抽象的语法树都将被省略。</p>
<p>生成中间代码：将抽象语法树转化为只在编译器内部使用的中间代码；之所以特地的转化为中间代码，主要是为了支持多种编程语言或机器语言；</p>
<p>gcc 使用一种名为RTL(Register Transfer Language)的中间代码。解析代码转化为中间代码为止称为编译器的前端。<br>    代码生成：吧中间代码转换为汇编语言，这个阶段为代码生成；负责代码生成的程序模块为代码生成器。<br>    优化：各个环节都可执行优化</p>
<h1 id="语法分析："><a href="#语法分析：" class="headerlink" title="语法分析："></a>语法分析：</h1><h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><ol>
<li>词法分析就是将代码分割为一个个的单词，也可以称为扫描。</li>
<li>在该过程中，会将空白字符和注释这种对程序没有实际意义的部分剔除。</li>
<li>正是因为预先有了词法分析，语法分析才可以只处理有意义的单词，进而实现简化处理。</li>
<li>负责词法分析的模块称为词法分析器，又称为扫描器。</li>
<li><p>Token：在编程语言系统中，将一个单词的字面和他的种类以及语义值统称为token。词法解析器的作用就是解析代码并生成token序列。</p>
</li>
<li><p>编程语言的编译器中的解析器的主要作用是解析有扫描器生成的token序列，并生成代码所对应的树形结构，即语法树。</p>
</li>
<li>语法树和语法是完全对应的，所以c语言的分号以及表达式的括号等都包含在真实的语法树中，但是，没有意义，因此，实际上大部分情况下会生成一开始就省略分号和括号的抽象语法树。也就是说解析器会跳过语法树，直接生成抽象语法树。</li>
</ol>
<p>理想情况是将词法分析、语法分析、语义分析这三个阶段做成3个独立的模块，这样的代码是最优美的。但实际上，这三个阶段并不能明确的分割开来。</p>
<p>语法分析的两层含义：一、语法分析中词法分析以外的部分才称为语法分析。二、词法分析和语法分析合起来称为语法分析。</p>
<h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>定义的分析<br>语句的分析<br>表达式的分析<br>项的分析</p>
<h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><p>变量引用的消解<br>类型名称的消解<br>类型定义的检查<br>表达式有效性的检查<br>静态类型的检查 </p>
<h1 id="计算机内部结构"><a href="#计算机内部结构" class="headerlink" title="计算机内部结构"></a>计算机内部结构</h1><p>计算机的中心是总线（bus）。总线是传送数据的通信干线，它连接了计算机中的各个设备，使之通信，就像人类的血管或者神经系统。</p>
<ol>
<li><p>CPU是负责运算的设备。</p>
<ul>
<li>CPU内部有寄存器，寄存器大小有32位或64位，在cpu计算时，寄存器被用于临时存放数据。通常cpu先将数据从存储器读入寄存器，然后以寄存器为对象进行计算，再将结果写回存储器。<br>将数据从存储器读入寄存器的操作称为加载<br>将数据从寄存器写回存储器的操作称为写回</li>
</ul>
</li>
<li><p>存储器是存储二进制数据的设备。</p>
</li>
<li>进程所使用的地址称为虚拟地址。<ul>
<li>物理存储器的实际地址称为物理地址。</li>
<li>虚拟地址的整体范围称为程序的地址空间。</li>
<li>进程使用虚拟地址访问存储器，cpu内部称为MMU的设备会访问地址转换表进行地址转换。</li>
</ul>
</li>
<li>CPU<ul>
<li>386是x86系列的第一款32位cpu.</li>
<li>Pentinum 4是intel的x86系列第一款64位cpu。</li>
<li>满足1.具备n位宽的通用寄存器 2.具备n位以上的地址空间。 才真正被称为n位cpu。</li>
<li>32位的cpu的通用寄存器的大小为32位，和指针大小相同，地址空间为无符号的32位整数可以指向的范围。64位一样。</li>
<li>X86系列的CPU只要使用PAE(physical address extension)这样的机制，32位的CPU也可以操作36位范围的地址空间</li>
</ul>
</li>
<li>指令集<br>不同的CPU都能够解释的机器语言体系称为指令集架构（ISA， instruction set architecture）,也可以简称指令集。<br>Intel 将x86系列CPU之中的32位CPU的指令集架构称为IA—32.IA(iIntel Architecture).</li>
</ol>
<p></p>
<h1 id="ELF文件的结构"><a href="#ELF文件的结构" class="headerlink" title="ELF文件的结构"></a>ELF文件的结构</h1><p>Linux使用ELF作为目标文件的格式。ELF格式被用于描述目标文件、可执行文件以及共享库的所有信息。<br>无论什么场合，使用ELF格式的目的只有一个，那就是把机器代码以及其对应的元数据以方便的链接器和加载器处理的形式保存起来。<br>代码的元数据包含如下的信息：</p>
<ol>
<li>代码文件的大小以及转换前的源代码文件名。</li>
<li>符号<br>符号指的是变量或者函数的名称。简单的情况下直接使用原编程语言中的函数名或者变量名即可。有时候也会根据不同的编程语言进行特定的变换后得到的符号名称。这种变换称为名称重整。比如c++里的重载。</li>
<li>重定位信息<br>重定位信息用于表示在链接完成前无法确定内存地址的代码位置信息。比如，在共享库内的函数，那么在最终链接完成后才能确定的其内存地址。在这种情况下，目标文件中就会留有“代码中这个位置的内存引用尚未确定”这样的信息。<br>这样的信息就是重定向信息。</li>
<li>调试信息</li>
</ol>
<h2 id="ELF的节和段"><a href="#ELF的节和段" class="headerlink" title="ELF的节和段"></a>ELF的节和段</h2><p>ELF文件结构的二元结构。目的：为了兼顾链接器、汇编器等编译工具以及程序加载到内存中的加载器两者的易用性的需求。</p>
<p>二元结构:如果以程序头信息来处理，则ELF文件可以解释为段集合。如果以节头信息来处理，则可以解释成节集合。</p>
<table>
<thead>
<tr>
<th>节</th>
</tr>
</thead>
<tbody>
<tr>
<td>ELF头</td>
</tr>
<tr>
<td>程序头（描述段）</td>
</tr>
<tr>
<td>.text节</td>
</tr>
<tr>
<td>.rodata节</td>
</tr>
<tr>
<td>.data节</td>
</tr>
<tr>
<td>.got节</td>
</tr>
<tr>
<td>.symtab节</td>
</tr>
<tr>
<td>.strtab节</td>
</tr>
<tr>
<td>节头（描述节）</td>
</tr>
</tbody>
</table>
<p>节（section）：是汇编器、链接器等处理ELF文件内容的单位。ELF文件把不同目的的代码、数据等分割成节保存。比如，机器码统一保存到.text节中。全局变量的初始化数据则保存在.data节中。</p>
<p>段（segment）：则是把程序加载到内存的加载器处理ELF文件时的单位。段由1个以上的字节构成。内存上不同范围有着“只读”、“可写”、“可执行”等不同的属性。因而需要根据属性进行分段。比如机器码如果不可执行就毫无意义，因此要统一到具有可执行属性段中。</p>
<p>目标文件的主要节</p>
<table>
<thead>
<tr>
<th>节名</th>
<th style="text-align:left">内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>.text节</td>
<td style="text-align:left">机器码。配置机器码的节，虽然叫text，但和文本文件没有关系。</td>
</tr>
<tr>
<td>.rodata节</td>
<td style="text-align:left">读专用的.data。配置的字符串字面量等不能更新的数据</td>
</tr>
<tr>
<td>.data节</td>
<td style="text-align:left">全局变量等。在文件中无大小信息。配置的是拥有初始值的全局变量等，这个节的数据在加载后有可能发生变更。</td>
</tr>
<tr>
<td>.bss</td>
<td style="text-align:left">通用符号等。在文件中无大小信息。配置的是没有初始值的全局变量，并且加载到内存后，会被分配所有字节都初始化为0的内存空间。BSS是（Block Started by Symbol）。</td>
</tr>
<tr>
<td>.rel.text节</td>
<td style="text-align:left">.text段中的符号的重定位信息</td>
</tr>
<tr>
<td>.symtab节</td>
<td style="text-align:left">文件中包含的符号表。实际的字面量在.strtab节中保存</td>
</tr>
<tr>
<td>.strtab节</td>
<td style="text-align:left">符号等字符串列表</td>
</tr>
<tr>
<td>.shstrtab</td>
<td style="text-align:left">节名字符串列表</td>
</tr>
<tr>
<td>.line</td>
<td style="text-align:left">代码和原始代码行号对照</td>
</tr>
<tr>
<td>.debug</td>
<td style="text-align:left">调试用的符号信息</td>
</tr>
<tr>
<td>.fini</td>
<td style="text-align:left">进程结束前执行的代码</td>
</tr>
<tr>
<td>.fini_array</td>
<td style="text-align:left">进程结束前执行的函数的指针数组</td>
</tr>
<tr>
<td>.init</td>
<td style="text-align:left">目标文件加载时执行的代码</td>
</tr>
<tr>
<td>.init_array</td>
<td style="text-align:left">目标文件加载时执行的函数的指针数组</td>
</tr>
<tr>
<td>.note</td>
<td style="text-align:left">用于保障兼容性等</td>
</tr>
</tbody>
</table>
<p>Linux下的 binutils包中包含readelf命令可以输出elf文件的结构。</p>
<pre><code>1．    readelf –S hello #输出hello的节头信息。
2．    readelf –l hello #查看hello的程序头。
3．    readelf –s hello #输出符号表。
</code></pre><p>gcc<br>    gcc – c main.c //在编译后中断build.<br>    -o 指定输出文件名。<br>    -v 详细输出其内部处理过程</p>
<p>Linux下负责链接的程序是/usr/bin/ld，这个程序称为GNU ld,一般称为链接器。</p>
<h2 id="链接器可处理的文件："><a href="#链接器可处理的文件：" class="headerlink" title="链接器可处理的文件："></a>链接器可处理的文件：</h2><table>
<thead>
<tr>
<th>文件类型</th>
<th style="text-align:center">格式</th>
<th style="text-align:center">后缀名</th>
<th style="text-align:left">生成器</th>
</tr>
</thead>
<tbody>
<tr>
<td>可重定位文件</td>
<td style="text-align:center">ELF</td>
<td style="text-align:center">.o</td>
<td style="text-align:left">汇编器</td>
</tr>
<tr>
<td>可执行文件</td>
<td style="text-align:center">ELF</td>
<td style="text-align:center">无</td>
<td style="text-align:left">链接器</td>
</tr>
<tr>
<td>共享库</td>
<td style="text-align:center">ELF</td>
<td style="text-align:center">.so</td>
<td style="text-align:left">链接器</td>
</tr>
<tr>
<td>静态库</td>
<td style="text-align:center">UNIX ar</td>
<td style="text-align:center">.a</td>
<td style="text-align:left">ar命令</td>
</tr>
</tbody>
</table>
<p>可重定位文件指汇编器生成的目标文件(.o)。GNU as 生成的可重定位文件没有程序头，因此不能直接运行，只有配合链接器与其他可重定位文件、库产生连接后才可执行。</p>
<p>可执行文件指的是链接生成的用户可直接运行的目标文件。Linux下可执行文件没有后缀名</p>
<p>共享库是链接生成的另一种形式的目标文件，其中集合了各个函数、变量等供用户调用，因此需要能够再次和其他目标文件链接使用。共享库不会直接运行。共享库也叫动态链接库。Linux下的共享库文件名一般以lib开头，以.so作为后缀，并加上版本号。</p>
<p>静态库文件可以作为链接器的输入。和共享库文件一样，静态库文件也集合了各种函数、变量供其它用户使用。一般以lib开头，以.a作为后缀。静态库文件利用ar命令把多个可重定位文件打包成一个，因此链接静态库文件就相当于链接其中打包的所有可重定位文件。</p>
<h1 id="什么是链接"><a href="#什么是链接" class="headerlink" title="什么是链接"></a>什么是链接</h1><p>链接指的是把多个目标文件关联为一个整体。而通过关联多个目标文件，就可生成同时使用多个目标文件定义的变量、函数的程序。</p>
<p>具体步骤：</p>
<ol>
<li>合并节</li>
<li>重定位 </li>
<li>符号相消</li>
</ol>
<p>此外，链接时还必须进行很多其他的处理。比如，在生成ELF文件时，需要为程序生成合适的程序头信息。不过归根到底，链接的主旨是关联目标文件，因此主要处理也就是上述三点。</p>
<h2 id="合并节："><a href="#合并节：" class="headerlink" title="合并节："></a>合并节：</h2><p>在链接多个目标文件时，需要从各个目标文件中抽取节，把相同种类的节合并到一起。</p>
<h2 id="重定位："><a href="#重定位：" class="headerlink" title="重定位："></a>重定位：</h2><p>指根据程序实际加载到内存时的地址，对目标文件中的代码和数据进行调整。<br>在链接文件时，根据整体情况决定“真实的”内存地址，把所有用虚拟内存地址的地方替换成真实的内存地址。这个处理就是重定位。</p>
<h2 id="符号相消"><a href="#符号相消" class="headerlink" title="符号相消"></a>符号相消</h2><p>指为了可以使用其他目标文件和库文件中提供的变量和函数，把尚未和实体链接的符号与具体的变量和函数等实体链接起来的操作。例如：mian.c中有printf函数，汇编器会把“这个目标文件中使用的printf函数的函数体在其他文件中”这个信息保留下来。这个信息就是未定义的符号。接下来，再进行链接操作的时候，再检索未定义的符号，把相关的变量或者函数的内存地址链接进来。这个处理就是符号消解。</p>
<p>符号相消和重定位联系紧密，比如上面的printf函数，编译mian.c时printf函数的地址是未知的，这时编译器为printf函数分配虚拟地址，并生成类似call printf的汇编指令，然后在链接时再把函数的内存地址修正为正确的地址。而这个“先设置虚拟地址，在链接时修正为正确的地址”的处理正是重定位操作，因此符号消解本身可以通过重定位来实现。<br>总体来说，像上面这样解释目标文件代码的含义，把目标文件从物理上、逻辑上连接起来，从而生成可执行文件的处理就是“链接”。</p>
<h2 id="动态链接和静态链接"><a href="#动态链接和静态链接" class="headerlink" title="动态链接和静态链接"></a>动态链接和静态链接</h2><p>静态库在build，也就是执行ld命令的时候就会进行目标文件的链接，<br> 而共享库在build的时候不会进行目标文件的链接，而只是检查共享库和符号是否存在，在程序运行时才在内存上实际链接目标文件。<br>    其中，在build时链接目标文件的的链接操作称为静态链接。<br>    而在程序执行时链接目标文件的链接操作则称为动态链接。<br>    给链接器输入多个重定位文件时，这些文件被执行静态链接。<br>    动态链接有容易更新、节省磁盘空间、节省内存的优点。Linux下也主要使用共享库和动态链接。gcc也是如此，不加任何选项的话执行的动态链接，而静态库的静态链接只在个别情况下使用。缺点：性能稍差、链接具有不确定性。</p>
<pre><code>Eg:
动态链接：
gcc –c main.c
gcc –c f.c
gcc main.o f.o –lc –o prog
-l选项可以为链接指定库
Ldd prog  //查看是否被动态链接。

静态链接：
gcc –static main.o f.o –lc –o prog
file prog

生成库

生成静态库
用ar生成静态库，和tar命令差不多
eg：$ ar crs libmy.a f.o g.o h.o
选项
含义
c
如果存档不存在，则创建
r
向存档添加文件
S
生成加速链接的索引

Linux下优化执行时共享库的检索速度，加载器会对共享库的信息建立缓存文件。这个缓存文件就是 /etc/ld.so.cache。安装新版本的共享库时，一定要更新这个缓存文件，更新缓存文件的需要以管理员的权限运行ldconfig命令。

gcc –c –fPIC f.c
gcc –c –fPIC g.c
gcc –share –WL, -soname, libfg.so.1 f.o g.o –o libfg.so.1
file libfg.so.1
</code></pre><p></p>
<h1 id="加载程序"><a href="#加载程序" class="headerlink" title="加载程序"></a>加载程序</h1><p>利用mmap系统调用进行文件映射，把程序加载到内存中。所谓的映射，意思是可以通过读取内存直接获得文件的内容，也可以通过写内存对文件的内容进行修改</p>
<p>在linux下，通过使用Proc文件系统，就可以表示进程利用mmap系统调用把文件映射到内存的范围信息。例如，利用cat /proc/44337/maps就可以表示44437进程中文件映射的信息。通过readelf –l /tmp/showmap 可以输出程序头。里面有elf段和内存空间的对应关系。<br>ELF文件中拥有实体的段都是通过mmap系统调用来加载的。不过进程的内存空间中也存在不和ELF文件对应的部分，比如，和.bss等节对应的空间、机器栈、堆。</p>
<h2 id="动态链接的过程"><a href="#动态链接的过程" class="headerlink" title="动态链接的过程"></a>动态链接的过程</h2><p>目标文件的种类不同，加载ELF文件的主体也不同。程序由系统内核加载，共享库由动态链接加载器加载。</p>
<p>动态链接加载器是指加载并链接动态链接的程序本身及其链接的共享库，设置程序运行状态的程序。Linux下常用的动态链接加载器是/lib/ld-linux.so.2。动态链接加载器的统称为ld.so。使用ELF文件的系统中，程序ELF文件的INTERP段需要指定动态链接加载器的路径。系统内核在启动程序时读入此段的内容，从而加载，启动程序。换句话说，动态链接器和动态链接加载器的运作过程并无二致。<br>从ld.so链接程序到程序的执行完毕过程。</p>
<blockquote>
<ol>
<li>加载程序</li>
<li>启动ld.so</li>
<li>读入共享库</li>
<li>符号相消和重定位</li>
<li>初始化</li>
<li>跳转到程序入口</li>
<li>程序终止处理</li>
</ol>
</blockquote>
<p>首先系统内核加载程序和ld.so，准备好运行环境后交由ld.so处理。完成启动的ld.so根据系统内核传递的参数进行初始化。接着读取程序的DYNAMIC段，加载所有可执行文件链接的共享库。对已经加载的共享库也执行同样的处理，递归加载所有的共享库。一旦加载完所需要的库，马上消解所有程序和代码库中的符号，并重定位代码。这样就完成了启动程序的准备工作。在执行了各个文件的初始化代码后，跳转到程序的入口，这样就启动了程序。在C语言程序中，也就是执行了main函数的意思。程序执行完毕后，最后会对每个文件执行终止处理，这样整个执行过程最终完成。 </p>
<p>反汇编指的是从机器码恢复到汇编代码的过程。Linux上使用binutils包的objdump命令就可以反汇编一个程序，eg: objdump –d hello</p>
<p>C语言中设定程序是从main函数开始执行，但实际上程序最初是从_start函数开始执行的。_start函数由lib提供的/usr/lib/crtl.o文件定义，ctrl.o在这个文件在编译时是默认链接的。_start函数会初始化libc，之后调用mian函数。</p>
<p>执行终止处理，接下来从main函数返回，接着ld.so会执行终止处理代码。用于初始化的有.init节和.init_array节，相应的，终止处理有.fini节和.fini_array节。.fini节保存进程终止时的代码，而.fini_array则保存进程终止时执行的函数指针列表。程序执行完后，ld.so会调用exit系统调用终止进程。Exit系统调用和平时使用的exit函数不同。C语言调用exit系统调用时，调用的是_exit函数。_exit函数执行libc的终止处理代码（.fini节和.fini_array节）后，执行exit系统调用结束进程。而exit系统调用会跳过终止处理，立即结束进程。这就是ld.so所有处理过程。</p>
<p>动态加载指的是在程序运行时指定共享库名称进行加载的方法。动态加载经常被用于实现所谓的插件。Linux中使用dlopen()函数进行动态加载。动态链接的程序最初一定已经加载了ld.so。而程序启动后它依然保存在内存上。因此只需要调用内存中的ld.so的代码，就可以在程序开始执行之后也能进行动态链接处理。</p>
<p>地址无关代码指的是无论加载到那个地址，都不需要重定位也能运行的代码。共享库的代码一定要是地址无关的代码，这一点很重要共享库一定要设置为地址无关代码，是为了实现库共享。要实现地址无关的代码，必须改变两点：一是全局变量的访问，二是 外部函数的调用。</p>
<p>访问全局变量的代码一定要把绝对地址改为相对地址。可以使用全局偏移表（GOT）的结构。GOT是指向全局变量的指针数组，链接器为其申请内存空间，动态链接加载器初始化其内容。地址无关代码就是通过 从这个GOT中读取地址而做到地址无关的。</p>
<p>外部函数如何调用地址无关的代码。Linux下为了使函数调用地址独立，使用了一种可以称之为GOT的函数版的方法—过程链接表（PLT）。不过PLT一般比GOT的入口数多，因此会采取延迟初始化。也就是说，外部函数第一次调用该函数时，该函数才会被链接。</p>
<p>地址无关的可执行文件（PIE）。指的是使用地址无关代码的可执行文件。因为地址无关，所以可以被加载到任意地址。 </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://onaple.duoshuo.com/2017/03/05/程序员自我修养简记/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="onaple">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="onaple‘s Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="onaple‘s Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/05/程序员自我修养简记/" itemprop="url">
                  程序员自我修养简记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-05T19:08:29+08:00">
                2017-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/05/程序员自我修养简记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/05/程序员自我修养简记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><ol>
<li>对于系统程序开发者来说，计算机三个部件最为关键：CPU、内存、I/O控制芯片。</li>
<li>高速的北桥芯片：为了协调CPU、内存和高速的图形设备。此时慢速的I/O总线已经无法满足需求。</li>
<li>低速设备的南桥芯片：由于北桥芯片运行速度非常高，于是人们有设计了低速设备的南桥芯片，磁盘、usb、键盘、鼠标等设备都连接在南桥芯片上，由南桥芯片将他们汇总后链接到北桥上。</li>
<li>SMP(对称多处理器)多CPU的计算机；简单的来讲就是每个CPU在系统中所处的地位和发挥的功能是一样的，是相互对称的。使用场景：大型数据库、网络服务器上，他们要求同时处理大量的请求，而这些请求时相互独立的，所以多处理器就可以最大效能的发挥作用。多处理器最多的应用场合时这些商用的服务器和需要处理大量计算的环境。（CPU频率碰到了天花板4GHZ,才出现了SMP）.</li>
<li>多核处理器：实际上就是SMP的简化版。这是由于多处理器成本高，所以厂商将多个处理器“合并在一起打包出售”，这些被打包的处理器之间共享比较昂贵的缓存部件，只保留多个核心；并且以一个处理器的外包装进行出售，价格比单核处理器只贵一点。当然他们在缓存共享方面有细微的差别，但是从程序员的角度来看，他们的区别很小，逻辑上看他们是完全相同的。</li>
<li>系统软件：传统意义上一般将用于管理计算机本身的软件称为系统软件，以区别普通的应用程序。系统软件可以分为两块；一块是平台性的，比如，操作系统内核、驱动程序、运行库和数以千记得系统工具；另一块是用于程序开发的，比如，编译器、链接器、汇编器等开发工具和开发库。</li>
<li>计算机系统软件体系结构采用一种层的结构：计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。</li>
<li><p>接口：每个层次之间都必须要相互通信，则需要一个通信协议，我们一般将其称为接口。接口下面那层是提供者，上层是使用者。除了硬件和应用程序，其他层都是中间层，每个中间层都是对它下面的那层的包装与扩展。正是由于这些中间层的存在，使得应用程序和硬件之间保持相对独立。</p>
</li>
<li><p>在软件体系结构中：位于最高层的是应用程序。从整个层次结构上来看，开发工具与应用程序属于同一层，因为他们都使用同一接口，那就是操作系统应用程序编程接口。应用程序接口的提供者是运行库。<br>运行库使用操作系统提供的系统调用接口，系统调用接口往往以软中断的方式提供；比如，linux使用0x80号中断作为系统调用接口。<br>硬件规格: 操作系统内核层对于硬件层来说是硬件接口的使用者，而硬件是接口的定义者，硬件的接口的定义决定了操作系统的内核，具体来讲就是驱动程序如何操作硬件，如何与硬件通讯，这种接口被叫做硬件规格。</p>
</li>
<li><p>操作系统：一个功能是提供抽象的接口，另外一个主要功能就是管理硬件资源。</p>
</li>
<li>多道程序的设计：编写一个监控程序，当某个程序暂时无需使用CPU时，监控程序就把另外的正在等待CPU资源的程序启动起来，使得CPU能够充分利用起来，这种被称为多到程序。</li>
<li>分时系统：每个程序运行一段时间后都主动让出CPU给其他的程序，使得一段时间内每个程序都有机会运行一小段时间。</li>
<li>多任务系统：操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别，每个进程都有自己的独立空间，使得进程之间的地址相互隔离。CPU由操作系统同一分配，每个进程都会根据进程优先级的高低都有机会得到CPU.但是，如果运行超出了一定的时间，操作系统会暂停该进程，将CPU资源分配给其他的等待运行的进程，这种CPU分配方式为抢占式。</li>
<li>驱动程序可以看做事操作系统的一部分，它往往和系统内核一起运行在特权级别，但他与操作系统内核之间有一定的独立性，使得驱动程序有较好的灵活性。操作系统开发者为硬件生产商提供了一系列接口和框架，凡是按照这个接口和框架开发的驱动程序都可以在该操作系统上使用。</li>
<li>进程的总体目标是希望每个进程从逻辑上看都可以独占计算机的资源。操作系统的多任务功能使得CPU能够在多个进程之间共享；从进程的角度看好像是他独占了CPU而不用考虑与其他进程分享CPU的事。操作系统的I/O抽象模型也很好的实现I/O设备的共享和抽象。内存通过虚拟地址空间；分段分页来实现共享。</li>
</ol>
<h1 id="为什么要虚拟内存："><a href="#为什么要虚拟内存：" class="headerlink" title="为什么要虚拟内存："></a>为什么要虚拟内存：</h1><p>如果程序直接在物理内存上使用，直接访问物理地址将带来很多问题：</p>
<ol>
<li>地址空间不隔离：所有程序都访问物理地址，程序所使用的内存空间不相互隔离，恶意的程序可以很容易改写其他程序的内存数据，以达到破坏的目的。有些非恶意、但有臭虫的程序可能不小心修改ill其他程序的数据，就会使其他程序崩溃。而使用虚拟地址空间可保证一个任务的失败不影响其他任务的执行。</li>
<li>内存使用效率低：由于没有有效的内存管理机制，通常需要一个程序执行时，监控程序就将整个程序装载进内存然后执行。内存不够时会发生大量的数据交换，效率低下。</li>
<li>程序运行的地址不稳定：因为程序每次需要装入运行时，我们都需要给他从内存中分配一块足够大的内存空间区域，这个区域位置不确定；这给程序的编写造成一定的麻烦，因为程序在编写时，它访问的数据和指令跳转时的目标地址很多都市固定的，这涉及到重定位问题。</li>
</ol>
<p>解决问题的思路就是增加中间层，即使用一种间接地址访问方法。我们把程序给出的地址看作是一种虚拟地址，然后通过某种映射，将虚拟地址转 换为物理地址。这样，只要我们能够妥善控制这个虚拟地址到物理地址的映射过程，就可以保证任意一个程序所能够访问的物理内存区域跟另一个程序相互不重叠，以达到地址空间隔离的效果。物理地址空间是真真实实存在的；虚拟地址空间是指虚拟的，而且每个进程只能访问自己的地址空间，这样就有效的做到了进程的隔离。</p>
<h2 id="分段："><a href="#分段：" class="headerlink" title="分段："></a>分段：</h2><p>解决了第一个和第三个问题。首先，它做到了地址的隔离，如果程序访问越界，将会被硬件判断为非法访问，拒绝这个地址请求，并将这个请求报告给操作系统或者监控程序。再者，对于每个程序员来说，无论他们被分配到物理地址的那个区域，对于程序来说都是透明的。他们不需要关心物理地址的变化。    但分段没有解决内存使用效率问题；分段对内存区域的映射还是按照程序为单位；如果内存不足，被换入换出到磁盘的都是整个程序，这样势必会造成大量的磁盘访问操作，从而严重影响速度。这种方法换是显得比较粗糙，粒度比较大。<br>事实上，根据程序的局部性原理，当一个程序在运行时，在某个段内，它只是频繁的用到一小部分数据，也就是说，程序的很多数据其实在一段时间内都是不会被用到的。人们很自然的想到了更小粒度的内存分割和映射的方法，使得程序的局部性原理得到充分的利用，大大提高了内存使用率，这种方法就是分页。</p>
<h2 id="分页："><a href="#分页：" class="headerlink" title="分页："></a>分页：</h2><p>提高了内存的使用率，减少了内存碎片的产生；保护也是页映射的目的之一。简单来说就是每个页可以设置权限属性，只有操作系统有权限修改这些属性。MMU都集成在CPU的内部了，不会以独立的部件存在。</p>
<h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><p>线程：有时被称为轻量级的进程（LWP）,是程序执行流的最小单位。一个标准的线程是由线程ID\当前指令指针（PC）、寄存器集合和堆栈组成。通常意义上，一个进程由一到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）以及一些进程级的资源（打开的文件和信号）。</p>
<p>使用多线程的原因：</p>
<ol>
<li>某个操作可能会陷入长时间的等待，等待的线程会进入睡眠状态，无法继续执行，多线程执行可以有效的利用等待的时间。典型的例子是等待网络响应，这可能要花费数秒。</li>
<li>某个操作（计算）会消耗大量的时间，如果只有一个线程，程序和用户之间的交互会中断。多线程可以让一个线程负责交互，另一个线程负责计算。</li>
<li>程序本身就要求并发操作。、</li>
<li>多CPU或多核计算机，本身具备同时执行多个线程的能力，因此单个线程程序无法全面的发挥计算机的全部计算能力。</li>
<li>相对于多进程应用，多线程在数据共享方面效率要高得多。</li>
</ol>
<h1 id="线程的访问权限"><a href="#线程的访问权限" class="headerlink" title="线程的访问权限"></a>线程的访问权限</h1><p>线程的访问非常自由，它可以访问进程内存空间内的所有数据，甚至包括其他线程的堆栈（如果他知道其他线程的堆栈地址，这是很少见的情况），但实际运用中线程也拥有自己的私有存储空间：</p>
<ol>
<li>栈：尽管并非完全无法被其他线程访问，但一般情况下仍然可以认为是私有数据。</li>
<li>线程局部存储，是某些操作系统为线程单独提供的私有空间，但通常只具有很有限的容量。</li>
<li>寄存器：寄存器是执行流的基本数据，因此为线程私有。</li>
</ol>
<h1 id="从C程序员的角度看，数据在线程之间是否私有："><a href="#从C程序员的角度看，数据在线程之间是否私有：" class="headerlink" title="从C程序员的角度看，数据在线程之间是否私有："></a>从C程序员的角度看，数据在线程之间是否私有：</h1><p>私有：局部变量、函数参数、TLS线程局部存储数据</p>
<p>线程之间共享进程所有：全局变量、堆上的数据、函数里的静态变量、程序代码，任何程序都有权读取并执行任何代码、打开的文件。</p>
<p>线程调度：一个不断在处理器上切换不同线程的的行为。线程通常至少拥有三种状态：运行、就绪、等待。</p>
<p>IO密集型线程：频繁等待的线程；CPU密集型线程：很少等待的线程；IO密集型的线程总比cpu密集型的线程容易得到优先级的提升。</p>
<p>对于linux来说，线程并不是一个通用的概念；linux对多线程支持颇为贫乏；事实上，在linux内核中并不存在真正意义上的线程的概念。Linux将所有可执行的实体称为任务（TASK）,无论是进程换是线程。每一个任务概念上都类似于一个单进程的线程，具有内存空间、执行实体、文件资源。不过，linux下不同任务之间可以选择共享内存空间，因而在实际意义上，共享同一个内存空间的多个任务构成了一个进程，这些任务也就成为了这个进程里的线程。在linux下，用以下方法可以创建一个新的任务。</p>
<table>
<thead>
<tr>
<th>系统调用</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>fork</td>
<td style="text-align:left">复制当前进程</td>
<td style="text-align:left">新的任务启动并和本任务一起从fork返回，本任务返回的是新任务的pid,新任务返回0。Fork速度非常快，因为采用了写时复制。Fork只能产生本任务的镜像。</td>
</tr>
<tr>
<td>exec</td>
<td style="text-align:left">使用新的可执行映像覆盖当前可执行映像</td>
<td style="text-align:left">Fork+exec启动别的新任务。</td>
</tr>
<tr>
<td>Clone</td>
<td style="text-align:left">创建子进程并从指定位置开始执行</td>
<td style="text-align:left">产生新的线程使用clone。从指定的位置开始执行，并且（可选）共享当前的内存空间和文件等。如此就可以在实际效果上产生一个线程。</td>
</tr>
</tbody>
</table>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>同步：为了避免多个线程同时读写同一个数据而产生不可预料的结果，我们需要将各个线程对同一个数据的访问同步。所谓的同步，既是指在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。如此，对数据的访问被原子化了。<br>同步的方式：</p>
<ol>
<li>锁、</li>
<li>二元信号量、（多元）信号量（对于允许多个线程并发访问的资源，它是一个很好的选择；一个初始值为n的信号量允许N个线程并发访问。）</li>
<li>互斥量：和二元信号量很类似，资源进同时只能被一个线程访问。不同的是，信号量在整个系统可以被任意线程获取并释放。而互斥量则要求那个线程获取了互斥量，那个线程就要负责释放这个锁。</li>
<li>临界区：是比互斥量更加严格的同步手段。把临界区的锁获取称为进入临界区，释放称为离开临界区。临界区和互斥量与信号量的区别在于，互斥量和信号量在系统的任何进程里都是可见的，也就是说，一个进程创建了一个互斥量或者信号量，另一个进程试图获取该锁是合法的。然而，临界区的作用范围仅限于本进程，其他进程无法获取该锁。除此之外，临界区胡互斥量具有相同的性质。</li>
<li>读写锁：适用于读频繁写少的情况。对于一段数据，多个线程同时读取总是没有问题的，写时必须上锁。</li>
<li>条件变量：作用类似一个栅栏。线程有两种操作，等待与唤醒。使用条件变量可以让许多线程一起等待某个事件的发生，当时间发生时，条件变量被唤醒，所有的线程可以一起恢复执行。</li>
</ol>
<h1 id="可重入与线程安全"><a href="#可重入与线程安全" class="headerlink" title="可重入与线程安全"></a>可重入与线程安全</h1><p>一个函数要被重入只有两种情况：一是多个线程同时执行这个函数；二是函数自身调用自身。一个函数被重入表示这个函数没有被执行完成，由于外部因素或者内部调用，又一次进入函数执行。一个函数可重入，表明函数重入后不会产生任何不良的后果。一个函数要成为可重入的，必须具有</p>
<p>如下几个特点：</p>
<ol>
<li>不使用任何（局部）静态或全局的非const变量。</li>
<li>不返回任何（局部）静态或者全局的非const变量的指针。</li>
<li>仅依赖于调用方提供的参数。</li>
<li>不依赖任何单个资源的锁。</li>
<li>不调用任何可重入的函数。</li>
</ol>
<p>可重入是并发的强力保障，一个可重入的函数可以在多线程环境下放心使用。</p>
<h2 id="过度优化"><a href="#过度优化" class="headerlink" title="过度优化"></a>过度优化</h2><p>Volatile关键字:一是阻止编译器为了提高速度将一个变量缓存到寄存器中而不写回；二是阻止编译器调整volatile变量的指令顺序。<br>Barrier：因为即使volatile可以阻止编译器调整顺序，也无法阻止CPU动态调度换序。现在并不存在可移植的阻止换序的方法。通常情况下是通过调用CPU提供的一条指令，这条指令被称为barrier。它可以阻止cpu将该指令之前的指令交换到它之后，反之亦然。Barrier指令的作用类似于一个拦水坝，阻止换序穿透这个大坝。</p>
<h1 id="三种线程模型"><a href="#三种线程模型" class="headerlink" title="三种线程模型"></a>三种线程模型</h1><p>Windows和linux，都是在内核里提供线程的支持。内核线程，这里的内核线程和linux内核里的kernel_thread并不是一回事，它和我们之前讨论的一样，由多个处理器或调度器来实现并发。然而用户实际使用的的线程不是内核线程，而是存在于用户态的用户线程。用户线程并不一定在操作系统内核内对应着同样数量的内核线程。<br>用户态多线程库的实现</p>
<ol>
<li>一对一模型：用户线程具有和内核线程一致的优点，线程之间的并发，是真正的并发。一个线程阻塞，其他线程不会受到影响。一对一模型可以让多线程程序在多处理器的系统上有跟好的体现。一般直接使用API或系统调用创建的线程均为一对一的线程。</li>
</ol>
<blockquote>
<p>缺点：一是由于许多操作系统限制了内核线程的数量，因此一对一线程会让用户的线程数量受到限制。二是许多操作系统内核线程调度时，上下文切换开销大，导致用户线程的执行效率下降。</p>
</blockquote>
<ol>
<li>多对一模型：线程间的切换由用户态的代码来进行，线程切换的速度要快许多，但是一个用户线程阻塞，那么所有线程都将无法执行，因此此时内核里的线程也随之阻塞了。多对一模型的好处就是高效的上下文切换和几乎无限制的线程数量。</li>
<li>多对多模型：一个用户线程阻塞并不会使得所有用户线程阻塞，因为此时还有别的线程可以被调度来执行。另外，多对多模型对用户线程的数量没有什么限制，在多处理器上，线程也能得到一定性能的提升。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://onaple.duoshuo.com/2017/03/05/linux-基础常识/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="onaple">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="onaple‘s Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="onaple‘s Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/05/linux-基础常识/" itemprop="url">
                  linux 基础常识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-05T18:18:13+08:00">
                2017-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/05/linux-基础常识/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/05/linux-基础常识/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><ol>
<li>Linux可划分为：linux内核、GNU工具、图形化桌面环境、应用软件。</li>
<li>内核主要负责：系统内存管理、软件程序管理、硬件设备管理、文件系统管理。</li>
<li>交换空间：内核通过硬盘上的存储空间来实现虚拟内存的这块区域。</li>
</ol>
<h1 id="linux内核"><a href="#linux内核" class="headerlink" title="linux内核"></a>linux内核</h1><h2 id="1-内存管理"><a href="#1-内存管理" class="headerlink" title="1.内存管理:"></a>1.内存管理:</h2><p>分段分页</p>
<h2 id="2-软件程序管理："><a href="#2-软件程序管理：" class="headerlink" title="2.软件程序管理："></a>2.软件程序管理：</h2><p>内核控制着linux系统如何管理运行在系统上的所有进程。内核创建的第一个进程称为init进程，它是用来启动系统上所有其他进程的。当内核启动时，它会将init进程加载到虚拟内存中。内核在启动任何其他进程，都会在虚拟内存中给新进程分配一块专有的区域来存储该进程用到的数据和代码。</p>
<p>一些linux发行版使用一个表来管理在系统开机时要启动的进程。在linux上这个表通常位于专门文件/etc/inittab中。Ubuntu则采用/etc/init.d目录，将开机时启动或者停止某个应用脚本放在这个目录下。这个脚本通过/etc/rcX.d目录下的入口启动，这里X代表运行级别。Linux操作系统的init系统采用了运行级别。运行级别决定了init进程运行/etc/inittab文件或/etc/rcX.d目录中定义好的某些特定的进程。Linux操作系统有5个启动运行级别。</p>
<p>运行级别为一时，只启动基本的系统进程以及一个控制台终端进程，我们称之为单用户模式。单用户模式通常用来在系统有问题的时候进行紧急的文件系统维护。</p>
<p>标准的启动运行级别是3，在这个运行级别上，大多数应用软件，比如网络支持程序都会启动。<br>运行级别5上系统启动图形化的X window系统，允许用户通过图形化桌面窗口登录系统。</p>
<ol>
<li><p>硬件设备管理：任何linux系统需要与之通讯的设备，都需要在内核代码中加入其驱动程序代码。驱动程序代码相当于应用程序和硬件设备的中间人，允许内核与设备之间交互数据。在linux内核中有两种方法用于插入设备驱动的代码，第一，编译进内核的设备驱动代码，第二，可插入内核的设备驱动代码。<br>Linux将硬件设备当成特殊的文件，称为设备文件。设备文件有：字符型设备文件、块设备文件、网络设备文件。</p>
</li>
<li><p>文件系统管理：linux内核支持不同类型的文件系统从硬盘中读取数据。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ext</td>
<td style="text-align:left">Linux 扩展文件系统，最早的linux文件系统</td>
</tr>
<tr>
<td>Ext2</td>
<td style="text-align:left">第二扩展文件系统，在ext的基础上提供了更多的功能。</td>
</tr>
<tr>
<td>Ext3</td>
<td style="text-align:left">第三扩展文件系统，支持日志功能。</td>
</tr>
<tr>
<td>Ext4</td>
<td style="text-align:left">第四扩展文件系统，支持高级日志功能。</td>
</tr>
<tr>
<td>Hpfs</td>
<td style="text-align:left">Os/2高性能文件系统。</td>
</tr>
<tr>
<td>Nfs</td>
<td style="text-align:left">网络文件系统</td>
</tr>
<tr>
<td>Proc</td>
<td style="text-align:left">访问系统信息</td>
</tr>
<tr>
<td>ReiserFS</td>
<td style="text-align:left">高级linux文件系统，能够提供更好的性能和硬盘恢复功能</td>
</tr>
</tbody>
</table>
<p>Linux内核采用虚拟文件系统（VFS）作为和每个文件系统交互的接口。这为linux内核同任何类型的文件系统通信提供了一个标准的接口。当每个文件系统都被挂载和使用的时候，VFS将信息都缓存在内存中。</p>
<h1 id="GNU工具"><a href="#GNU工具" class="headerlink" title="GNU工具"></a>GNU工具</h1><p>GNU(GNU‘s Not Unix 的缩写) linux 内核和GNU工具的结合成为linux</p>
<ol>
<li>核心GNU工具：GNU项目的主旨在于为UNIX系统管理员设计出一套类似于UNIX的环境。这个目标促使该项目移植了很多常见的unix系统命令行工具。供linux系统使用的这组核心工具被称为coreutils(core utilities)软件包。它由三部分构成：处理文件的工具、操作文本的工具、管理进程的工具。</li>
<li>Shell<br>GNU/Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在linux系统上的进程的途径。Shell的核心是命令提示符。命令提示符是设立负责交互的部分。它允许你输入文本命令，然后解释命令，并在内核中运行。<br>  Shell包含一组内部命令，它也允许你输入程序的名称，将程序名称传递给内核以启动它。<br>  所有linux发行版本默认的shell都是bash shell。Bash shell 由GNU项目开发，被当作标准的Unix shell(bourne shell以创建者命名)的替代品。Bash shell 的名字就是针对bourne shell 的拼写玩的一个文字游戏，称为bourne again shell。</li>
</ol>
<table>
<thead>
<tr>
<th>shell</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ash</td>
<td style="text-align:left">一个运行在内存受限环境中简单的轻量级的shell，但和bash shell 完全兼容</td>
</tr>
<tr>
<td>Korn</td>
<td style="text-align:left">一种与bourne shell 兼容的编程shell，但支持一些高级编程特性：关联数组和浮点运算</td>
</tr>
<tr>
<td>Tcsh</td>
<td style="text-align:left">一种将C语言中的一些元素引入shell脚本中的shell。</td>
</tr>
<tr>
<td>Zsh</td>
<td style="text-align:left">一种结合了bash tcsh korn 的特性，同时提供了高级编程特性，共享历史文件和主题的高级shell。</td>
</tr>
</tbody>
</table>
<h1 id="linux桌面环境"><a href="#linux桌面环境" class="headerlink" title="linux桌面环境"></a>linux桌面环境</h1><ol>
<li>x window系统:它是直接和PC上的显示器以及显卡打交道的底层程序。它控制这linux程序如何在电脑上显示漂亮的窗口和图形。</li>
<li>KDE(K Desktop Enivironment): 它允许你把应用程序图标和文件图标放置在桌面上。单击应用程序图标，linux就会运行该应用程序。</li>
<li>GNOME（the GNU Network Object Model Environment, GNU网络对象模型环境），用的最多是Red Hat Linux.</li>
<li>Unity桌面：ubuntu的桌面环境。目标为工作站、平板电脑以及移动设备提供一致的桌面体验。</li>
</ol>
<h1 id="Linux发行版通常分为三类："><a href="#Linux发行版通常分为三类：" class="headerlink" title="Linux发行版通常分为三类："></a>Linux发行版通常分为三类：</h1><ol>
<li>完整的核心linux发行版</li>
<li>特定用途的发行版</li>
<li>LiveCD测试发行版</li>
</ol>
<h2 id="核心linux发行版"><a href="#核心linux发行版" class="headerlink" title="核心linux发行版"></a>核心linux发行版</h2><p>含有内核、一个多个图形化桌面环境以编译好的几乎所有能见到的linux应用。它提供了一站式完整的安装。比较流行的版本有</p>
<table>
<thead>
<tr>
<th>发行版</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Debian</td>
<td style="text-align:left">在linux专家和商用linux产品中流行的发行版。</td>
</tr>
<tr>
<td>OpenSUSE</td>
<td style="text-align:left">用于商用和家用的发行版</td>
</tr>
<tr>
<td>Slackware</td>
<td style="text-align:left">最早的linux发行版的一员，在linux极客中比较流行。</td>
</tr>
<tr>
<td>Red Hat</td>
<td style="text-align:left">主要用于Internet服务器的商业发行版</td>
</tr>
<tr>
<td>Fedora</td>
<td style="text-align:left">从RedHat分离出的家用发行版</td>
</tr>
<tr>
<td>Gentoo</td>
<td style="text-align:left">为高级linux用户设计的发行版，仅包含Linux源码。</td>
</tr>
</tbody>
</table>
<h2 id="特殊用途的linux发行版："><a href="#特殊用途的linux发行版：" class="headerlink" title="特殊用途的linux发行版："></a>特殊用途的linux发行版：</h2><p>他们通常基于某个主流发行版，但仅包含主流发行版的一小部分用于某种特定用途的应用程序。定制化发行版还尝试通过自动检测和自动配置常见的硬件来帮助新手安装linux。</p>
<table>
<thead>
<tr>
<th>发行版</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Centos</td>
<td style="text-align:left">基于Red Hat企业版linux源代码构建的免费发行版</td>
</tr>
<tr>
<td>Ubuntu</td>
<td style="text-align:left">用于学校和家庭的免费发行版</td>
</tr>
<tr>
<td>PClinuxOS</td>
<td style="text-align:left">用于家庭和办公</td>
</tr>
<tr>
<td>Mint</td>
<td style="text-align:left">用于家庭娱乐</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://onaple.duoshuo.com/2017/03/05/linux-杂记/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="onaple">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="onaple‘s Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="onaple‘s Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/05/linux-杂记/" itemprop="url">
                  linux 进程与线程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-05T18:00:46+08:00">
                2017-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/05/linux-杂记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/05/linux-杂记/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h1><ol>
<li>进程是资源分配和和独立运行的单位；</li>
<li>进程是操作系统中可执行程序的一次执行，换句话说进程就是拥有资源（cpu,内存，磁盘，进程ID，文件描述符，虚拟地址空间，端口号等）的程序；它是动态的；</li>
<li>一个进程是由程序控制块（pcb也就是task_struct结构体）,代码和数据组成；其中进程控制块是描述进程的资源和运行状态等；它有内核来管理；</li>
<li>在linux中可以通过ps，pstree来查看当前系统中的进程；</li>
</ol>
<h1 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h1><ol>
<li>线程属于轻量级进程，一个进程可以拥有多个线程；linux下线程就是轻量级进程，所以线程的概念和进程是大同小异的。只不过是共享了大部分资源的进程罢了。</li>
<li>线程是进程的一个执行流，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程是进程中的最小调度单位；</li>
<li>用户线程指的是完全建立在用户空间的线程库，用户线程的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。因此这种线程的操作是极其快速的且低消耗的。</li>
<li>用户态线程和内核态线程；主要的区分就是“谁来管理”线程，用户态是用户管理，内核态是内核管理（但肯定要提供一些API，例如创建）。</li>
<li>线程的模型有哪些<ul>
<li>n : 1 多个线程对应一个核心线程(进程); 线程的创建和销毁以及管理全部在用户层的线程库中实现，在内核层完全不知情，内核层看到的只是一个个进程。所以内核会以进程为单位调度任务运行。</li>
<li>1：1    一个线程对应核心线程(进程); 在1:1模式下，线程的创建，调度，销毁全由内核完成，而其他操作则由线程库完成。</li>
<li>m ：n ： 结合上面两种方式，如某些进程一一对应核内线程，其他线程完全在用户态实现。</li>
</ul>
</li>
</ol>
<h1 id="linux是如何管理进程的？"><a href="#linux是如何管理进程的？" class="headerlink" title="linux是如何管理进程的？"></a>linux是如何管理进程的？</h1><ol>
<li>每个进程在linux内核拥有一个task_struct结构体（进程控制块的具体定义），里面包含了进程几乎所有的信息。在linux下，所谓的进程管理，就是反复操纵task_struct结构体的过程一点也不为过。</li>
<li>操作系统对进程的所有管理都是围绕task_struct结构体为中心构建的。</li>
</ol>
<blockquote>
<p>例如，给某个进程发送kill信息，操作系统就会根据task_struct结构体中的信息释放进程所占用的内存，信号量，打开文件相关的资源等等，然后当进程被切换出去时释放task_struct结构体，至此，系统再没有保存该进程的任意一点信息，标志着进程的死亡。</p>
<p>再例如，进程的调度，由于每个进程都有其自己的上下文环境，或者说是当前系统状态的总和。被切换出去进程的这种系统状态需要保存到task_struct结构体中，以便下次恢复。而被切换进来的进程的上下文环境从哪里来呢？显而易见，在这个被调度进来的进程在真正运行之前，调度程序会从该进程的task_struct结构体中找到之前保存的上下文环境，然后将系统恢复到之前保存的状态，被调度进来的程序才真正开始运行。</p>
</blockquote>
<h1 id="进程的创建过程："><a href="#进程的创建过程：" class="headerlink" title="进程的创建过程："></a>进程的创建过程：</h1><ol>
<li>操作系统给新进程分配一个全局唯一的pid号;</li>
<li>并在内核空间中创建和分配诸如task_struct结构体，kernel堆栈等必要的数据结构和物理资源。</li>
<li>然后复制父进程的与信号有关，与文件系统有关的运行环境。最后还会给task_struct结构体某些变量赋值，将来使用这些变量来将新进程运行的某些环境（如kernel栈的起始地址，EAX的初值等）设置为子进程自己独有的运行环境。并加入运行队列中，之后就是调度程序的事了。</li>
<li>这个过程中涉及到了写时拷贝技术。在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。</li>
</ol>
<h1 id="写时拷贝技术"><a href="#写时拷贝技术" class="headerlink" title="写时拷贝技术:"></a>写时拷贝技术:</h1><blockquote>
<p><a href="http://blog.sina.cn/dpool/blog/s/blog_96757e4b01011b1n.html?vt=4" target="_blank" rel="external">http://blog.sina.cn/dpool/blog/s/blog_96757e4b01011b1n.html?vt=4</a> </p>
</blockquote>
<p>在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。</p>
<p>这就是分配内存的拖延战术，直到不得不做。操作系统中与此类似思想的还有页高速缓存器（page cache）。也就是，当有程序试图将数据写入文件的时候，linux操作系统并不会马上将数据写入disk中，而是将它们临时放在memory的一块区域。这块区域就叫做page cache。只有在关闭文件或者关机时，才有内核线程将page cache中的数据刷到磁盘中。这也就是非正常退出时，数据会损坏的原因。</p>
<h1 id="在Linux中主要提供了fork、vfork、clone三个进程创建方法。"><a href="#在Linux中主要提供了fork、vfork、clone三个进程创建方法。" class="headerlink" title="在Linux中主要提供了fork、vfork、clone三个进程创建方法。"></a>在Linux中主要提供了fork、vfork、clone三个进程创建方法。</h1><blockquote>
<p>以下总结来源:<a href="http://www.360doc.com/content/14/1231/11/14530056_437075775.shtml" target="_blank" rel="external">http://www.360doc.com/content/14/1231/11/14530056_437075775.shtml</a> </p>
</blockquote>
<p>在linux源码中这三个调用的执行过程是执行fork(),vfork(),clone()时，通过一个系统调用表映射到sys_fork(),sys_vfork(),sys_clone(),再在这三个函数中去调用do_fork()去做具体的创建进程工作。</p>
<ol>
<li>fork创建一个进程时，子进程只是完全复制父进程的资源，复制出来的子进程有自己的task_struct结构和pid,但却复制父进程其它所有的资源。这样看来，fork是一个开销十分大的系统调用，这些开销并不是所有的情况下都是必须的，比如某进程fork出一个子进程后，其子进程仅仅是为了调用exec执行另一个可执行文件，那么在fork过程中对于虚存空间的复制将是一个多余的过程。但由于现在Linux中是采取了copy-on-write(COW写时复制)技术，为了降低开销，fork最初并不会真的产生两个不同的拷贝，因为在那个时候，大量的数据其实完全是一样的。写时复制是在推迟真正的数据拷贝。所以有了写时复制后呢，vfork其实现意义就不大了。</li>
<li>vfork系统调用不同于fork，用vfork创建的子进程与父进程共享地址空间，也就是说子进程完全运行在父进程的地址空间上，如果这时子进程修改了某个变量，这将影响到父进程。但此处有一点要注意的是用vfork()创建的子进程必须显示调用exit()来结束，否则子进程将不能结束，而fork()则不存在这个情况。用 vfork创建子进程后，父进程会被阻塞直到子进程调用exec(exec，将一个新的可执行文件载入到地址空间并执行之。)或exit。vfork的好处是在子进程被创建后往往仅仅是为了调用exec执行另一个程序，因为它就不会对父进程的地址空间有任何引用，所以对地址空间的复制是多余的 ，因此通过vfork共享内存可以减少不必要的开销。</li>
<li>clone :系统调用fork()和vfork()是无参数的，而clone()则带有参数。fork()是全部复制，vfork()是共享内存，而clone() 是则可以将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些资源给子进程，由参数列表中的 clone_flags来决定。另外，clone()返回的是子进程的pid。<br>所以，这个就和上面说的轻量级进程联系起来，也可以这样说，linux通过clone调用生成线程。</li>
</ol>
<h1 id="fork，vfork，clone的区别"><a href="#fork，vfork，clone的区别" class="headerlink" title="fork，vfork，clone的区别"></a>fork，vfork，clone的区别</h1><ol>
<li><p>fork出来的子进程是父进程的一个拷贝，即，子进程从父进程得到了数据段和堆栈段的拷贝，这些需要分配新的内存；而对于只读的代码段，通常使用共享内存的方式访问；而vfork则是子进程与父进程共享内存空间, 子进程对虚拟地址空间任何数据的修改同样为父进程所见；clone则由用户通过参clone_flags 的设置来决定哪些资源共享，哪些资源拷贝。 </p>
</li>
<li><p>fork不对父子进程的执行次序进行任何限制，fork返回后，子进程和父进程都从调用fork函数的下一条语句开始行，但父子进程运行顺序是不定的，它取决于内核的调度算法；而在vfork调用中，子进程先运行，父进程挂起，直到子进程调用了exec或exit之后，父子进程的执行次序才不再有限制；clone中由标志CLONE_VFORK来决定子进程在执行时父进程是阻塞还是运行，若没有设置该标志，则父子进程同时运行，设置了该标志，则父进程挂起，直到子进程结束为止。<br>他们成功执行时，父进程中返回子进程的进程号，在子进程中返回0。</p>
</li>
</ol>
<h1 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h1><p>主要结构就是运行队列(双向循环链表)。为什么会有运行队列的存在呢?<br>当Linux内核要寻找一个新的进程在CPU上运行时，必须只考虑处于可运行状态的进程，（即在TASK_RUNNING状态的进程），因为扫描整个进程链表是相当低效的，所以引入了可运行状态进程的双向循环链表，也叫运行队列（runqueue）。运行队列容纳了系统中所有可以运行的进程，它是一个双向循环队列。</p>
<p>也就是说，为了实现进程的调度，内核维护了一个叫做运行队列的数据结构。在这个数据结构中，active，expired，arrays是主要的三个结构。目前，咱们几个了解这三个就足够了。arrays也就是一个拥有两个成员的数组，每个数组有140个双向链表（也就是说，所有的就绪进程，按照时间片是否用完分成两个部分），对应了0~139 的140个优先级。active和expired分别指向arrays的两个成员。进程调度时，从active指针选择下一个要运行的程序。active中时间片用完的进程会被移动到expired队列，并且时间片会被重新计算，若active队列再无成员，则两个指针指向互换。</p>
<p>linux进程主要分为 实时进程（例如键盘中输入字母或者鼠标点击之类的） 和 交互式进程与批处理进程（例如word程序，你总是写一会停一会）。内核不会动态调整前者的优先级，如需调整，则需要调用特殊的系统调用。而且，前者的优先级别最高。只有没有实时进程的时候，交互式或者批处理才会被调度执行。而后者的优先级会被内核动态调整。</p>
<h1 id="进程有哪些调度策略？"><a href="#进程有哪些调度策略？" class="headerlink" title="进程有哪些调度策略？"></a>进程有哪些调度策略？</h1><p>这时候你分开说。对于实时进程，一般采用的是FIFO或者RR（轮询）机制。而对于交互式或者批处理进程，则采用动态调整优先级加运行队列机制来执行调度。这里有个大原则，如果有实时进程，那么交互式或者批处理则不会被执行。这个从进程优先级就可以看出来：实时（0~99），交互式批处理（100~139）。这时，你还可以举个例子。比如，你正在复制100文件，文件是一个一个被复制的，当复制到第50个的时候，你点了一下停止符号，它不会说是继续第51个文件的复制，而是直接停止。说明你鼠标的点击被插入到第51个文件之前了。所以实时进程永远比后者优先级高。</p>
<h1 id="进程会在什么时候被调度"><a href="#进程会在什么时候被调度" class="headerlink" title="进程会在什么时候被调度?"></a>进程会在什么时候被调度?</h1><p>调度一般在进程退出内核态时，因为这时进程已经释放了可能导致内核死锁的资源。除了时间片用完触发调度，内核线程会在执行一些比较费时的任务时，自己调用调度函数，使其他进程有机会执行。</p>
<p>首先进程调度不应该产生内核死锁之类的问题。如果进程在内核态，则它可能会占有产生死锁的资源（比如，进程想要操纵硬件必须使用系统调用。想想这样一种情况：用户想要使用打印机这种独占资源，内核线程，也就是代表用户进程在内核状态执行的那个线程，它一定改变了代表打印机的结构的某个标志位，或者持有打印机结构体内的自旋锁，互斥锁之类的资源，标志着打印机正在被使用，本来打算在返回用户态时释放这种互斥锁资源，但调度函数来了，我不管，我就要让你现在退出。然后该进程带着互斥锁退出。当下一个进程进来，也要使用打印机，这时，该进程向内核申请打印机，而内核却发现打印机正在被使用，所以内核等待打印机退出，而持有互斥锁的进程已经被内核踢出cpu了，谈何释放？所以这时，所有的进程都在等，被调度进来进程陷入内核出不来了,整条逻辑陷入了无限循环，如果是单核，那么死锁便产生了）。</p>
<h1 id="关于僵尸进程"><a href="#关于僵尸进程" class="headerlink" title="关于僵尸进程"></a>关于僵尸进程</h1><p>僵尸进程指的是那些虽然已经终止的进程，但仍然保留一些信息，等待其父进程为其收尸。</p>
<ol>
<li><p>生的原因：<br>父进程调用fork创建子进程后，子进程运行直至其终止，它立即从内存中移除，但进程描述符仍然保留在内存中（进程描述符占有极少的内存空间）。子进程的状态变成EXIT_ZOMBIE，并且向父进程发送SIGCHLD 信号，父进程此时应该调用 wait() 系 统调用来获取子进程的退出状态以及其它的信息。在 wait 调用之后，僵尸进程就完全从内存中移除。因此一个僵尸存在于其终止到父进程调用 wait 等函数这个时间的间隙，一般很快就消失，但如果编程不合理，父进程从不调用 wait 等系统调用来收集僵尸进程，那么这些进程会一直存在内存中。比如父进程死了，或者父进程忽略了SIGCHLD信号，或者父进程对SIGCHLD信号定义的信号处理函数有误。</p>
</li>
<li><p>如何避免：不能使用 kill 后接 SIGKILL 信号这样的命令像杀死普通进程一样杀死僵尸进程，因为僵尸进程是已经死掉的进程，它不能再接收任何信号。事实上，如果系统中僵尸进程并不多的话，我们也无需去消除它们，少数的僵尸进程并不会对系统的性能有什么影响。</p>
</li>
</ol>
<p>那么在编程时，如果能避免系统中大量产生僵尸进程呢？根据上面描述的，子进程在终止时会向父进程发 SIGCHLD 信号，Linux 默认是忽略该信号的，我们可以显示安装该信号，在信号处理函数中调用 wait 等函数来为其收尸，这样就能避免僵尸进程长期存在于系统中了。<br>以上都是复制下面这个链接的，</p>
<blockquote>
<p><a href="http://www.cnblogs.com/hazir/p/zombie_process.html" target="_blank" rel="external">http://www.cnblogs.com/hazir/p/zombie_process.html</a></p>
</blockquote>
<ol>
<li><p>危害：</p>
<ul>
<li>僵尸进程的pid不会释放，意味着如果有海量的僵尸进程，则会占满进程表项，是的后续进程无法执行fork（）</li>
<li>内核栈无法释放，这个资源是很珍贵的。根本原因在于，task_stauct结构体没有释放。</li>
</ul>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://onaple.duoshuo.com/2017/03/05/c-类的四大函数/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="onaple">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="onaple‘s Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="onaple‘s Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/05/c-类的四大函数/" itemprop="url">
                  c++ 类的四大函数
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-05T17:33:19+08:00">
                2017-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/05/c-类的四大函数/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/05/c-类的四大函数/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><ol>
<li>类是用户自定义的一种数据类型，定义类时描述它可以提供的信息及能够执行的操作；即类是一种具有属性和行为的自定义的数据类型；</li>
<li>对象就是封装了数据结构，及施加这些数据结构上的操作的封装体；</li>
</ol>
<h1 id="类与对象的关系："><a href="#类与对象的关系：" class="headerlink" title="类与对象的关系："></a>类与对象的关系：</h1><p>类之于对象如同类型之于变量，因此类只是描述了数据格式和方法，而对象则是根据规范创建的实体；换句话说类就像图纸，而对象则是根据图纸盖起的大楼。</p>
<h1 id="类与结构体的区别"><a href="#类与结构体的区别" class="headerlink" title="类与结构体的区别"></a>类与结构体的区别</h1><p>唯一的区别在于struct的默认访问权限是public,而类是private;</p>
<h1 id="C-中的类所占内存分析："><a href="#C-中的类所占内存分析：" class="headerlink" title="C++中的类所占内存分析："></a>C++中的类所占内存分析：</h1><ol>
<li>类所占内存的大小是由成员变量（静态变量除外）决定的，成员函数（这是笼统的说，后面会细说）是不计算在内的。成员函数还是以一般的函数一样的存在。a.fun()是通过fun(a.this)来调用的。</li>
<li>所谓成员函数只是在名义上是类里的。其实成员函数的大小不在类的对象里面，同一个类的多个对象共享函数代码。而我们访问类的成员函数是通过类里面的一个指针实现，而这个指针指向的是一个table，</li>
<li>table里面记录的各个成员函数的地址（当然不同的编译可能略有不同的实现）。所以我们访问成员函数是间接获得地址的。所以这样也就增加了一定的时间开销，这也就是为什么我们提倡把一些简短的，调用频率高的函数声明为inline形式（内联函数）。</li>
</ol>
<p>总结：空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。</p>
<ol>
<li>类内部的成员变量：<br> 普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。<br> static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。</li>
<li>类内部的成员函数：<br> 普通函数：不占用内存。<br> 虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的。</li>
</ol>
<h1 id="C-类中的四大函数：构造函数、拷贝构造函数、析构函数和赋值函数"><a href="#C-类中的四大函数：构造函数、拷贝构造函数、析构函数和赋值函数" class="headerlink" title="C++类中的四大函数：构造函数、拷贝构造函数、析构函数和赋值函数:"></a>C++类中的四大函数：构造函数、拷贝构造函数、析构函数和赋值函数:</h1><ol>
<li>四个函数一般系统都会默认。但是往往系统默认的并不是我们所期望的，为此我们有必要自己编写符合要求的函数，参看String.cpp;</li>
<li>把对象的初始化工作放在构造函数中，当对象被创建时，构造函数被自动执行。</li>
<li>把清除工作放在析构函数中。当对象消亡时，析构函数被自动执行，把一切内存垃圾清理，可见他的重要。如果没有析构函数或析构函数不正确就会发生内存泄露等问题，后果非常危险</li>
<li>每个类只有一个析构函数和一个赋值函数，但可以有多个构造函数（包含一个拷贝构造函数，其它的称为普通构造函数）。</li>
<li>构造函数和赋值函数有着很大的区别，构造函数是在对象创建时调用的；而赋值函数使对象已经创建好了存在之后再赋值时调用的。有时候我们懒得写赋值函数和拷贝构造函数，又不允许别人使用编译器生成的缺省函数，那么我们可以只需将拷贝构造函数和赋值函数声明为私有函数，函数体为空即可；</li>
</ol>
<h1 id="使用对象前正确初始化"><a href="#使用对象前正确初始化" class="headerlink" title="使用对象前正确初始化"></a>使用对象前正确初始化</h1><ol>
<li>并不是所有的编译器都对象对象的内置类型成员会被自动初始化为0。永远在使用对象之前先将它初始化。确保每一个构造函数都将对象的每一个成员初始化。</li>
<li>别把赋值错当成初始化。C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前（对于内置类型对象可能不确定），这点对于非内置类型对象来说尤其关键。如果你没有在成员初始化列表（member initialization list）为其初始化，它们将调用自己的默认构造函数，然后才进入构造函数内部（很可能你会在这里给他们赋值）。在成员初始化列表中的初始化只是调用了拷贝构造函数一次，而在构造函数内部再为其赋值则在调用默认构造函数后又调用了一次拷贝构造函数。因此初始化列表将更为高效</li>
</ol>
<p>所以，请用成员初始化列表进行初始化，虽然效率提高只针对于非内置类型成员，但是规定总是在初值列中列出所有成员变量，这样就省的有些未被列出的内置类型成员被忘记初始化。而有些时候，即使成员变量是内置类型，也必须要用成员初始化列表（成员变量为const或者reference，它们一定要有初值，而且不能被赋值）。</p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><ol>
<li>使用构造函数的原因：由于类的封装性,不能象普通变量一样初始化</li>
<li>构造函数的作用：是在对象被创建时使用特定的值构造对象，或者说将对象初始化为一个特定的状态。</li>
<li>调用时刻：在对象创建时由系统自动调用。如果程序中未声明，则系统自动产生出一个缺省形式的构造函数</li>
<li>条件约束：允许为内联函数、重载函数、带缺省形参值的函数；但不允许是虚函数因为在刚开始对象还未被创建，内部什么都没有，更不用说虚表，虚表指针。因此无法调用虚函数。</li>
</ol>
<h1 id="拷贝构造函数（是一种特殊的构造函数，其形参为本类的对象引用）。"><a href="#拷贝构造函数（是一种特殊的构造函数，其形参为本类的对象引用）。" class="headerlink" title="拷贝构造函数（是一种特殊的构造函数，其形参为本类的对象引用）。　"></a>拷贝构造函数（是一种特殊的构造函数，其形参为本类的对象引用）。　</h1><p>作用：使用一个对象（参数指定的对象），去初始化一个正在被建立的同类型对象（如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个拷贝构造函数。）</p>
<p>调用时刻：</p>
<ol>
<li>当用类的一个对象去初始化该类的另一个对象时系统自动调用它实现拷贝赋值。</li>
<li>若函数的形参为类对象，调用函数时，实参赋值给形参，系统自动调用拷贝构造函数。</li>
<li>当函数的返回值是类对象时，系统自动调用拷贝构造函数。<h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1>作用：完成对象被删除前的一些清理工作。<br>调用时刻：在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间。<br>如果程序中未声明析构函数，编译器将自动产生一个缺省的析构函数。</li>
</ol>
<p>注意事项：  </p>
<ol>
<li>析构函数也不被继承，派生类自行声明。</li>
<li>声明方法与一般（无继承关系时）类的析构函数相同。</li>
<li>不需要显式地调用基类的析构函数，系统会自动隐式调用。</li>
<li>析构函数的调用次序与构造函数相反。</li>
</ol>
<h1 id="类组合的构造函数调用"><a href="#类组合的构造函数调用" class="headerlink" title="类组合的构造函数调用"></a>类组合的构造函数调用</h1><ol>
<li>构造函数调用顺序：先调用内嵌对象的构造函数（按内嵌时的声明顺序，先声明者先构造）。然后调用本类的构造函数。（析构函数的调用顺序相反）</li>
<li>若调用缺省构造函数（即无形参的），则内嵌对象的初始化也将调用相应的缺省构造函数。</li>
</ol>
<h1 id="多继承且有内嵌对象时的构造函数调用次序"><a href="#多继承且有内嵌对象时的构造函数调用次序" class="headerlink" title="多继承且有内嵌对象时的构造函数调用次序"></a>多继承且有内嵌对象时的构造函数调用次序</h1><ol>
<li>调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。</li>
<li>调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序。</li>
</ol>
<h1 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h1><p>在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。</p>
<p>使用静态数据成员可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。</p>
<p>静态数据成员的使用方法和注意事项如下：</p>
<ol>
<li>静态数据成员在定义或说明时前面加关键字static。</li>
<li>静态成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式如下：<br>  &lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;</li>
</ol>
<p>这表明：</p>
<ol>
<li>初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆。</li>
<li>初始化时不加该成员的访问权限控制符private，public等。</li>
<li>初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员。</li>
<li>静态数据成员是静态存储的，它是静态生存期，必须对它进行初始化。</li>
<li>引用静态数据成员时，采用如下格式：<br>&lt;类名&gt;::&lt;静态成员名&gt;</li>
</ol>
<h1 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h1><ol>
<li>静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。</li>
<li>在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。如果静态成员函数中要引用非静态成员时，可通过对象来引用。</li>
<li>调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;);</li>
<li>类外代码可以使用类名和作用域操作符来调用静态成员函数。</li>
<li>静态成员函数只能引用属于该类的静态数据成员或静态成员函数。</li>
</ol>
<h1 id="Inline函数"><a href="#Inline函数" class="headerlink" title="Inline函数"></a>Inline函数</h1><p>C++ inline函数 ：</p>
<pre><code>inline int min(int first, int secend) {/****/};
</code></pre><ol>
<li>inline函数对编译器而言必须是可见的，以便它能够在调用点内展开该函数。与非<br>inline函数不同的是，inline函数必须在调用该函数的每个文本文件中定义。</li>
<li>关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。<br>（所以说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。）</li>
</ol>
<h1 id="慎用内联："><a href="#慎用内联：" class="headerlink" title="慎用内联："></a>慎用内联：</h1><p>内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：</p>
<ol>
<li>如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。</li>
<li>如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</li>
</ol>
<h1 id="内联函数和-define-宏的区别："><a href="#内联函数和-define-宏的区别：" class="headerlink" title="内联函数和#define 宏的区别："></a>内联函数和#define 宏的区别：</h1><p>内联函数总是对参数只精确地进行一次求值，从而避免了那声名狼藉的宏错误。换句话说，调用内联函数和调用正规函数是等价的，差别仅仅是更快</p>
<h1 id="常函数的调用是这样的："><a href="#常函数的调用是这样的：" class="headerlink" title="常函数的调用是这样的："></a>常函数的调用是这样的：</h1><p>常量对象只能调用常成员函数，非常量对象即可以调常成员函数，也可以调一般成员函数，但当某个函数有const和非const两个版本时，const对象调const版本，非const对象调非const版本。</p>
<h1 id="二义性的问题"><a href="#二义性的问题" class="headerlink" title="二义性的问题"></a>二义性的问题</h1><ol>
<li>在多继承时，基类与派生类之间，或基类之间出现同名成员时，将出现访问时的二义性（不确定性）——采用虚函数（第8章）或支配（同名覆盖）原则来解决。</li>
<li>当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性——采用虚基类来解决。</li>
</ol>
<h1 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h1><p>引入</p>
<ol>
<li>用于有共同基类的场合声明</li>
<li>以virtual修饰说明基类    例：class B1:virtual public B</li>
</ol>
<p>作用：</p>
<ol>
<li>主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题.</li>
<li>为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝  </li>
</ol>
<p><strong>注意：</strong> 在第一级继承时就要将共同基类设计为虚基类。</p>
<h1 id="虚基类及其派生类构造函数"><a href="#虚基类及其派生类构造函数" class="headerlink" title="虚基类及其派生类构造函数"></a>虚基类及其派生类构造函数</h1><ol>
<li>建立对象时所指定的类称为最（远）派生类。</li>
<li>虚基类的成员是由最派生类的构造函数通过调用虚基类的构造函数进行初始化的。</li>
<li>在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中给出对虚基类的构造函数的调用。如果未列出，则表示调用该虚基类的缺省构造函数。</li>
<li>在建立对象时，只有最派生类的构造函数调用虚基类的构造函数，该派生类的其它基类对虚基类构造函数的调用被忽略。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://onaple.duoshuo.com/2017/03/05/c-继承/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="onaple">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="onaple‘s Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="onaple‘s Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/05/c-继承/" itemprop="url">
                  c++ 继承
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-05T16:59:34+08:00">
                2017-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/05/c-继承/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/05/c-继承/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="继承与派生："><a href="#继承与派生：" class="headerlink" title="继承与派生："></a>继承与派生：</h1><ul>
<li>保持已有类的特性而构造新类的过程称为继承。</li>
<li>在已有类的基础上新增自己的特性而产生新类的过程称为派生。</li>
<li>继承的目的：实现代码重用。</li>
<li>派生的目的：当新的问题出现，原有程序无法解决（或不能完全解决）时，需要对原有程序进行改造。</li>
</ul>
<h1 id="三种继承方式"><a href="#三种继承方式" class="headerlink" title="三种继承方式"></a>三种继承方式</h1><blockquote>
<p>公有继承；私有继承；保护继承<br>不同继承方式的影响主要体现在:</p>
<ol>
<li>派生类成员对基类成员的访问控制。</li>
<li>派生类对象对基类成员的访问控制。</li>
</ol>
</blockquote>
<h2 id="1-公有继承："><a href="#1-公有继承：" class="headerlink" title="1.公有继承："></a>1.公有继承：</h2><ul>
<li>继承方式：基类的public和protected成员的访问属性在派生类中保持不变，但基类的private成员不可访问。</li>
<li>类内： 派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。</li>
<li>类外：通过派生类的对象只能访问基类的public成员。</li>
</ul>
<h2 id="2-私有继承："><a href="#2-私有继承：" class="headerlink" title="2.私有继承："></a>2.私有继承：</h2><ul>
<li>继承方式：基类的public和protected成员都以private身份出现在派生类中，但基类的private成员不可访问。</li>
<li>类内：派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。</li>
<li>类外：通过派生类的对象不能访问基类中的任何成员。</li>
</ul>
<h2 id="3-保护继承："><a href="#3-保护继承：" class="headerlink" title="3.保护继承："></a>3.保护继承：</h2><ul>
<li>继承方式：基类的public和protected成员都以protected身份出现在派生类中，但基类的private成员不可访问。</li>
<li>类内：派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。</li>
<li>类外：通过派生类的对象不能访问基类中的任何成员</li>
</ul>
<h2 id="4-protected-成员的特点与作用："><a href="#4-protected-成员的特点与作用：" class="headerlink" title="4.protected 成员的特点与作用："></a>4.protected 成员的特点与作用：</h2><ul>
<li>对建立其所在类对象的模块来说（水平访问时），它与 private 成员的性质相同。</li>
<li>对于其派生类来说（垂直访问时），它与 public 成员的性质相同。</li>
<li>.    既实现了数据隐藏，又方便继承，实现代码重用；</li>
</ul>
<h1 id="基类与派生类的对应关系"><a href="#基类与派生类的对应关系" class="headerlink" title="基类与派生类的对应关系"></a>基类与派生类的对应关系</h1><ul>
<li>单继承:    派生类只从一个基类派生。</li>
<li>多继承：派生类从多个基类派生。</li>
<li>多重派生: 由一个基类派生出多个不同的派生类。</li>
<li>多层派生: 派生类又作为基类，继续派生新的类。</li>
</ul>
<h1 id="继承时的构造函数"><a href="#继承时的构造函数" class="headerlink" title="继承时的构造函数"></a>继承时的构造函数</h1><ol>
<li>基类的构造函数不被继承，需要在派生类中自行声明。</li>
<li>声明构造函数时，只需要对本类中新增成员进行初始化，对继承来的基类成员的初始化由基类完成。</li>
</ol>
<h1 id="多重继承构造函数的调用次序"><a href="#多重继承构造函数的调用次序" class="headerlink" title="多重继承构造函数的调用次序"></a>多重继承构造函数的调用次序</h1><ol>
<li>调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。</li>
<li>调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序。</li>
<li>派生类的构造函数体中的内容。</li>
</ol>
<h1 id="多重继承时的析构函数"><a href="#多重继承时的析构函数" class="headerlink" title="多重继承时的析构函数"></a>多重继承时的析构函数</h1><ol>
<li>析构函数也不被继承，派生类自行声明。</li>
<li>声明方法与一般（无继承关系时）类的析构函数相同。</li>
<li>不需要显式地调用基类的析构函数，系统会自动隐式调用。</li>
<li>析构函数的调用次序与构造函数相反。</li>
</ol>
<h1 id="二义性问题"><a href="#二义性问题" class="headerlink" title="二义性问题"></a>二义性问题</h1><ul>
<li>在多继承时，基类与派生类之间，或基类之间出现同名成员时，将出现访问时的二义性（不确定性）——采用虚函数或支配（同名覆盖）原则来解决。</li>
<li>当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性——采用虚基类来解决。（菱形继承）</li>
</ul>
<h1 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h1><p>声明:    以virtual修饰说明基类    </p>
<pre><code>例：class B1:virtual public B
</code></pre><p>作用：</p>
<ol>
<li>主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题.</li>
<li>为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝</li>
</ol>
<blockquote>
<p><strong>注意</strong>：在第一级继承时就要将共同基类设计为虚基类。</p>
</blockquote>
<h1 id="赋值兼容原则"><a href="#赋值兼容原则" class="headerlink" title="赋值兼容原则"></a>赋值兼容原则</h1><p>一个公有派生类的对象在使用上可以被当作基类的对象，反之则禁止。具体表现在：</p>
<ol>
<li>派生类的对象可以被赋值给基类对象。</li>
<li>派生类的对象可以初始化基类的引用。</li>
<li>指向基类的指针也可以指向派生类。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://onaple.duoshuo.com/2017/03/05/c-的多态/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="onaple">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="onaple‘s Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="onaple‘s Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/05/c-的多态/" itemprop="url">
                  c++ 多态
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-05T16:34:59+08:00">
                2017-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/05/c-的多态/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/05/c-的多态/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C和C-的区别："><a href="#C和C-的区别：" class="headerlink" title="C和C++的区别："></a>C和C++的区别：</h2><ol>
<li>C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制）。C的优势在于编写的程序更接近于硬件，仅次于汇编语言，所以他相对其他编程语言高效的多，但同时程序员负责一切不安全，如内存泄露等。但正是由于这样的风险的存在，对程序员的紧密思维要求更高。</li>
<li>C++是有C，面向对象，泛型编程，stl组成。用面向对象来编程首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。 所以C与C++的最大区别在于它们的用于解决问题的思想方法不一样。之所以说C++比C更先进，是因为“ 设计这个概念已经被融入到C++之中 ”。</li>
</ol>
<h2 id="面向对象的三大特性："><a href="#面向对象的三大特性：" class="headerlink" title="面向对象的三大特性："></a>面向对象的三大特性：</h2><p>封装，继承，多态</p>
<ol>
<li>封装：将对象的属性和方法封装在对象内部，形成一个个独立的单元模块，对外通访问权限控制管理对象数据的交互。(访问权限：（private，protected,public) 保证封装性的关键)<br>目的：增强代码的安全性和简化编程，让使用者不必了解类具体的实现细节，只要通过外部接口，以特定的权限来使用类的方法即可。</li>
<li>继承：一个对象获得另一对象的特性的过程。是将一群类组织起来，定义了父子关系，实现了代码的重用，父类定义了所有子类的的共有借口和私有实现，同时子类都可以增加或覆盖继承来的东西，以实现独有的行为。</li>
<li>多态：它是建立在了继承的基础上；简单来说，就是一个接口，多个方法.具体来说：它是指不同子类在继承父类后分别覆盖了父类的方法<br>多态性使得同一属性或者行为在基类及其子类间有不同的语义；<br>多态性丰富了对象的内容，增强了软件的灵活性和可重用性；<br>C++的多态性有两种：编译时的多态（函数重载），运行时多态（虚函数）<br>（联编（binding)或称为绑定:是指计算机程序自身彼此关联的过程<br>联编工作在编译连接阶段完成的情况称为：静态联编<br>联编在程序运行阶段完成的情况称为：动态联编。）</li>
</ol>
<h2 id="c-重载-覆盖-隐藏的区别和执行方式"><a href="#c-重载-覆盖-隐藏的区别和执行方式" class="headerlink" title="c++ 重载 覆盖 隐藏的区别和执行方式 :"></a>c++ 重载 覆盖 隐藏的区别和执行方式 :</h2><ol>
<li>成员函数被重载的特征:<br>相同的范围（在同一个类中）；函数名字相同；参数不同； virtual 关键字可有可无。</li>
<li>覆盖是指派生类函数覆盖基类函数，特征是:<br>不同的范围（分别位于派生类与基类）； 函数名字相同； 参数相同； 基类函数必须有virtual 关键字。 </li>
<li>“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下:<br>如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）</li>
<li>3种情况怎么执行：<br>重载：看参数;<br>隐藏：用什么就调用什么;<br>覆盖：调用派生类;</li>
</ol>
<h2 id="虚函数的工作原理："><a href="#虚函数的工作原理：" class="headerlink" title="虚函数的工作原理："></a>虚函数的工作原理：</h2><p>编译器处理虚函数的方法是.给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。而这个数组称为虚函数表，虚函数表中存储了为类对象进行声明的虚函数的地址。</p>
<ol>
<li>单继承时<ul>
<li>虚函数指针在对象的最前面的位置；</li>
<li>虚函数地址按照声明的顺序存放于虚表中；</li>
<li>父类虚函数地址在子类虚函数地址的前面；</li>
<li>子类如果覆盖父类的虚函数，则被放到虚表中原父类虚函数的位置</li>
<li>没有被覆盖的函数依旧在原位。</li>
</ul>
</li>
<li>多重继承的特殊地方：<ul>
<li>每个父类都有自己的虚表时，子类的虚函数成员只被放到第一个父类中。</li>
<li>子类有多个虚表指针，位于类的最前面，分别指向不同的父类的虚表，（按继承的顺序）。</li>
<li>如果有覆盖情况，则替换所有被覆盖的父类虚函数地址。</li>
</ul>
</li>
<li>父类访问子类中成员函数只能通过虚函数，覆盖的方法。否则无法访问。但我们可以通过函数指针强行访问虚表里的函数。本人就是通过此方法的出的以上结论。</li>
<li>虚函数特性：<ul>
<li>虚函数是动态联编的基础。</li>
<li>是非静态的成员函数。</li>
<li>在类的声明中，在函数原型之前写virtual。</li>
<li>virtual 只用来说明类声明中的原型，不能用在函数实现时。</li>
<li>具有继承性，基类中声明了虚函数，派生类中无论是否说明，同原型函数都自动为虚函数。</li>
<li>本质：不是重载声明而是覆盖。</li>
<li>调用方式：通过基类指针或引用，执行时会根据指针指向的对象的类，决定调用哪个函数。</li>
</ul>
</li>
<li>虚函数的限制<ul>
<li>只有类的成员函数才能说明为虚函数，因为虚函数仅适用于继承关系的 类对象，所以普通函数不能说明为虚函数。</li>
<li>内联函数不能是虚函数，因为内联函数是在编译时决    定其位置。</li>
<li>构造函数不能是虚函数，因为构造时对象还是一片未    定型的空间，就没有虚指针，虚表。。</li>
<li>析构函数可以是虚函数，而且通常声明为虚函数。<h2 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h2></li>
</ul>
</li>
<li>带有纯虚函数的类称为抽象类:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class  类名 &#123;     virtual 类型 函数名(参数表)=0;  //纯虚函 	 ...&#125;;</div></pre></td></tr></table></figure>
<ol>
<li>作用：<ul>
<li>抽象类为抽象和设计的目的而建立，将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为。</li>
<li>对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现。主要作用是通过它为一个类族建立一个公共的接口，使它们能够更有效地发挥多态特性。</li>
</ul>
</li>
<li>注意：抽象类只能作为基类来使用;不能声明抽象类的对象;但可以声明一个指针</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://onaple.duoshuo.com/2017/03/05/c-模板/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="onaple">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="onaple‘s Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="onaple‘s Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/05/c-模板/" itemprop="url">
                  c++ 模板
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-05T10:15:38+08:00">
                2017-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/05/c-模板/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/03/05/c-模板/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>模板是C++支持参数化多态的工具，使用模板可以使用户为类或者函数声明一种一般模式，使得类中的某些数据成员或者成员函数的参数、返回值取得任意类型。</p>
<p>模板是一种对类型进行参数化的工具；通常有两种形式：函数模板和类模板；函数模板针对仅参数类型不同的函数；类模板针对仅数据成员和成员函数类型不同的类。</p>
<p>使用模板的目的：就是能够让程序员编写与类型无关的代码。</p>
<p>注意：模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。</p>
<h2 id="1-函数模板定义格式"><a href="#1-函数模板定义格式" class="headerlink" title="1.函数模板定义格式:"></a>1.函数模板定义格式:</h2><pre><code>template &lt;class 形参名，class 形参名，......&gt; 返回类型 函数名(参数列表)
{    函数体 }
</code></pre><blockquote>
<p>模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。</p>
</blockquote>
<h2 id="2-函数模板"><a href="#2-函数模板" class="headerlink" title="2.函数模板"></a>2.函数模板</h2><blockquote>
<ol>
<li>函数模板可以用来创建一个通用功能的函数，以支持多种不同形参，进一步简化重载函数的函数体设计。</li>
<li>函数模板提供一个种用来自动生成各种类型函数实例的算法，程序员对于函数接口参数和返回类型中的全部或者部分类型进行参数化(parameterize)，而函数体保持不变。<br> <strong>注意</strong>：模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。<br> <strong>注意</strong>：对于函数模板而言不存在 h(int,int) 这样的调用，不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行，即只能进行 h(2,3) 这样的调用，或者int a, b; h(a,b)</li>
<li>函数模板实例化</li>
<li>函数模板只是声明了一个函数的描述即模板，不是一个可以直接执行的函数，只有根据实际情况用实参的数据类型代替类型参数标识符之后，才能产生真正的函数。</li>
<li>函数模板的数据类型参数标识符实际上是一个类型形参，在使用函数模板时，要将这个形参实例化为确定的数据类型。将类型形参实例化的参数称为模板实参，用模板实参实例化的函数称为模板函数。模板函数的生成就是将函数模板的类型形参实例化的过程。</li>
<li>函数模板在它被调用或取其地址时被实例化</li>
<li>模板函数类似于重载函数，但两者有很大区别：函数重载时，每个函数体内可以执行不同的动作，但同一个函数模板实例化后的模板函数都必须执行相同的动作 </li>
</ol>
</blockquote>
<h2 id="3-函数模板与同名的非模板函数重载时，应遵循下列调用原则："><a href="#3-函数模板与同名的非模板函数重载时，应遵循下列调用原则：" class="headerlink" title="3.函数模板与同名的非模板函数重载时，应遵循下列调用原则："></a>3.函数模板与同名的非模板函数重载时，应遵循下列调用原则：</h2><blockquote>
<ol>
<li>寻找一个参数完全匹配的函数，若找到就调用它。若参数完全匹配的函数多于一个，则这个调用是一个错误的调用。 </li>
<li>寻找一个函数模板，若找到就将其实例化生成一个匹配的模板函数并调用它。 </li>
<li>若上面两条都失败，则使用函数重载的方法，通过类型转换产生参数匹配，若找到就调用它。</li>
<li>若上面三条都失败，还没有找都匹配的函数，则这个调用是一个错误的调用</li>
</ol>
</blockquote>
<h2 id="4-类模板定义："><a href="#4-类模板定义：" class="headerlink" title="4.类模板定义："></a>4.类模板定义：</h2><pre><code>template&lt;class  形参名，class 形参名，…&gt;   
class 类名
{... };
</code></pre><blockquote>
<p>类模板和函数模板都是以template开始后接模板形参列表组成，模板形参不能为空，一但声明了类模板就可以用类模板的形参名声明类中的成员变量和成员函数，即可以在类中使用内置类型的地方都可以使用模板形参名来声明。比如:</p>
</blockquote>
<pre><code>template&lt;class T&gt; class A{public: T a; T b; T hy(T c, T &amp;d);};
</code></pre><h2 id="5-类模板对象的创建："><a href="#5-类模板对象的创建：" class="headerlink" title="5.类模板对象的创建："></a>5.类模板对象的创建：</h2><blockquote>
<ol>
<li>比如一个模板类A，则使用类模板创建对象的方法为A<int> m;在类A后面跟上一个&lt;&gt;尖括号并在里面填上相应的类型，这样的话类A中凡是用到模板形参的地方都会被int 所代替。当类模板有两个模板形参时创建对象的方法为A<int, double=""> m;类型之间用逗号隔开。</int,></int></li>
<li>对于类模板，模板形参的类型必须在类名后的尖括号中明确指定。比如A<2> m;用这种方法把模板形参设置为int是错误的（编译错误：error C2079: ‘a’ uses undefined class ‘A<int>‘），类模板形参不存在实参推演的问题。也就是说不能把整型值2推演为int 型传递给模板形参。要把类模板形参调置为int 型必须这样指定A<int> m。</int></int></2></li>
</ol>
</blockquote>
<h2 id="6-在类模板外部定义成员函数的方法为："><a href="#6-在类模板外部定义成员函数的方法为：" class="headerlink" title="6.在类模板外部定义成员函数的方法为："></a>6.在类模板外部定义成员函数的方法为：</h2><pre><code>template&lt;模板形参列表&gt; 函数返回类型 类名&lt;模板形参名&gt;::函数名(参数列表){函数体}；
</code></pre><blockquote>
<p>比如有两个模板形参T1，T2的类A中含有一个void h()函数，则定义该函数的语法为：　</p>
</blockquote>
<pre><code>template&lt;class T1,class T2&gt; void A&lt;T1,T2&gt;::h(){}。
</code></pre><blockquote>
<p>注意：当在类外面定义类的成员时template后面的模板形参应与要定义的类的模板形参一致。</p>
</blockquote>
<h2 id="7-模板的实例化：类模板在引用实际模板类类型时实例化"><a href="#7-模板的实例化：类模板在引用实际模板类类型时实例化" class="headerlink" title="7.模板的实例化：类模板在引用实际模板类类型时实例化"></a>7.模板的实例化：类模板在引用实际模板类类型时实例化</h2><blockquote>
<ol>
<li>定义模板类对象时</li>
<li>通过类指针或引用指向一个类模板实例时，只有当检查这个指针或引用指的那个对象时(访问数据成员或成员函数)，才会实例化</li>
<li>当类模板被实例化时，类模板的成员函数并不自动被实例化。只有该函数被调用或取地址时，才被实例化。</li>
<li>静态数据成员只有被使用时才实例化。</li>
</ol>
</blockquote>
<h2 id="8-类模板和函数模板区别"><a href="#8-类模板和函数模板区别" class="headerlink" title="8.类模板和函数模板区别"></a>8.类模板和函数模板区别</h2><blockquote>
<ol>
<li>函数模板允许重载 ，而类模板不允许重载(类无重载概念，即不存在同名类模板)。</li>
<li>类模板可以进行全特化和偏特化，而函数模板仅能够全特化 。</li>
<li>类模板支持默认参数，函数模板不支持</li>
</ol>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://onaple.duoshuo.com/2017/02/10/hello-world/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="onaple">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.jpg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="onaple‘s Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="onaple‘s Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/10/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-10T19:43:33+08:00">
                2017-02-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/10/hello-world/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/10/hello-world/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  

          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="onaple" />
          <p class="site-author-name" itemprop="name">onaple</p>
          <p class="site-description motion-element" itemprop="description">Talk is cheap, show me the code.  ——Linus Torvalds</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/onaple" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://my.csdn.net/aoo_wangxu" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-csdn"></i>
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">onaple</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"onaple"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  













  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  


</body>
</html>
