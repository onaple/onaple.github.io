<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[c++ 类的四大函数]]></title>
      <url>%2F2017%2F03%2F05%2Fc-%E7%B1%BB%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[类与对象 类是用户自定义的一种数据类型，定义类时描述它可以提供的信息及能够执行的操作；即类是一种具有属性和行为的自定义的数据类型； 对象就是封装了数据结构，及施加这些数据结构上的操作的封装体； 类与对象的关系：类之于对象如同类型之于变量，因此类只是描述了数据格式和方法，而对象则是根据规范创建的实体；换句话说类就像图纸，而对象则是根据图纸盖起的大楼。 类与结构体的区别唯一的区别在于struct的默认访问权限是public,而类是private; C++中的类所占内存分析： 类所占内存的大小是由成员变量（静态变量除外）决定的，成员函数（这是笼统的说，后面会细说）是不计算在内的。成员函数还是以一般的函数一样的存在。a.fun()是通过fun(a.this)来调用的。 所谓成员函数只是在名义上是类里的。其实成员函数的大小不在类的对象里面，同一个类的多个对象共享函数代码。而我们访问类的成员函数是通过类里面的一个指针实现，而这个指针指向的是一个table， table里面记录的各个成员函数的地址（当然不同的编译可能略有不同的实现）。所以我们访问成员函数是间接获得地址的。所以这样也就增加了一定的时间开销，这也就是为什么我们提倡把一些简短的，调用频率高的函数声明为inline形式（内联函数）。 总结：空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。 类内部的成员变量： 普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。 static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。 类内部的成员函数： 普通函数：不占用内存。 虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的。 C++类中的四大函数：构造函数、拷贝构造函数、析构函数和赋值函数: 四个函数一般系统都会默认。但是往往系统默认的并不是我们所期望的，为此我们有必要自己编写符合要求的函数，参看String.cpp; 把对象的初始化工作放在构造函数中，当对象被创建时，构造函数被自动执行。 把清除工作放在析构函数中。当对象消亡时，析构函数被自动执行，把一切内存垃圾清理，可见他的重要。如果没有析构函数或析构函数不正确就会发生内存泄露等问题，后果非常危险 每个类只有一个析构函数和一个赋值函数，但可以有多个构造函数（包含一个拷贝构造函数，其它的称为普通构造函数）。 构造函数和赋值函数有着很大的区别，构造函数是在对象创建时调用的；而赋值函数使对象已经创建好了存在之后再赋值时调用的。有时候我们懒得写赋值函数和拷贝构造函数，又不允许别人使用编译器生成的缺省函数，那么我们可以只需将拷贝构造函数和赋值函数声明为私有函数，函数体为空即可； 使用对象前正确初始化 并不是所有的编译器都对象对象的内置类型成员会被自动初始化为0。永远在使用对象之前先将它初始化。确保每一个构造函数都将对象的每一个成员初始化。 别把赋值错当成初始化。C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前（对于内置类型对象可能不确定），这点对于非内置类型对象来说尤其关键。如果你没有在成员初始化列表（member initialization list）为其初始化，它们将调用自己的默认构造函数，然后才进入构造函数内部（很可能你会在这里给他们赋值）。在成员初始化列表中的初始化只是调用了拷贝构造函数一次，而在构造函数内部再为其赋值则在调用默认构造函数后又调用了一次拷贝构造函数。因此初始化列表将更为高效 所以，请用成员初始化列表进行初始化，虽然效率提高只针对于非内置类型成员，但是规定总是在初值列中列出所有成员变量，这样就省的有些未被列出的内置类型成员被忘记初始化。而有些时候，即使成员变量是内置类型，也必须要用成员初始化列表（成员变量为const或者reference，它们一定要有初值，而且不能被赋值）。 构造函数 使用构造函数的原因：由于类的封装性,不能象普通变量一样初始化 构造函数的作用：是在对象被创建时使用特定的值构造对象，或者说将对象初始化为一个特定的状态。 调用时刻：在对象创建时由系统自动调用。如果程序中未声明，则系统自动产生出一个缺省形式的构造函数 条件约束：允许为内联函数、重载函数、带缺省形参值的函数；但不允许是虚函数因为在刚开始对象还未被创建，内部什么都没有，更不用说虚表，虚表指针。因此无法调用虚函数。 拷贝构造函数（是一种特殊的构造函数，其形参为本类的对象引用）。 作用：使用一个对象（参数指定的对象），去初始化一个正在被建立的同类型对象（如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个拷贝构造函数。） 调用时刻： 当用类的一个对象去初始化该类的另一个对象时系统自动调用它实现拷贝赋值。 若函数的形参为类对象，调用函数时，实参赋值给形参，系统自动调用拷贝构造函数。 当函数的返回值是类对象时，系统自动调用拷贝构造函数。析构函数作用：完成对象被删除前的一些清理工作。调用时刻：在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间。如果程序中未声明析构函数，编译器将自动产生一个缺省的析构函数。 注意事项： 析构函数也不被继承，派生类自行声明。 声明方法与一般（无继承关系时）类的析构函数相同。 不需要显式地调用基类的析构函数，系统会自动隐式调用。 析构函数的调用次序与构造函数相反。 类组合的构造函数调用 构造函数调用顺序：先调用内嵌对象的构造函数（按内嵌时的声明顺序，先声明者先构造）。然后调用本类的构造函数。（析构函数的调用顺序相反） 若调用缺省构造函数（即无形参的），则内嵌对象的初始化也将调用相应的缺省构造函数。 多继承且有内嵌对象时的构造函数调用次序 调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。 调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序。 静态数据成员在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。 使用静态数据成员可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。 静态数据成员的使用方法和注意事项如下： 静态数据成员在定义或说明时前面加关键字static。 静态成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式如下： &lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt; 这表明： 初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆。 初始化时不加该成员的访问权限控制符private，public等。 初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员。 静态数据成员是静态存储的，它是静态生存期，必须对它进行初始化。 引用静态数据成员时，采用如下格式：&lt;类名&gt;::&lt;静态成员名&gt; 静态成员函数 静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。 在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。如果静态成员函数中要引用非静态成员时，可通过对象来引用。 调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;); 类外代码可以使用类名和作用域操作符来调用静态成员函数。 静态成员函数只能引用属于该类的静态数据成员或静态成员函数。 Inline函数C++ inline函数 ： inline int min(int first, int secend) {/****/}; inline函数对编译器而言必须是可见的，以便它能够在调用点内展开该函数。与非inline函数不同的是，inline函数必须在调用该函数的每个文本文件中定义。 关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。（所以说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。） 慎用内联：内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联： 如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。 内联函数和#define 宏的区别：内联函数总是对参数只精确地进行一次求值，从而避免了那声名狼藉的宏错误。换句话说，调用内联函数和调用正规函数是等价的，差别仅仅是更快 常函数的调用是这样的：常量对象只能调用常成员函数，非常量对象即可以调常成员函数，也可以调一般成员函数，但当某个函数有const和非const两个版本时，const对象调const版本，非const对象调非const版本。 二义性的问题 在多继承时，基类与派生类之间，或基类之间出现同名成员时，将出现访问时的二义性（不确定性）——采用虚函数（第8章）或支配（同名覆盖）原则来解决。 当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性——采用虚基类来解决。 虚基类引入 用于有共同基类的场合声明 以virtual修饰说明基类 例：class B1:virtual public B 作用： 主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题. 为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝 注意： 在第一级继承时就要将共同基类设计为虚基类。 虚基类及其派生类构造函数 建立对象时所指定的类称为最（远）派生类。 虚基类的成员是由最派生类的构造函数通过调用虚基类的构造函数进行初始化的。 在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中给出对虚基类的构造函数的调用。如果未列出，则表示调用该虚基类的缺省构造函数。 在建立对象时，只有最派生类的构造函数调用虚基类的构造函数，该派生类的其它基类对虚基类构造函数的调用被忽略。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[c++ 继承]]></title>
      <url>%2F2017%2F03%2F05%2Fc-%E7%BB%A7%E6%89%BF%2F</url>
      <content type="text"><![CDATA[继承与派生： 保持已有类的特性而构造新类的过程称为继承。 在已有类的基础上新增自己的特性而产生新类的过程称为派生。 继承的目的：实现代码重用。 派生的目的：当新的问题出现，原有程序无法解决（或不能完全解决）时，需要对原有程序进行改造。 三种继承方式 公有继承；私有继承；保护继承不同继承方式的影响主要体现在: 派生类成员对基类成员的访问控制。 派生类对象对基类成员的访问控制。 1.公有继承： 继承方式：基类的public和protected成员的访问属性在派生类中保持不变，但基类的private成员不可访问。 类内： 派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。 类外：通过派生类的对象只能访问基类的public成员。 2.私有继承： 继承方式：基类的public和protected成员都以private身份出现在派生类中，但基类的private成员不可访问。 类内：派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。 类外：通过派生类的对象不能访问基类中的任何成员。 3.保护继承： 继承方式：基类的public和protected成员都以protected身份出现在派生类中，但基类的private成员不可访问。 类内：派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。 类外：通过派生类的对象不能访问基类中的任何成员 4.protected 成员的特点与作用： 对建立其所在类对象的模块来说（水平访问时），它与 private 成员的性质相同。 对于其派生类来说（垂直访问时），它与 public 成员的性质相同。 . 既实现了数据隐藏，又方便继承，实现代码重用； 基类与派生类的对应关系 单继承: 派生类只从一个基类派生。 多继承：派生类从多个基类派生。 多重派生: 由一个基类派生出多个不同的派生类。 多层派生: 派生类又作为基类，继续派生新的类。 继承时的构造函数 基类的构造函数不被继承，需要在派生类中自行声明。 声明构造函数时，只需要对本类中新增成员进行初始化，对继承来的基类成员的初始化由基类完成。 多重继承构造函数的调用次序 调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。 调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序。 派生类的构造函数体中的内容。 多重继承时的析构函数 析构函数也不被继承，派生类自行声明。 声明方法与一般（无继承关系时）类的析构函数相同。 不需要显式地调用基类的析构函数，系统会自动隐式调用。 析构函数的调用次序与构造函数相反。 二义性问题 在多继承时，基类与派生类之间，或基类之间出现同名成员时，将出现访问时的二义性（不确定性）——采用虚函数或支配（同名覆盖）原则来解决。 当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性——采用虚基类来解决。（菱形继承） 虚基类声明: 以virtual修饰说明基类 例：class B1:virtual public B 作用： 主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题. 为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝 注意：在第一级继承时就要将共同基类设计为虚基类。 赋值兼容原则一个公有派生类的对象在使用上可以被当作基类的对象，反之则禁止。具体表现在： 派生类的对象可以被赋值给基类对象。 派生类的对象可以初始化基类的引用。 指向基类的指针也可以指向派生类。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[c++ 多态]]></title>
      <url>%2F2017%2F03%2F05%2Fc-%E7%9A%84%E5%A4%9A%E6%80%81%2F</url>
      <content type="text"><![CDATA[C和C++的区别： C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制）。C的优势在于编写的程序更接近于硬件，仅次于汇编语言，所以他相对其他编程语言高效的多，但同时程序员负责一切不安全，如内存泄露等。但正是由于这样的风险的存在，对程序员的紧密思维要求更高。 C++是有C，面向对象，泛型编程，stl组成。用面向对象来编程首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。 所以C与C++的最大区别在于它们的用于解决问题的思想方法不一样。之所以说C++比C更先进，是因为“ 设计这个概念已经被融入到C++之中 ”。 面向对象的三大特性：封装，继承，多态 封装：将对象的属性和方法封装在对象内部，形成一个个独立的单元模块，对外通访问权限控制管理对象数据的交互。(访问权限：（private，protected,public) 保证封装性的关键)目的：增强代码的安全性和简化编程，让使用者不必了解类具体的实现细节，只要通过外部接口，以特定的权限来使用类的方法即可。 继承：一个对象获得另一对象的特性的过程。是将一群类组织起来，定义了父子关系，实现了代码的重用，父类定义了所有子类的的共有借口和私有实现，同时子类都可以增加或覆盖继承来的东西，以实现独有的行为。 多态：它是建立在了继承的基础上；简单来说，就是一个接口，多个方法.具体来说：它是指不同子类在继承父类后分别覆盖了父类的方法多态性使得同一属性或者行为在基类及其子类间有不同的语义；多态性丰富了对象的内容，增强了软件的灵活性和可重用性；C++的多态性有两种：编译时的多态（函数重载），运行时多态（虚函数）（联编（binding)或称为绑定:是指计算机程序自身彼此关联的过程联编工作在编译连接阶段完成的情况称为：静态联编联编在程序运行阶段完成的情况称为：动态联编。） c++ 重载 覆盖 隐藏的区别和执行方式 : 成员函数被重载的特征:相同的范围（在同一个类中）；函数名字相同；参数不同； virtual 关键字可有可无。 覆盖是指派生类函数覆盖基类函数，特征是:不同的范围（分别位于派生类与基类）； 函数名字相同； 参数相同； 基类函数必须有virtual 关键字。 “隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下:如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆） 3种情况怎么执行：重载：看参数;隐藏：用什么就调用什么;覆盖：调用派生类; 虚函数的工作原理：编译器处理虚函数的方法是.给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。而这个数组称为虚函数表，虚函数表中存储了为类对象进行声明的虚函数的地址。 单继承时 虚函数指针在对象的最前面的位置； 虚函数地址按照声明的顺序存放于虚表中； 父类虚函数地址在子类虚函数地址的前面； 子类如果覆盖父类的虚函数，则被放到虚表中原父类虚函数的位置 没有被覆盖的函数依旧在原位。 多重继承的特殊地方： 每个父类都有自己的虚表时，子类的虚函数成员只被放到第一个父类中。 子类有多个虚表指针，位于类的最前面，分别指向不同的父类的虚表，（按继承的顺序）。 如果有覆盖情况，则替换所有被覆盖的父类虚函数地址。 父类访问子类中成员函数只能通过虚函数，覆盖的方法。否则无法访问。但我们可以通过函数指针强行访问虚表里的函数。本人就是通过此方法的出的以上结论。 虚函数特性： 虚函数是动态联编的基础。 是非静态的成员函数。 在类的声明中，在函数原型之前写virtual。 virtual 只用来说明类声明中的原型，不能用在函数实现时。 具有继承性，基类中声明了虚函数，派生类中无论是否说明，同原型函数都自动为虚函数。 本质：不是重载声明而是覆盖。 调用方式：通过基类指针或引用，执行时会根据指针指向的对象的类，决定调用哪个函数。 虚函数的限制 只有类的成员函数才能说明为虚函数，因为虚函数仅适用于继承关系的 类对象，所以普通函数不能说明为虚函数。 内联函数不能是虚函数，因为内联函数是在编译时决 定其位置。 构造函数不能是虚函数，因为构造时对象还是一片未 定型的空间，就没有虚指针，虚表。。 析构函数可以是虚函数，而且通常声明为虚函数。纯虚函数与抽象类 带有纯虚函数的类称为抽象类: 1class 类名 &#123; virtual 类型 函数名(参数表)=0; //纯虚函 ... &#125;; 作用： 抽象类为抽象和设计的目的而建立，将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为。 对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现。主要作用是通过它为一个类族建立一个公共的接口，使它们能够更有效地发挥多态特性。 注意：抽象类只能作为基类来使用;不能声明抽象类的对象;但可以声明一个指针]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[c++ 模板]]></title>
      <url>%2F2017%2F03%2F05%2Fc-%E6%A8%A1%E6%9D%BF%2F</url>
      <content type="text"><![CDATA[模板是C++支持参数化多态的工具，使用模板可以使用户为类或者函数声明一种一般模式，使得类中的某些数据成员或者成员函数的参数、返回值取得任意类型。 模板是一种对类型进行参数化的工具；通常有两种形式：函数模板和类模板；函数模板针对仅参数类型不同的函数；类模板针对仅数据成员和成员函数类型不同的类。 使用模板的目的：就是能够让程序员编写与类型无关的代码。 注意：模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。 1.函数模板定义格式:template &lt;class 形参名，class 形参名，......&gt; 返回类型 函数名(参数列表) { 函数体 } 模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。 2.函数模板 函数模板可以用来创建一个通用功能的函数，以支持多种不同形参，进一步简化重载函数的函数体设计。 函数模板提供一个种用来自动生成各种类型函数实例的算法，程序员对于函数接口参数和返回类型中的全部或者部分类型进行参数化(parameterize)，而函数体保持不变。 注意：模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。 注意：对于函数模板而言不存在 h(int,int) 这样的调用，不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行，即只能进行 h(2,3) 这样的调用，或者int a, b; h(a,b) 函数模板实例化 函数模板只是声明了一个函数的描述即模板，不是一个可以直接执行的函数，只有根据实际情况用实参的数据类型代替类型参数标识符之后，才能产生真正的函数。 函数模板的数据类型参数标识符实际上是一个类型形参，在使用函数模板时，要将这个形参实例化为确定的数据类型。将类型形参实例化的参数称为模板实参，用模板实参实例化的函数称为模板函数。模板函数的生成就是将函数模板的类型形参实例化的过程。 函数模板在它被调用或取其地址时被实例化 模板函数类似于重载函数，但两者有很大区别：函数重载时，每个函数体内可以执行不同的动作，但同一个函数模板实例化后的模板函数都必须执行相同的动作 3.函数模板与同名的非模板函数重载时，应遵循下列调用原则： 寻找一个参数完全匹配的函数，若找到就调用它。若参数完全匹配的函数多于一个，则这个调用是一个错误的调用。 寻找一个函数模板，若找到就将其实例化生成一个匹配的模板函数并调用它。 若上面两条都失败，则使用函数重载的方法，通过类型转换产生参数匹配，若找到就调用它。 若上面三条都失败，还没有找都匹配的函数，则这个调用是一个错误的调用 4.类模板定义：template&lt;class 形参名，class 形参名，…&gt; class 类名 {... }; 类模板和函数模板都是以template开始后接模板形参列表组成，模板形参不能为空，一但声明了类模板就可以用类模板的形参名声明类中的成员变量和成员函数，即可以在类中使用内置类型的地方都可以使用模板形参名来声明。比如: template&lt;class T&gt; class A{public: T a; T b; T hy(T c, T &amp;d);}; 5.类模板对象的创建： 比如一个模板类A，则使用类模板创建对象的方法为A m;在类A后面跟上一个&lt;&gt;尖括号并在里面填上相应的类型，这样的话类A中凡是用到模板形参的地方都会被int 所代替。当类模板有两个模板形参时创建对象的方法为A m;类型之间用逗号隔开。 对于类模板，模板形参的类型必须在类名后的尖括号中明确指定。比如A m;用这种方法把模板形参设置为int是错误的（编译错误：error C2079: ‘a’ uses undefined class ‘A‘），类模板形参不存在实参推演的问题。也就是说不能把整型值2推演为int 型传递给模板形参。要把类模板形参调置为int 型必须这样指定A m。 6.在类模板外部定义成员函数的方法为：template&lt;模板形参列表&gt; 函数返回类型 类名&lt;模板形参名&gt;::函数名(参数列表){函数体}； 比如有两个模板形参T1，T2的类A中含有一个void h()函数，则定义该函数的语法为： template&lt;class T1,class T2&gt; void A&lt;T1,T2&gt;::h(){}。 注意：当在类外面定义类的成员时template后面的模板形参应与要定义的类的模板形参一致。 7.模板的实例化：类模板在引用实际模板类类型时实例化 定义模板类对象时 通过类指针或引用指向一个类模板实例时，只有当检查这个指针或引用指的那个对象时(访问数据成员或成员函数)，才会实例化 当类模板被实例化时，类模板的成员函数并不自动被实例化。只有该函数被调用或取地址时，才被实例化。 静态数据成员只有被使用时才实例化。 8.类模板和函数模板区别 函数模板允许重载 ，而类模板不允许重载(类无重载概念，即不存在同名类模板)。 类模板可以进行全特化和偏特化，而函数模板仅能够全特化 。 类模板支持默认参数，函数模板不支持]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F02%2F10%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
