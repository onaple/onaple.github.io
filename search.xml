<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[c++的多态]]></title>
      <url>%2F2017%2F03%2F05%2Fc-%E7%9A%84%E5%A4%9A%E6%80%81%2F</url>
      <content type="text"><![CDATA[C和C++的区别： C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制）。C的优势在于编写的程序更接近于硬件，仅次于汇编语言，所以他相对其他编程语言高效的多，但同时程序员负责一切不安全，如内存泄露等。但正是由于这样的风险的存在，对程序员的紧密思维要求更高。 C++是有C，面向对象，泛型编程，stl组成。用面向对象来编程首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。 所以C与C++的最大区别在于它们的用于解决问题的思想方法不一样。之所以说C++比C更先进，是因为“ 设计这个概念已经被融入到C++之中 ”。 面向对象的三大特性：封装，继承，多态 封装：将对象的属性和方法封装在对象内部，形成一个个独立的单元模块，对外通访问权限控制管理对象数据的交互。(访问权限：（private，protected,public) 保证封装性的关键)目的：增强代码的安全性和简化编程，让使用者不必了解类具体的实现细节，只要通过外部接口，以特定的权限来使用类的方法即可。 继承：一个对象获得另一对象的特性的过程。是将一群类组织起来，定义了父子关系，实现了代码的重用，父类定义了所有子类的的共有借口和私有实现，同时子类都可以增加或覆盖继承来的东西，以实现独有的行为。 多态：它是建立在了继承的基础上；简单来说，就是一个接口，多个方法.具体来说：它是指不同子类在继承父类后分别覆盖了父类的方法多态性使得同一属性或者行为在基类及其子类间有不同的语义；多态性丰富了对象的内容，增强了软件的灵活性和可重用性；C++的多态性有两种：编译时的多态（函数重载），运行时多态（虚函数）（联编（binding)或称为绑定:是指计算机程序自身彼此关联的过程联编工作在编译连接阶段完成的情况称为：静态联编联编在程序运行阶段完成的情况称为：动态联编。） c++ 重载 覆盖 隐藏的区别和执行方式 : 成员函数被重载的特征:相同的范围（在同一个类中）；函数名字相同；参数不同； virtual 关键字可有可无。 覆盖是指派生类函数覆盖基类函数，特征是:不同的范围（分别位于派生类与基类）； 函数名字相同； 参数相同； 基类函数必须有virtual 关键字。 “隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下:如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆） 3种情况怎么执行：重载：看参数;隐藏：用什么就调用什么;覆盖：调用派生类; 虚函数的工作原理：编译器处理虚函数的方法是.给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。而这个数组称为虚函数表，虚函数表中存储了为类对象进行声明的虚函数的地址。 单继承时 虚函数指针在对象的最前面的位置； 虚函数地址按照声明的顺序存放于虚表中； 父类虚函数地址在子类虚函数地址的前面； 子类如果覆盖父类的虚函数，则被放到虚表中原父类虚函数的位置 没有被覆盖的函数依旧在原位。 多重继承的特殊地方： 每个父类都有自己的虚表时，子类的虚函数成员只被放到第一个父类中。 子类有多个虚表指针，位于类的最前面，分别指向不同的父类的虚表，（按继承的顺序）。 如果有覆盖情况，则替换所有被覆盖的父类虚函数地址。 父类访问子类中成员函数只能通过虚函数，覆盖的方法。否则无法访问。但我们可以通过函数指针强行访问虚表里的函数。本人就是通过此方法的出的以上结论。 虚函数特性： 虚函数是动态联编的基础。 是非静态的成员函数。 在类的声明中，在函数原型之前写virtual。 virtual 只用来说明类声明中的原型，不能用在函数实现时。 具有继承性，基类中声明了虚函数，派生类中无论是否说明，同原型函数都自动为虚函数。 本质：不是重载声明而是覆盖。 调用方式：通过基类指针或引用，执行时会根据指针指向的对象的类，决定调用哪个函数。 虚函数的限制 只有类的成员函数才能说明为虚函数，因为虚函数仅适用于继承关系的 类对象，所以普通函数不能说明为虚函数。 内联函数不能是虚函数，因为内联函数是在编译时决 定其位置。 构造函数不能是虚函数，因为构造时对象还是一片未 定型的空间，就没有虚指针，虚表。。 析构函数可以是虚函数，而且通常声明为虚函数。纯虚函数与抽象类 带有纯虚函数的类称为抽象类: 1class 类名 &#123; virtual 类型 函数名(参数表)=0; //纯虚函 ... &#125;; 作用： 抽象类为抽象和设计的目的而建立，将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为。 对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现。主要作用是通过它为一个类族建立一个公共的接口，使它们能够更有效地发挥多态特性。 注意：抽象类只能作为基类来使用;不能声明抽象类的对象;但可以声明一个指针]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[c++ 模板]]></title>
      <url>%2F2017%2F03%2F05%2Fc-%E6%A8%A1%E6%9D%BF%2F</url>
      <content type="text"><![CDATA[模板 模板是C++支持参数化多态的工具，使用模板可以使用户为类或者函数声明一种一般模式，使得类中的某些数据成员或者成员函数的参数、返回值取得任意类型。 模板是一种对类型进行参数化的工具；通常有两种形式：函数模板和类模板；函数模板针对仅参数类型不同的函数；类模板针对仅数据成员和成员函数类型不同的类。 使用模板的目的：就是能够让程序员编写与类型无关的代码。 注意：模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。 1.函数模板定义格式:template &lt;class 形参名，class 形参名，......&gt; 返回类型 函数名(参数列表) { 函数体 } 模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。 2.函数模板 函数模板可以用来创建一个通用功能的函数，以支持多种不同形参，进一步简化重载函数的函数体设计。 函数模板提供一个种用来自动生成各种类型函数实例的算法，程序员对于函数接口参数和返回类型中的全部或者部分类型进行参数化(parameterize)，而函数体保持不变。 注意：模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。 注意：对于函数模板而言不存在 h(int,int) 这样的调用，不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行，即只能进行 h(2,3) 这样的调用，或者int a, b; h(a,b) 函数模板实例化 函数模板只是声明了一个函数的描述即模板，不是一个可以直接执行的函数，只有根据实际情况用实参的数据类型代替类型参数标识符之后，才能产生真正的函数。 函数模板的数据类型参数标识符实际上是一个类型形参，在使用函数模板时，要将这个形参实例化为确定的数据类型。将类型形参实例化的参数称为模板实参，用模板实参实例化的函数称为模板函数。模板函数的生成就是将函数模板的类型形参实例化的过程。 函数模板在它被调用或取其地址时被实例化 模板函数类似于重载函数，但两者有很大区别：函数重载时，每个函数体内可以执行不同的动作，但同一个函数模板实例化后的模板函数都必须执行相同的动作 3.函数模板与同名的非模板函数重载时，应遵循下列调用原则： 寻找一个参数完全匹配的函数，若找到就调用它。若参数完全匹配的函数多于一个，则这个调用是一个错误的调用。 寻找一个函数模板，若找到就将其实例化生成一个匹配的模板函数并调用它。 若上面两条都失败，则使用函数重载的方法，通过类型转换产生参数匹配，若找到就调用它。 若上面三条都失败，还没有找都匹配的函数，则这个调用是一个错误的调用 4.类模板定义：template&lt;class 形参名，class 形参名，…&gt; class 类名 {... }; 类模板和函数模板都是以template开始后接模板形参列表组成，模板形参不能为空，一但声明了类模板就可以用类模板的形参名声明类中的成员变量和成员函数，即可以在类中使用内置类型的地方都可以使用模板形参名来声明。比如: template&lt;class T&gt; class A{public: T a; T b; T hy(T c, T &amp;d);}; 5.类模板对象的创建： 比如一个模板类A，则使用类模板创建对象的方法为A m;在类A后面跟上一个&lt;&gt;尖括号并在里面填上相应的类型，这样的话类A中凡是用到模板形参的地方都会被int 所代替。当类模板有两个模板形参时创建对象的方法为A m;类型之间用逗号隔开。 对于类模板，模板形参的类型必须在类名后的尖括号中明确指定。比如A m;用这种方法把模板形参设置为int是错误的（编译错误：error C2079: ‘a’ uses undefined class ‘A‘），类模板形参不存在实参推演的问题。也就是说不能把整型值2推演为int 型传递给模板形参。要把类模板形参调置为int 型必须这样指定A m。 6.在类模板外部定义成员函数的方法为：template&lt;模板形参列表&gt; 函数返回类型 类名&lt;模板形参名&gt;::函数名(参数列表){函数体}； 比如有两个模板形参T1，T2的类A中含有一个void h()函数，则定义该函数的语法为： template&lt;class T1,class T2&gt; void A&lt;T1,T2&gt;::h(){}。 注意：当在类外面定义类的成员时template后面的模板形参应与要定义的类的模板形参一致。 7.模板的实例化：类模板在引用实际模板类类型时实例化 定义模板类对象时 通过类指针或引用指向一个类模板实例时，只有当检查这个指针或引用指的那个对象时(访问数据成员或成员函数)，才会实例化 当类模板被实例化时，类模板的成员函数并不自动被实例化。只有该函数被调用或取地址时，才被实例化。 静态数据成员只有被使用时才实例化。 8.类模板和函数模板区别 函数模板允许重载 ，而类模板不允许重载(类无重载概念，即不存在同名类模板)。 类模板可以进行全特化和偏特化，而函数模板仅能够全特化 。 类模板支持默认参数，函数模板不支持]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F02%2F10%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
