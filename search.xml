<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LINUX启动过程]]></title>
    <url>%2F2017%2F09%2F02%2FLINUX%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[linux开机启动过程,必须经过加载BOIS、读取MBR、Boot Loader、加载内核、启动init进程并确定运行等级、执行初始化脚本、启动内核模块、执行对应运行等级的初始化脚本、个性化设置、进入登录状态的这十个步骤 一、 BIOS (Basic Input Output System)基本输入输出系统 按下电源按钮触发CPU的reset引脚。CS寄存器会设值为0xffff;eip = 0x0000 。此时CPU会从内存的0xffff0处执行代码。此处就是一条跳转到BIOS的指令 BIOS读取CMOS了解硬件情况，开机自检，并对硬件初始化，然后将控制权交给MBR程序。 二、MBR（Master Boot Record）主引导记录 MBR是在Boot Sector（512字节）里的446字节。那Boot Sector是什么呢，他是引导扇区，在磁盘上占512字节，其中包括MBR（446字节）、DPT（磁盘分区表64子节）、BRID（引导记录表示2字节）。 BIOS会将Boot Sector里的所有内容读到地址是0x7c00的内存位置。（Boot Sector就是BIOS在读取CMOS时被设为启动设备的第一扇区） BIOS首先会检验BRID是不是0x55AA,是的话才会将控制权交给MBR。 由于MBR只有446个字节，所以它只是个跳板，然后把控制权交给GRUB 三、 GRUB （Grand Unified BootLoader）牛逼的统一引导加载器 BootLoader是什么呢？他是在操作系统内核运行前运行的一小段程序，他负责将操作系统的内核加载到内存，然后将电脑的控制权交给操作系统。同时还会搜集电脑的硬件信息、初始化硬件设备、安排内存布局等。 GRUB的特点： 动态可配置化的，它在启动时读取配置信息，且允许启动时修改。 提供菜单供用户选择要启动的操作系统。 支持多种语言、支持链式启动。 拥有丰富的控制台命令与用户交互、支持的操作系统非常广泛。 GRUB2的工作流程 它比较霸道，必须提供1M的内存空间，来放置他的核心代码，位置无所谓，但必须在2T以内，否则找不到。 第一阶段：占用MBR的坑（这是对付BISO的唯一方法）。编译好的代码叫boot.img（512字节）；他去那1M的空间找diskboot.img代码。 第二阶段：diskboot.img是第二阶段的代码，大小也是512字节。是GRUB核心文件的第一个扇区。这个阶段的代码就是继续将core.img文件余下的部分读到内存，然后继续执行。 第三阶段：开始加载GRUB内核模块。这样做的好处是core.img可以做的很小，可配置性和可扩展性非常高。 第四阶段：启动操作界面，供用户选择要启动的操作系统。 （内核启动参数的的传递） 四、加载内核 Bootloader在保护模式下（32位字长、32位寻址）直接交权给内核。 内核调用startup_32对自己解压缩。 跳转到startup_32这个函数继续执行。（注：这两个函数虽然同名，但是是不一样的）。 这个startup_32函数它代表了Linux的第一个进程process0的开始。这里，他会决定Linux的布局；Linux了解了自己将要与什么样的CPU在一起；会把由BIOS提供和BootLoader们整理的资料放入内存的第一个分页；同时为中断做好准备；如果是64位系统，将把长模式开启，最后会跳到Linux内核的主函数start_kernel。开启内核的生命之旅。 start_kernel函数位于init/mian.c这个文件中。它大部分时间是在为Linux内核准备必要的数据结构。比如：用于内存管理的数据结构，用于任务调度的数据结构，用于处理中断的数据结构，用于处理文件系统的数据结构。经过这些初始化后，Linux此时已经具有了一个操作系统应该具备的功能。 start_kernel内核线程会创建一个名为kernel_init的内核线程。然后进入自己的归宿cpu_idle函数,进入无休止的循环当中。这个cpu_idle函数就是我们常见的CPU占用率经常是99%的进程。进程PID为0.它会一直调用CPU的idle指令，让CPU降温且省电，优先级是很低的。 kernel_init内核线程是新的Linux这么叫的，老得叫init内核线程。这是Linux的第二个进程，也是init的PID一定是1的由来。（在新的内核代码中，由于必须在创建kernel_init之前创建另一个内核线程来做一些更重要的事，所以不得不先创建kernel_init，并把它锁起来，然后再创建新的内核线程，然后等他执行完后再解锁。否则init的PID会变为2）。 kernel_init内核线程比较重要的工作就是让Linux内核开始与外面进行沟通。比如：给硬件加载驱动程序、初始化网络堆栈、在多CPU系统中让其他CPU开始工作，寻找用户的根文件系统。 kernel_init内核线程等一切都稳妥后，会调用用户空间的第一个进程init程序。此时，内核初始化完成。 五、 启动init进程并确定运行等级 内核通过initramfs启动init进程。 initramfs是一个使用gzip压缩的cpi_o打包文件，内核会将它的内容装入一个tmpfs，这就不需要附带任何文件系统驱动就能工作了。 initramfs直接启动init进程，initramfs是由bootloader准备好，告诉内核它在什么位置。内核知道后，直接启动initramfs中的init进程。接下来找根文件系统就交给init进程了。 init进程会根据用户设定的一个运行级别来对Linux系统进行初始化。比如：启动对应运行级别的服务进程，配置网络等。init进程会接受用户的 CTRL + Alt + Del 令Linux系统重新启动；也可以切换运行级别。当用户要关闭Linux系统时，init进程会将未来得及保存的文件保存好。init会收养孤儿进程。还可以保护某些进程不被kill。是Linux的守护神。]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>启动过程</tag>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码规范与整洁之道]]></title>
    <url>%2F2017%2F08%2F27%2F%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%B8%8E%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%2F</url>
    <content type="text"><![CDATA[1. 别传递以及返回null值 在方法中返回null值是很糟糕的的做法，但将null值传递给其他方法也就更糟糕了，除非API要求向他传递null，否则应尽量避免。 原因如下： 当传参时，传入null值，我们就必须创建异常，或者使用断言，但这些都会导致运行时错误。所以，应尽量避免传入null值。 返回值为null时，处理者必须对其进行非空判断，增加自己的工作量。而且在python中，可以同时返回多个变量，返回null，会使接受返回值变得很麻烦。替代方案就是抛出异常，或者返回特例。 2. 避免凌乱的错误处理代码 使用异常，而非返回码 原因：它会搞乱调用者的代码，调用者必须在调用之后即即刻检查错误，这容易别遗忘，而且处理起来麻烦]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>代码规范</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA DEBUG SLOW]]></title>
    <url>%2F2017%2F08%2F22%2FIDEA-DEBUG-SLOW%2F</url>
    <content type="text"><![CDATA[hi, all 我之前做单元覆盖率时遇到了两个问题。1.跑测试时，运行特别慢。2.debug根本进入不了断点。无法debug。 之前以前一直知道不到解决方法，昨天在苦苦查寻下，找到了，解决方法。如果你的test跑的很慢可以借鉴，希望对大家有帮助，帮大家节约一些宝贵的时间。 问题一产生的原因：升级到macOS Sierra后，造成的。 解决方法：命令行运行一下命令：sudo sed -i bak “s^127.0.0.1.^127.0.0.1 localhost $(hostname)^g” /etc/hostssudo sed -i bak “s^::1.^::1 localhost $(hostname)^g” /etc/hostssudo ifconfig en0 downsudo ifconfig en0 up 其他方法参考下面链接 参考链接： 问题二产生的原因：设置了方法断点，idea会提示：method breakpoint may dramatically slow debugging 解决方法：去除所有方法断点 参考链接：]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>DEBUG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码覆盖率]]></title>
    <url>%2F2017%2F08%2F13%2F%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%2F</url>
    <content type="text"><![CDATA[JaCoCoJaCoCo简述JaCoCo是一个开源的覆盖率工具( 官网地址：http://www.eclemma.org/JaCoCo/ )，它针对的开发语言是java，其使用方法很灵活，可以嵌入到Ant、Maven中；可以作为Eclipse插件，可以使用其JavaAgent技术监控Java程序等等。很多第三方的工具提供了对JaCoCo的集成，如sonar、Jenkins等。 使用姿势 在Bulid 的 plungs中加入以下plugn 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 &lt;plugin&gt; &lt;groupId&gt;org.jacoco&lt;/groupId&gt; &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.7.9&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;pre-unit-test&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;prepare-agent&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;destFile&gt;$&#123;project.build.directory&#125;/coverage-reports/jacoco.exec&lt;/destFile&gt; &lt;propertyName&gt;surefireArgLine&lt;/propertyName&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;execution&gt; &lt;id&gt;post-unit-test&lt;/id&gt; &lt;phase&gt;test&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;report&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;dataFile&gt;$&#123;project.build.directory&#125;/coverage-reports/jacoco.exec&lt;/dataFile&gt; &lt;outputDirectory&gt;$&#123;project.reporting.outputDirectory&#125;/jacoco&lt;/outputDirectory&gt; &lt;--包含要被测试的类--&gt; &lt;includes&gt; &lt;include&gt;me/ele/**&lt;/include&gt; &lt;/includes&gt; &lt;--排除要被测试的类--&gt; &lt;excludes&gt; &lt;exclude&gt;**/*Mock*.class&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.19.1&lt;/version&gt; &lt;configuration&gt; &lt;argLine&gt;$&#123;surefireArgLine&#125;&lt;/argLine&gt; &lt;skipTests&gt;false&lt;/skipTests&gt; &lt;testFailureIgnore&gt;true&lt;/testFailureIgnore&gt; &lt;--包含测试的类--&gt; &lt;includes&gt; &lt;include&gt;me/ele/**&lt;/include&gt; &lt;include&gt;com/**&lt;/include&gt; &lt;/includes&gt; &lt;--排除测试的类--&gt; &lt;excludes&gt; &lt;exclude&gt;**/Account*Test.java&lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt;&lt;/plugin&gt;&lt;plugin&gt; &lt;groupId&gt;me.ele.fin&lt;/groupId&gt; &lt;artifactId&gt;jacoco-console-report&lt;/artifactId&gt; &lt;version&gt;0.0.1-RELEASE&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;console&lt;/id&gt; &lt;phase&gt;prepare-package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;console&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt; 在pom下加入reporting 12345678910111213141516&lt;reporting&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.jacoco&lt;/groupId&gt; &lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt; &lt;reportSets&gt; &lt;reportSet&gt; &lt;reports&gt; &lt;!-- select non-aggregate reports --&gt; &lt;report&gt;report&lt;/report&gt; &lt;/reports&gt; &lt;/reportSet&gt; &lt;/reportSets&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/reporting&gt; mvn命令, 生成测试报告文档 1mvn clean package -U -DfailIfNoTests=false -f om.xml -X JaCoCo遇到的问题以及解决方式： 项目运行时卡住不动了，解决方法，在每个模块下的pom都配置jacoco。 项目运行报错，类重复加载。产生的原因：test类加载配置文件不同统一，spring配置文件加载了两次造成。另一次是，redis与mysql更换导致运行，运行失败、速度过慢，覆盖率大幅度下降。 ${surefireArgLine}标红解决方案 JaCoCo参考文档参考文档1:jacoco 原理篇 参考文档2: Jacoco覆盖率工具使用之maven篇 单元测试单元测试的概述所谓单元测试，是指对软件设计的最小单位，进行正确性检验的测试工作。而检验的方法，一般来说是由开发人员编写一小段测试代码，根据被测目标代码的应用场景，设计拥有合理覆盖度的输入条件，调用执行目标代码，然后判断输出结果是否与预期一致。被测试目标代码一般应具体到类的方法层面上。 总之，单元测试是一个方法层级上的测试，单元测试也是最细粒度的测试，用于测试一个类的每一个方法都已经满足了方法的功能需求。 一个单元测试用例需要包含什么 每个测试有明确的预期结果 每个测试一个(必须要有)断言,没有断言的case是骗人的case 如果你发现一个case需要两个断言,那么它们应该是两个case 为了测试时隔离模块(如下游soa服务,数据库等),使用stubs、mock或fake等测试马甲程序 有必要的注释，描述unit test case的基本作用 单元测试(unit test)对象 单元测试关注一个方法或一个类。它应该非常小，最多只有几行代码。 因为非常小一个单元测试用例应该在几毫秒内运行完成。 任何用到外部依赖（数据库、WebService、文件系统、I/O）的测试都不是单元测试，而是“集成测试（integration test）”、“综合测试（integrated test）”、验收测试、端到端测试等等 MOCKMockito简介什么是mock？在软件开发的世界之外, “mock”一词是指模仿或者效仿。 因此可以将“mock”理解为一个替身，替代者。在软件开发中提及”mock”，通常理解为模拟对象或者Fake。 为什么需要Mock?Mock是为了解决units之间由于耦合而难于被测试的问题。所以mock object是unit test的一部分。 参考链接1:Mockito浅谈 参考链接2:手把手教你 Mockito 的使用 maven依赖12345&lt;dependency&gt; &lt;groupId&gt;org.mockito&lt;/groupId&gt; &lt;artifactId&gt;mockito-all&lt;/artifactId&gt; &lt;version&gt;2.0.2-beta&lt;/version&gt;&lt;/dependency&gt; 个人demo参考]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
        <tag>JACOCO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[x86系统编译原理]]></title>
    <url>%2F2017%2F03%2F05%2Fx86%E7%B3%BB%E7%BB%9F%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[编译过程简述编译：预处理主要处理源文件中以“#”开头的预编译指令，例如#include，#define，#ifdef，#pragma等。 编译通过词法分析（生成一系列记号），语法分析（根据一系列记号生成语法树），语义分析（对语法树每一部分做有效性检查），优化后生成汇编代码。 汇编产生机器指令。 ELF文件（这里指.o文件）中包含什么？ 文件头 段表：包含了段的基本属性，例如每个段的段名，段的长度，在文件中的偏移，读写权限等。 重定位表：链接器在处理目标文件时，需要对文件的某些部分进行重定位。这些重定位信息就保存在重定位表里。 字符串表 符号表：每个目标文件中都会有一个符号表，记录了目标文件中用到的所有符号。每个符号有一个符号值，对于变量和函数而言，符号值就是它们的地址（我理解的是在文件中的相对偏移量，因为符号的虚拟地址是在链接后才重定位的，那么地址也只能是在文件中的地址。不知道对不对）。分别有全局符号，段名，局部符号。符号表往往是一个段，叫作.symtab。 链接步骤（俗称两步链接） 空间与地址分配，扫描所有的输入目标文件，并确定它们各个段的长度，属性和位置，并将输入目标文件符号表中的所有符号定义和符号引用收集起来，统一放到一个全局符号表。链接器获得所有输入目标文件的段长度，并将它们合并，计算出文件中各个段合并后的长度与位置，并建立映射关系（也就是说，已经分配了虚拟地址空间）。 符号解析与重定位。因为每个符号相对于所在段的偏移是确定的。而且，每个段虚拟地址已经分配，所以，只需将段起始地址加偏移量就可以得到符号的虚拟地址。也就实现了重定位。 ###动态链接：解决的问题：1.空间浪费2.程序更新，部署，发布困难。 编译器将程序语言的代码转化为其他形式的软件。这个转换过程叫做编译。Eg:c-&gt;(gcc) Linux可执行的文件通常指符合（ELF）Executable and Linking Format)这种特定形式的文件。ls 、cp 这些命令对应的实体文件都是可执行文件，使用file命令能查看文件是否符合ELF形式。ELF文件包含了程序以及如何运行程序的相关信息（元数据），机器语言是唯一一种cpu能够直接执行的语言，这里的程序或代码就是指机器语言的列表。 gccgcc 是将C语言的程序转化为机器语言描述的程序，将机器语言的程序按照ELF这种特定文件格式注入 文件，得到的就是可执行文件。由hello.c这样单个文件来生成可执行文件的过程如下：预处理（.i）侠义的编译(.s)—&gt;汇编(.o)-&gt;链接(.exe)。这个过程统称为build. 预处理：由编译器对#include和#define进行处理。具体 来说，读入头文件，将所有的宏展开。预处理的内容近似于sed命令和awk命令这样纯文本的操作。 狭义的编译：编译器对预处理器的输出进行编译，生成汇编语言（.s）。 汇编：汇编器将汇编语言的代码转换为机器语言。汇编器的输出文件为目标文件（.o）。linux下目标文件也是ELF文件；目标文件和可执行文件是通过ELF文件中用于提取文件种类的标志。File 命令来查看。 链接：目标文件本身还不能直接使用，无论是直接运行还是作为程序库文件使用都不可以。将目标文件转换为最终可以使用的形式的处理称为链接。使用程序库的情况下，在这个阶段处理程序的加载。通过链接生成的并不一定是可执行文件，也可以是程序库文件。 程序运行的全过程：代码的build-&gt;ELF-&gt;运行加载链接-&gt;进程—&gt;结束 运行环境：链接的话题并非仅出现在build过程。如果使用了共享库，那么在开始运行程序时链接才会发生。动态加载就是一种将所有链接处理放到程序于运行时进行的。 编程语言的运行方式:编译器会对程序进行编译，将其转换为可执行的文件（c/c++）；解释器不将程序转换为别的语言，而直接运行（python）；运行程序的方式不止一种，C语言也可以用解释器来运行，编程语言可以和运行方式自由搭配；编译器、解释器都统称为编程语言的处理器。 根据语言的特点：有静态类型检查，要求较高可靠性的情况下用编译方式；没有静态类型检查，对灵活性要求高于严密性的情况下，则使用解释方式。 静态类检查是指在程序开始运行之前，对函数的返回值以及参数进行检查的功能；在程序运行过程中随时进行类型检查的为动态类型检查。 静态指不运行程序而进行的处理；动态指一边运行程序一边进行某些处理。 狭义的编译过程:语法分析&gt;语义分析&gt;生成中间代码&gt;代码生成。 语法分析 :首先对代码进行解析，将其转化为计算机易于理解的形式，也就是语法树的形式。解析代码的程序模块称为解析器或者语法分析器 语义分析：通过解析语法获得语法树后，接着就要解析语法树，除去多余的内容、添加必要的信息；生成抽象的语法树。 语义分析包括： 区分变量为局部变量还是全局变量 解析变量的声明和引用。 变量和表达式的类型检查 检查引用变量之前是否进行了初始化。 检查函数是否按照定义返回了结果 语法分析只是对代码的表象进行分析；语义分析是对表象之外的部分级进行分析。语法分析生成的语法树只是将代码的构造照搬过来。而语义分析生成的抽象语法树还包含了语义信息。比如，在变量的引用和定义之间添加链接；适当的增加类型转换命令，是表达式的类型一致；另外语法树中的表达式外侧的括号行末的分号在抽象的语法树都将被省略。 生成中间代码：将抽象语法树转化为只在编译器内部使用的中间代码；之所以特地的转化为中间代码，主要是为了支持多种编程语言或机器语言； gcc 使用一种名为RTL(Register Transfer Language)的中间代码。解析代码转化为中间代码为止称为编译器的前端。 代码生成：吧中间代码转换为汇编语言，这个阶段为代码生成；负责代码生成的程序模块为代码生成器。 优化：各个环节都可执行优化 语法分析：词法分析 词法分析就是将代码分割为一个个的单词，也可以称为扫描。 在该过程中，会将空白字符和注释这种对程序没有实际意义的部分剔除。 正是因为预先有了词法分析，语法分析才可以只处理有意义的单词，进而实现简化处理。 负责词法分析的模块称为词法分析器，又称为扫描器。 Token：在编程语言系统中，将一个单词的字面和他的种类以及语义值统称为token。词法解析器的作用就是解析代码并生成token序列。 编程语言的编译器中的解析器的主要作用是解析有扫描器生成的token序列，并生成代码所对应的树形结构，即语法树。 语法树和语法是完全对应的，所以c语言的分号以及表达式的括号等都包含在真实的语法树中，但是，没有意义，因此，实际上大部分情况下会生成一开始就省略分号和括号的抽象语法树。也就是说解析器会跳过语法树，直接生成抽象语法树。 理想情况是将词法分析、语法分析、语义分析这三个阶段做成3个独立的模块，这样的代码是最优美的。但实际上，这三个阶段并不能明确的分割开来。 语法分析的两层含义：一、语法分析中词法分析以外的部分才称为语法分析。二、词法分析和语法分析合起来称为语法分析。 语法分析定义的分析语句的分析表达式的分析项的分析 语义分析变量引用的消解类型名称的消解类型定义的检查表达式有效性的检查静态类型的检查 计算机内部结构计算机的中心是总线（bus）。总线是传送数据的通信干线，它连接了计算机中的各个设备，使之通信，就像人类的血管或者神经系统。 CPU是负责运算的设备。 CPU内部有寄存器，寄存器大小有32位或64位，在cpu计算时，寄存器被用于临时存放数据。通常cpu先将数据从存储器读入寄存器，然后以寄存器为对象进行计算，再将结果写回存储器。将数据从存储器读入寄存器的操作称为加载将数据从寄存器写回存储器的操作称为写回 存储器是存储二进制数据的设备。 进程所使用的地址称为虚拟地址。 物理存储器的实际地址称为物理地址。 虚拟地址的整体范围称为程序的地址空间。 进程使用虚拟地址访问存储器，cpu内部称为MMU的设备会访问地址转换表进行地址转换。 CPU 386是x86系列的第一款32位cpu. Pentinum 4是intel的x86系列第一款64位cpu。 满足1.具备n位宽的通用寄存器 2.具备n位以上的地址空间。 才真正被称为n位cpu。 32位的cpu的通用寄存器的大小为32位，和指针大小相同，地址空间为无符号的32位整数可以指向的范围。64位一样。 X86系列的CPU只要使用PAE(physical address extension)这样的机制，32位的CPU也可以操作36位范围的地址空间 指令集不同的CPU都能够解释的机器语言体系称为指令集架构（ISA， instruction set architecture）,也可以简称指令集。Intel 将x86系列CPU之中的32位CPU的指令集架构称为IA—32.IA(iIntel Architecture). ELF文件的结构Linux使用ELF作为目标文件的格式。ELF格式被用于描述目标文件、可执行文件以及共享库的所有信息。无论什么场合，使用ELF格式的目的只有一个，那就是把机器代码以及其对应的元数据以方便的链接器和加载器处理的形式保存起来。代码的元数据包含如下的信息： 代码文件的大小以及转换前的源代码文件名。 符号符号指的是变量或者函数的名称。简单的情况下直接使用原编程语言中的函数名或者变量名即可。有时候也会根据不同的编程语言进行特定的变换后得到的符号名称。这种变换称为名称重整。比如c++里的重载。 重定位信息重定位信息用于表示在链接完成前无法确定内存地址的代码位置信息。比如，在共享库内的函数，那么在最终链接完成后才能确定的其内存地址。在这种情况下，目标文件中就会留有“代码中这个位置的内存引用尚未确定”这样的信息。这样的信息就是重定向信息。 调试信息 ELF的节和段ELF文件结构的二元结构。目的：为了兼顾链接器、汇编器等编译工具以及程序加载到内存中的加载器两者的易用性的需求。 二元结构:如果以程序头信息来处理，则ELF文件可以解释为段集合。如果以节头信息来处理，则可以解释成节集合。 节 ELF头 程序头（描述段） .text节 .rodata节 .data节 .got节 .symtab节 .strtab节 节头（描述节） 节（section）：是汇编器、链接器等处理ELF文件内容的单位。ELF文件把不同目的的代码、数据等分割成节保存。比如，机器码统一保存到.text节中。全局变量的初始化数据则保存在.data节中。 段（segment）：则是把程序加载到内存的加载器处理ELF文件时的单位。段由1个以上的字节构成。内存上不同范围有着“只读”、“可写”、“可执行”等不同的属性。因而需要根据属性进行分段。比如机器码如果不可执行就毫无意义，因此要统一到具有可执行属性段中。 目标文件的主要节 节名 内容 .text节 机器码。配置机器码的节，虽然叫text，但和文本文件没有关系。 .rodata节 读专用的.data。配置的字符串字面量等不能更新的数据 .data节 全局变量等。在文件中无大小信息。配置的是拥有初始值的全局变量等，这个节的数据在加载后有可能发生变更。 .bss 通用符号等。在文件中无大小信息。配置的是没有初始值的全局变量，并且加载到内存后，会被分配所有字节都初始化为0的内存空间。BSS是（Block Started by Symbol）。 .rel.text节 .text段中的符号的重定位信息 .symtab节 文件中包含的符号表。实际的字面量在.strtab节中保存 .strtab节 符号等字符串列表 .shstrtab 节名字符串列表 .line 代码和原始代码行号对照 .debug 调试用的符号信息 .fini 进程结束前执行的代码 .fini_array 进程结束前执行的函数的指针数组 .init 目标文件加载时执行的代码 .init_array 目标文件加载时执行的函数的指针数组 .note 用于保障兼容性等 Linux下的 binutils包中包含readelf命令可以输出elf文件的结构。 1． readelf –S hello #输出hello的节头信息。 2． readelf –l hello #查看hello的程序头。 3． readelf –s hello #输出符号表。 gcc gcc – c main.c //在编译后中断build. -o 指定输出文件名。 -v 详细输出其内部处理过程 Linux下负责链接的程序是/usr/bin/ld，这个程序称为GNU ld,一般称为链接器。 链接器可处理的文件： 文件类型 格式 后缀名 生成器 可重定位文件 ELF .o 汇编器 可执行文件 ELF 无 链接器 共享库 ELF .so 链接器 静态库 UNIX ar .a ar命令 可重定位文件指汇编器生成的目标文件(.o)。GNU as 生成的可重定位文件没有程序头，因此不能直接运行，只有配合链接器与其他可重定位文件、库产生连接后才可执行。 可执行文件指的是链接生成的用户可直接运行的目标文件。Linux下可执行文件没有后缀名 共享库是链接生成的另一种形式的目标文件，其中集合了各个函数、变量等供用户调用，因此需要能够再次和其他目标文件链接使用。共享库不会直接运行。共享库也叫动态链接库。Linux下的共享库文件名一般以lib开头，以.so作为后缀，并加上版本号。 静态库文件可以作为链接器的输入。和共享库文件一样，静态库文件也集合了各种函数、变量供其它用户使用。一般以lib开头，以.a作为后缀。静态库文件利用ar命令把多个可重定位文件打包成一个，因此链接静态库文件就相当于链接其中打包的所有可重定位文件。 什么是链接链接指的是把多个目标文件关联为一个整体。而通过关联多个目标文件，就可生成同时使用多个目标文件定义的变量、函数的程序。 具体步骤： 合并节 重定位 符号相消 此外，链接时还必须进行很多其他的处理。比如，在生成ELF文件时，需要为程序生成合适的程序头信息。不过归根到底，链接的主旨是关联目标文件，因此主要处理也就是上述三点。 合并节：在链接多个目标文件时，需要从各个目标文件中抽取节，把相同种类的节合并到一起。 重定位：指根据程序实际加载到内存时的地址，对目标文件中的代码和数据进行调整。在链接文件时，根据整体情况决定“真实的”内存地址，把所有用虚拟内存地址的地方替换成真实的内存地址。这个处理就是重定位。 符号相消指为了可以使用其他目标文件和库文件中提供的变量和函数，把尚未和实体链接的符号与具体的变量和函数等实体链接起来的操作。例如：mian.c中有printf函数，汇编器会把“这个目标文件中使用的printf函数的函数体在其他文件中”这个信息保留下来。这个信息就是未定义的符号。接下来，再进行链接操作的时候，再检索未定义的符号，把相关的变量或者函数的内存地址链接进来。这个处理就是符号消解。 符号相消和重定位联系紧密，比如上面的printf函数，编译mian.c时printf函数的地址是未知的，这时编译器为printf函数分配虚拟地址，并生成类似call printf的汇编指令，然后在链接时再把函数的内存地址修正为正确的地址。而这个“先设置虚拟地址，在链接时修正为正确的地址”的处理正是重定位操作，因此符号消解本身可以通过重定位来实现。总体来说，像上面这样解释目标文件代码的含义，把目标文件从物理上、逻辑上连接起来，从而生成可执行文件的处理就是“链接”。 动态链接和静态链接静态库在build，也就是执行ld命令的时候就会进行目标文件的链接， 而共享库在build的时候不会进行目标文件的链接，而只是检查共享库和符号是否存在，在程序运行时才在内存上实际链接目标文件。 其中，在build时链接目标文件的的链接操作称为静态链接。 而在程序执行时链接目标文件的链接操作则称为动态链接。 给链接器输入多个重定位文件时，这些文件被执行静态链接。 动态链接有容易更新、节省磁盘空间、节省内存的优点。Linux下也主要使用共享库和动态链接。gcc也是如此，不加任何选项的话执行的动态链接，而静态库的静态链接只在个别情况下使用。缺点：性能稍差、链接具有不确定性。 Eg: 动态链接： gcc –c main.c gcc –c f.c gcc main.o f.o –lc –o prog -l选项可以为链接指定库 Ldd prog //查看是否被动态链接。 静态链接： gcc –static main.o f.o –lc –o prog file prog 生成库 生成静态库 用ar生成静态库，和tar命令差不多 eg：$ ar crs libmy.a f.o g.o h.o 选项 含义 c 如果存档不存在，则创建 r 向存档添加文件 S 生成加速链接的索引 Linux下优化执行时共享库的检索速度，加载器会对共享库的信息建立缓存文件。这个缓存文件就是 /etc/ld.so.cache。安装新版本的共享库时，一定要更新这个缓存文件，更新缓存文件的需要以管理员的权限运行ldconfig命令。 gcc –c –fPIC f.c gcc –c –fPIC g.c gcc –share –WL, -soname, libfg.so.1 f.o g.o –o libfg.so.1 file libfg.so.1 加载程序利用mmap系统调用进行文件映射，把程序加载到内存中。所谓的映射，意思是可以通过读取内存直接获得文件的内容，也可以通过写内存对文件的内容进行修改 在linux下，通过使用Proc文件系统，就可以表示进程利用mmap系统调用把文件映射到内存的范围信息。例如，利用cat /proc/44337/maps就可以表示44437进程中文件映射的信息。通过readelf –l /tmp/showmap 可以输出程序头。里面有elf段和内存空间的对应关系。ELF文件中拥有实体的段都是通过mmap系统调用来加载的。不过进程的内存空间中也存在不和ELF文件对应的部分，比如，和.bss等节对应的空间、机器栈、堆。 动态链接的过程目标文件的种类不同，加载ELF文件的主体也不同。程序由系统内核加载，共享库由动态链接加载器加载。 动态链接加载器是指加载并链接动态链接的程序本身及其链接的共享库，设置程序运行状态的程序。Linux下常用的动态链接加载器是/lib/ld-linux.so.2。动态链接加载器的统称为ld.so。使用ELF文件的系统中，程序ELF文件的INTERP段需要指定动态链接加载器的路径。系统内核在启动程序时读入此段的内容，从而加载，启动程序。换句话说，动态链接器和动态链接加载器的运作过程并无二致。从ld.so链接程序到程序的执行完毕过程。 加载程序 启动ld.so 读入共享库 符号相消和重定位 初始化 跳转到程序入口 程序终止处理 首先系统内核加载程序和ld.so，准备好运行环境后交由ld.so处理。完成启动的ld.so根据系统内核传递的参数进行初始化。接着读取程序的DYNAMIC段，加载所有可执行文件链接的共享库。对已经加载的共享库也执行同样的处理，递归加载所有的共享库。一旦加载完所需要的库，马上消解所有程序和代码库中的符号，并重定位代码。这样就完成了启动程序的准备工作。在执行了各个文件的初始化代码后，跳转到程序的入口，这样就启动了程序。在C语言程序中，也就是执行了main函数的意思。程序执行完毕后，最后会对每个文件执行终止处理，这样整个执行过程最终完成。 反汇编指的是从机器码恢复到汇编代码的过程。Linux上使用binutils包的objdump命令就可以反汇编一个程序，eg: objdump –d hello C语言中设定程序是从main函数开始执行，但实际上程序最初是从_start函数开始执行的。_start函数由lib提供的/usr/lib/crtl.o文件定义，ctrl.o在这个文件在编译时是默认链接的。_start函数会初始化libc，之后调用mian函数。 执行终止处理，接下来从main函数返回，接着ld.so会执行终止处理代码。用于初始化的有.init节和.init_array节，相应的，终止处理有.fini节和.fini_array节。.fini节保存进程终止时的代码，而.fini_array则保存进程终止时执行的函数指针列表。程序执行完后，ld.so会调用exit系统调用终止进程。Exit系统调用和平时使用的exit函数不同。C语言调用exit系统调用时，调用的是_exit函数。_exit函数执行libc的终止处理代码（.fini节和.fini_array节）后，执行exit系统调用结束进程。而exit系统调用会跳过终止处理，立即结束进程。这就是ld.so所有处理过程。 动态加载指的是在程序运行时指定共享库名称进行加载的方法。动态加载经常被用于实现所谓的插件。Linux中使用dlopen()函数进行动态加载。动态链接的程序最初一定已经加载了ld.so。而程序启动后它依然保存在内存上。因此只需要调用内存中的ld.so的代码，就可以在程序开始执行之后也能进行动态链接处理。 地址无关代码指的是无论加载到那个地址，都不需要重定位也能运行的代码。共享库的代码一定要是地址无关的代码，这一点很重要共享库一定要设置为地址无关代码，是为了实现库共享。要实现地址无关的代码，必须改变两点：一是全局变量的访问，二是 外部函数的调用。 访问全局变量的代码一定要把绝对地址改为相对地址。可以使用全局偏移表（GOT）的结构。GOT是指向全局变量的指针数组，链接器为其申请内存空间，动态链接加载器初始化其内容。地址无关代码就是通过 从这个GOT中读取地址而做到地址无关的。 外部函数如何调用地址无关的代码。Linux下为了使函数调用地址独立，使用了一种可以称之为GOT的函数版的方法—过程链接表（PLT）。不过PLT一般比GOT的入口数多，因此会采取延迟初始化。也就是说，外部函数第一次调用该函数时，该函数才会被链接。 地址无关的可执行文件（PIE）。指的是使用地址无关代码的可执行文件。因为地址无关，所以可以被加载到任意地址。]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>LINUX</tag>
        <tag>X86</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员自我修养简记]]></title>
    <url>%2F2017%2F03%2F05%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E7%AE%80%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[计算机基础 对于系统程序开发者来说，计算机三个部件最为关键：CPU、内存、I/O控制芯片。 高速的北桥芯片：为了协调CPU、内存和高速的图形设备。此时慢速的I/O总线已经无法满足需求。 低速设备的南桥芯片：由于北桥芯片运行速度非常高，于是人们有设计了低速设备的南桥芯片，磁盘、usb、键盘、鼠标等设备都连接在南桥芯片上，由南桥芯片将他们汇总后链接到北桥上。 SMP(对称多处理器)多CPU的计算机；简单的来讲就是每个CPU在系统中所处的地位和发挥的功能是一样的，是相互对称的。使用场景：大型数据库、网络服务器上，他们要求同时处理大量的请求，而这些请求时相互独立的，所以多处理器就可以最大效能的发挥作用。多处理器最多的应用场合时这些商用的服务器和需要处理大量计算的环境。（CPU频率碰到了天花板4GHZ,才出现了SMP）. 多核处理器：实际上就是SMP的简化版。这是由于多处理器成本高，所以厂商将多个处理器“合并在一起打包出售”，这些被打包的处理器之间共享比较昂贵的缓存部件，只保留多个核心；并且以一个处理器的外包装进行出售，价格比单核处理器只贵一点。当然他们在缓存共享方面有细微的差别，但是从程序员的角度来看，他们的区别很小，逻辑上看他们是完全相同的。 系统软件：传统意义上一般将用于管理计算机本身的软件称为系统软件，以区别普通的应用程序。系统软件可以分为两块；一块是平台性的，比如，操作系统内核、驱动程序、运行库和数以千记得系统工具；另一块是用于程序开发的，比如，编译器、链接器、汇编器等开发工具和开发库。 计算机系统软件体系结构采用一种层的结构：计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。 接口：每个层次之间都必须要相互通信，则需要一个通信协议，我们一般将其称为接口。接口下面那层是提供者，上层是使用者。除了硬件和应用程序，其他层都是中间层，每个中间层都是对它下面的那层的包装与扩展。正是由于这些中间层的存在，使得应用程序和硬件之间保持相对独立。 在软件体系结构中：位于最高层的是应用程序。从整个层次结构上来看，开发工具与应用程序属于同一层，因为他们都使用同一接口，那就是操作系统应用程序编程接口。应用程序接口的提供者是运行库。运行库使用操作系统提供的系统调用接口，系统调用接口往往以软中断的方式提供；比如，linux使用0x80号中断作为系统调用接口。硬件规格: 操作系统内核层对于硬件层来说是硬件接口的使用者，而硬件是接口的定义者，硬件的接口的定义决定了操作系统的内核，具体来讲就是驱动程序如何操作硬件，如何与硬件通讯，这种接口被叫做硬件规格。 操作系统：一个功能是提供抽象的接口，另外一个主要功能就是管理硬件资源。 多道程序的设计：编写一个监控程序，当某个程序暂时无需使用CPU时，监控程序就把另外的正在等待CPU资源的程序启动起来，使得CPU能够充分利用起来，这种被称为多到程序。 分时系统：每个程序运行一段时间后都主动让出CPU给其他的程序，使得一段时间内每个程序都有机会运行一小段时间。 多任务系统：操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别，每个进程都有自己的独立空间，使得进程之间的地址相互隔离。CPU由操作系统同一分配，每个进程都会根据进程优先级的高低都有机会得到CPU.但是，如果运行超出了一定的时间，操作系统会暂停该进程，将CPU资源分配给其他的等待运行的进程，这种CPU分配方式为抢占式。 驱动程序可以看做事操作系统的一部分，它往往和系统内核一起运行在特权级别，但他与操作系统内核之间有一定的独立性，使得驱动程序有较好的灵活性。操作系统开发者为硬件生产商提供了一系列接口和框架，凡是按照这个接口和框架开发的驱动程序都可以在该操作系统上使用。 进程的总体目标是希望每个进程从逻辑上看都可以独占计算机的资源。操作系统的多任务功能使得CPU能够在多个进程之间共享；从进程的角度看好像是他独占了CPU而不用考虑与其他进程分享CPU的事。操作系统的I/O抽象模型也很好的实现I/O设备的共享和抽象。内存通过虚拟地址空间；分段分页来实现共享。 为什么要虚拟内存：如果程序直接在物理内存上使用，直接访问物理地址将带来很多问题： 地址空间不隔离：所有程序都访问物理地址，程序所使用的内存空间不相互隔离，恶意的程序可以很容易改写其他程序的内存数据，以达到破坏的目的。有些非恶意、但有臭虫的程序可能不小心修改ill其他程序的数据，就会使其他程序崩溃。而使用虚拟地址空间可保证一个任务的失败不影响其他任务的执行。 内存使用效率低：由于没有有效的内存管理机制，通常需要一个程序执行时，监控程序就将整个程序装载进内存然后执行。内存不够时会发生大量的数据交换，效率低下。 程序运行的地址不稳定：因为程序每次需要装入运行时，我们都需要给他从内存中分配一块足够大的内存空间区域，这个区域位置不确定；这给程序的编写造成一定的麻烦，因为程序在编写时，它访问的数据和指令跳转时的目标地址很多都市固定的，这涉及到重定位问题。 解决问题的思路就是增加中间层，即使用一种间接地址访问方法。我们把程序给出的地址看作是一种虚拟地址，然后通过某种映射，将虚拟地址转 换为物理地址。这样，只要我们能够妥善控制这个虚拟地址到物理地址的映射过程，就可以保证任意一个程序所能够访问的物理内存区域跟另一个程序相互不重叠，以达到地址空间隔离的效果。物理地址空间是真真实实存在的；虚拟地址空间是指虚拟的，而且每个进程只能访问自己的地址空间，这样就有效的做到了进程的隔离。 分段：解决了第一个和第三个问题。首先，它做到了地址的隔离，如果程序访问越界，将会被硬件判断为非法访问，拒绝这个地址请求，并将这个请求报告给操作系统或者监控程序。再者，对于每个程序员来说，无论他们被分配到物理地址的那个区域，对于程序来说都是透明的。他们不需要关心物理地址的变化。 但分段没有解决内存使用效率问题；分段对内存区域的映射还是按照程序为单位；如果内存不足，被换入换出到磁盘的都是整个程序，这样势必会造成大量的磁盘访问操作，从而严重影响速度。这种方法换是显得比较粗糙，粒度比较大。事实上，根据程序的局部性原理，当一个程序在运行时，在某个段内，它只是频繁的用到一小部分数据，也就是说，程序的很多数据其实在一段时间内都是不会被用到的。人们很自然的想到了更小粒度的内存分割和映射的方法，使得程序的局部性原理得到充分的利用，大大提高了内存使用率，这种方法就是分页。 分页：提高了内存的使用率，减少了内存碎片的产生；保护也是页映射的目的之一。简单来说就是每个页可以设置权限属性，只有操作系统有权限修改这些属性。MMU都集成在CPU的内部了，不会以独立的部件存在。 线程基础线程：有时被称为轻量级的进程（LWP）,是程序执行流的最小单位。一个标准的线程是由线程ID\当前指令指针（PC）、寄存器集合和堆栈组成。通常意义上，一个进程由一到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）以及一些进程级的资源（打开的文件和信号）。 使用多线程的原因： 某个操作可能会陷入长时间的等待，等待的线程会进入睡眠状态，无法继续执行，多线程执行可以有效的利用等待的时间。典型的例子是等待网络响应，这可能要花费数秒。 某个操作（计算）会消耗大量的时间，如果只有一个线程，程序和用户之间的交互会中断。多线程可以让一个线程负责交互，另一个线程负责计算。 程序本身就要求并发操作。、 多CPU或多核计算机，本身具备同时执行多个线程的能力，因此单个线程程序无法全面的发挥计算机的全部计算能力。 相对于多进程应用，多线程在数据共享方面效率要高得多。 线程的访问权限线程的访问非常自由，它可以访问进程内存空间内的所有数据，甚至包括其他线程的堆栈（如果他知道其他线程的堆栈地址，这是很少见的情况），但实际运用中线程也拥有自己的私有存储空间： 栈：尽管并非完全无法被其他线程访问，但一般情况下仍然可以认为是私有数据。 线程局部存储，是某些操作系统为线程单独提供的私有空间，但通常只具有很有限的容量。 寄存器：寄存器是执行流的基本数据，因此为线程私有。 从C程序员的角度看，数据在线程之间是否私有：私有：局部变量、函数参数、TLS线程局部存储数据 线程之间共享进程所有：全局变量、堆上的数据、函数里的静态变量、程序代码，任何程序都有权读取并执行任何代码、打开的文件。 线程调度：一个不断在处理器上切换不同线程的的行为。线程通常至少拥有三种状态：运行、就绪、等待。 IO密集型线程：频繁等待的线程；CPU密集型线程：很少等待的线程；IO密集型的线程总比cpu密集型的线程容易得到优先级的提升。 对于linux来说，线程并不是一个通用的概念；linux对多线程支持颇为贫乏；事实上，在linux内核中并不存在真正意义上的线程的概念。Linux将所有可执行的实体称为任务（TASK）,无论是进程换是线程。每一个任务概念上都类似于一个单进程的线程，具有内存空间、执行实体、文件资源。不过，linux下不同任务之间可以选择共享内存空间，因而在实际意义上，共享同一个内存空间的多个任务构成了一个进程，这些任务也就成为了这个进程里的线程。在linux下，用以下方法可以创建一个新的任务。 系统调用 作用 效果 fork 复制当前进程 新的任务启动并和本任务一起从fork返回，本任务返回的是新任务的pid,新任务返回0。Fork速度非常快，因为采用了写时复制。Fork只能产生本任务的镜像。 exec 使用新的可执行映像覆盖当前可执行映像 Fork+exec启动别的新任务。 Clone 创建子进程并从指定位置开始执行 产生新的线程使用clone。从指定的位置开始执行，并且（可选）共享当前的内存空间和文件等。如此就可以在实际效果上产生一个线程。 线程安全同步：为了避免多个线程同时读写同一个数据而产生不可预料的结果，我们需要将各个线程对同一个数据的访问同步。所谓的同步，既是指在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。如此，对数据的访问被原子化了。同步的方式： 锁、 二元信号量、（多元）信号量（对于允许多个线程并发访问的资源，它是一个很好的选择；一个初始值为n的信号量允许N个线程并发访问。） 互斥量：和二元信号量很类似，资源进同时只能被一个线程访问。不同的是，信号量在整个系统可以被任意线程获取并释放。而互斥量则要求那个线程获取了互斥量，那个线程就要负责释放这个锁。 临界区：是比互斥量更加严格的同步手段。把临界区的锁获取称为进入临界区，释放称为离开临界区。临界区和互斥量与信号量的区别在于，互斥量和信号量在系统的任何进程里都是可见的，也就是说，一个进程创建了一个互斥量或者信号量，另一个进程试图获取该锁是合法的。然而，临界区的作用范围仅限于本进程，其他进程无法获取该锁。除此之外，临界区胡互斥量具有相同的性质。 读写锁：适用于读频繁写少的情况。对于一段数据，多个线程同时读取总是没有问题的，写时必须上锁。 条件变量：作用类似一个栅栏。线程有两种操作，等待与唤醒。使用条件变量可以让许多线程一起等待某个事件的发生，当时间发生时，条件变量被唤醒，所有的线程可以一起恢复执行。 可重入与线程安全一个函数要被重入只有两种情况：一是多个线程同时执行这个函数；二是函数自身调用自身。一个函数被重入表示这个函数没有被执行完成，由于外部因素或者内部调用，又一次进入函数执行。一个函数可重入，表明函数重入后不会产生任何不良的后果。一个函数要成为可重入的，必须具有 如下几个特点： 不使用任何（局部）静态或全局的非const变量。 不返回任何（局部）静态或者全局的非const变量的指针。 仅依赖于调用方提供的参数。 不依赖任何单个资源的锁。 不调用任何可重入的函数。 可重入是并发的强力保障，一个可重入的函数可以在多线程环境下放心使用。 过度优化Volatile关键字:一是阻止编译器为了提高速度将一个变量缓存到寄存器中而不写回；二是阻止编译器调整volatile变量的指令顺序。Barrier：因为即使volatile可以阻止编译器调整顺序，也无法阻止CPU动态调度换序。现在并不存在可移植的阻止换序的方法。通常情况下是通过调用CPU提供的一条指令，这条指令被称为barrier。它可以阻止cpu将该指令之前的指令交换到它之后，反之亦然。Barrier指令的作用类似于一个拦水坝，阻止换序穿透这个大坝。 三种线程模型Windows和linux，都是在内核里提供线程的支持。内核线程，这里的内核线程和linux内核里的kernel_thread并不是一回事，它和我们之前讨论的一样，由多个处理器或调度器来实现并发。然而用户实际使用的的线程不是内核线程，而是存在于用户态的用户线程。用户线程并不一定在操作系统内核内对应着同样数量的内核线程。用户态多线程库的实现 一对一模型：用户线程具有和内核线程一致的优点，线程之间的并发，是真正的并发。一个线程阻塞，其他线程不会受到影响。一对一模型可以让多线程程序在多处理器的系统上有跟好的体现。一般直接使用API或系统调用创建的线程均为一对一的线程。 缺点：一是由于许多操作系统限制了内核线程的数量，因此一对一线程会让用户的线程数量受到限制。二是许多操作系统内核线程调度时，上下文切换开销大，导致用户线程的执行效率下降。 多对一模型：线程间的切换由用户态的代码来进行，线程切换的速度要快许多，但是一个用户线程阻塞，那么所有线程都将无法执行，因此此时内核里的线程也随之阻塞了。多对一模型的好处就是高效的上下文切换和几乎无限制的线程数量。 多对多模型：一个用户线程阻塞并不会使得所有用户线程阻塞，因为此时还有别的线程可以被调度来执行。另外，多对多模型对用户线程的数量没有什么限制，在多处理器上，线程也能得到一定性能的提升。]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>程序员自我修养</tag>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 基础常识]]></title>
    <url>%2F2017%2F03%2F05%2Flinux-%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%AF%86%2F</url>
    <content type="text"><![CDATA[概要 Linux可划分为：linux内核、GNU工具、图形化桌面环境、应用软件。 内核主要负责：系统内存管理、软件程序管理、硬件设备管理、文件系统管理。 交换空间：内核通过硬盘上的存储空间来实现虚拟内存的这块区域。 linux内核1.内存管理:分段分页 2.软件程序管理：内核控制着linux系统如何管理运行在系统上的所有进程。内核创建的第一个进程称为init进程，它是用来启动系统上所有其他进程的。当内核启动时，它会将init进程加载到虚拟内存中。内核在启动任何其他进程，都会在虚拟内存中给新进程分配一块专有的区域来存储该进程用到的数据和代码。 一些linux发行版使用一个表来管理在系统开机时要启动的进程。在linux上这个表通常位于专门文件/etc/inittab中。Ubuntu则采用/etc/init.d目录，将开机时启动或者停止某个应用脚本放在这个目录下。这个脚本通过/etc/rcX.d目录下的入口启动，这里X代表运行级别。Linux操作系统的init系统采用了运行级别。运行级别决定了init进程运行/etc/inittab文件或/etc/rcX.d目录中定义好的某些特定的进程。Linux操作系统有5个启动运行级别。 运行级别为一时，只启动基本的系统进程以及一个控制台终端进程，我们称之为单用户模式。单用户模式通常用来在系统有问题的时候进行紧急的文件系统维护。 标准的启动运行级别是3，在这个运行级别上，大多数应用软件，比如网络支持程序都会启动。运行级别5上系统启动图形化的X window系统，允许用户通过图形化桌面窗口登录系统。 硬件设备管理：任何linux系统需要与之通讯的设备，都需要在内核代码中加入其驱动程序代码。驱动程序代码相当于应用程序和硬件设备的中间人，允许内核与设备之间交互数据。在linux内核中有两种方法用于插入设备驱动的代码，第一，编译进内核的设备驱动代码，第二，可插入内核的设备驱动代码。Linux将硬件设备当成特殊的文件，称为设备文件。设备文件有：字符型设备文件、块设备文件、网络设备文件。 文件系统管理：linux内核支持不同类型的文件系统从硬盘中读取数据。 类型 描述 Ext Linux 扩展文件系统，最早的linux文件系统 Ext2 第二扩展文件系统，在ext的基础上提供了更多的功能。 Ext3 第三扩展文件系统，支持日志功能。 Ext4 第四扩展文件系统，支持高级日志功能。 Hpfs Os/2高性能文件系统。 Nfs 网络文件系统 Proc 访问系统信息 ReiserFS 高级linux文件系统，能够提供更好的性能和硬盘恢复功能 Linux内核采用虚拟文件系统（VFS）作为和每个文件系统交互的接口。这为linux内核同任何类型的文件系统通信提供了一个标准的接口。当每个文件系统都被挂载和使用的时候，VFS将信息都缓存在内存中。 GNU工具GNU(GNU‘s Not Unix 的缩写) linux 内核和GNU工具的结合成为linux 核心GNU工具：GNU项目的主旨在于为UNIX系统管理员设计出一套类似于UNIX的环境。这个目标促使该项目移植了很多常见的unix系统命令行工具。供linux系统使用的这组核心工具被称为coreutils(core utilities)软件包。它由三部分构成：处理文件的工具、操作文本的工具、管理进程的工具。 ShellGNU/Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在linux系统上的进程的途径。Shell的核心是命令提示符。命令提示符是设立负责交互的部分。它允许你输入文本命令，然后解释命令，并在内核中运行。 Shell包含一组内部命令，它也允许你输入程序的名称，将程序名称传递给内核以启动它。 所有linux发行版本默认的shell都是bash shell。Bash shell 由GNU项目开发，被当作标准的Unix shell(bourne shell以创建者命名)的替代品。Bash shell 的名字就是针对bourne shell 的拼写玩的一个文字游戏，称为bourne again shell。 shell 描述 Ash 一个运行在内存受限环境中简单的轻量级的shell，但和bash shell 完全兼容 Korn 一种与bourne shell 兼容的编程shell，但支持一些高级编程特性：关联数组和浮点运算 Tcsh 一种将C语言中的一些元素引入shell脚本中的shell。 Zsh 一种结合了bash tcsh korn 的特性，同时提供了高级编程特性，共享历史文件和主题的高级shell。 linux桌面环境 x window系统:它是直接和PC上的显示器以及显卡打交道的底层程序。它控制这linux程序如何在电脑上显示漂亮的窗口和图形。 KDE(K Desktop Enivironment): 它允许你把应用程序图标和文件图标放置在桌面上。单击应用程序图标，linux就会运行该应用程序。 GNOME（the GNU Network Object Model Environment, GNU网络对象模型环境），用的最多是Red Hat Linux. Unity桌面：ubuntu的桌面环境。目标为工作站、平板电脑以及移动设备提供一致的桌面体验。 Linux发行版通常分为三类： 完整的核心linux发行版 特定用途的发行版 LiveCD测试发行版 核心linux发行版含有内核、一个多个图形化桌面环境以编译好的几乎所有能见到的linux应用。它提供了一站式完整的安装。比较流行的版本有 发行版 描述 Debian 在linux专家和商用linux产品中流行的发行版。 OpenSUSE 用于商用和家用的发行版 Slackware 最早的linux发行版的一员，在linux极客中比较流行。 Red Hat 主要用于Internet服务器的商业发行版 Fedora 从RedHat分离出的家用发行版 Gentoo 为高级linux用户设计的发行版，仅包含Linux源码。 特殊用途的linux发行版：他们通常基于某个主流发行版，但仅包含主流发行版的一小部分用于某种特定用途的应用程序。定制化发行版还尝试通过自动检测和自动配置常见的硬件来帮助新手安装linux。 发行版 描述 Centos 基于Red Hat企业版linux源代码构建的免费发行版 Ubuntu 用于学校和家庭的免费发行版 PClinuxOS 用于家庭和办公 Mint 用于家庭娱乐]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 内存管理]]></title>
    <url>%2F2017%2F03%2F05%2Flinux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[CPU位数和操作系统位数的关系：操作系统的位数其实是说的CPU的位数。因为计算机的所有功能都是基于CPU的指令集，也就是说，操作系统的所有功能几乎都跟CPU指令集有关系，操作系统的所有功能都会被翻译成一组CPU指令集。64位CPU的指令集是64位的，要想使用64位的功能，那么操作系统也必须是64位的。比如操作系统里的寻址，数据的大小都可以为64位。当然，64位CPU也会保存32位指令集，所以也兼容32位操作系统。 现在来说CPU位数。众所周知，CPU里有8个通用寄存器，AX/BX/CX/DX/SI/DI/BP/SP，也就是说，由于64位CPU指令集会操作64位数据，如果寄存器是32位的，那么64位指令集便没有了可以运行的场所。所以，CPU位数说的是指令集的位数和通用寄存器的位数。 下面是两个参考网站位什么要分段分页？ http://www.2cto.com/os/201210/161572.htmlhttp://www.cppblog.com/sixinquan/archive/2012/07/19/184234.html 分段首先看一下分段的引入早期的8086处理器运算单元是16位的，也就是说，处理内存寻址的那部分指令集处理的也是16位的。而地址线是20位的。理论上，20位地址线寻址范围应该是1MB。但是由于指令集是16位的，所以也就不能直接使用这20位地址线。 解决方法有2种 一种是，给CPU指令集增加一部分20位的指令集用来处理内存寻址，但是这会CPU内部结构不均匀（坏处网上我没搜到，反正肯定不好。我猜应该是，如果当这20位的指令集需要和16位的指令集进行交互时，那么就需要某种方式的映射，这会增加CPU功耗或者是拖慢CPU的速度）。 另一种解决方法，CPU仍然使用16位指令集，增设一些16位的段寄存器。在把最终地址送上20位地址总线时，它会把某个段寄存器的16位放在地址总线的高16位，然后把指令集得到的16位地址放在低16位，那么相当于重叠了12位。但是，总能在20位的地址上模拟出1MB的访问空间。这就利用简单地加法模拟了一个映射，从而用16位的指令集使用了20位的地址线。这也就是为什么段的引入会加大寻址空间。 而80386CPU的指令集是32位，地址线也是32位，按理来说根本不需要分段来增大寻址空间。但是，80386到底是8086的一员，它还得兼容之前的实模式，所以，16位的段寄存器必须保存下来。既然已经不需要分段的空大空间能力，所以，inter处理器的开发商便基于16位寄存器开发出了保护模式。在保护模式下,它的段范围不再受限于64K，可以达到4G。这一下真正解放了软件工程师,他们不必再费尽心思去压缩程序规模，软件功能也因此迅速提升。 分段实现的功能： 扩大寻址空间。 实现保护模式 保护模式会实现怎样的功能？ 在保护模式下，一个地址空间是否可以被写入？可以被多少优先级的代码写入？是不是允许被执行等问题就显现出来了。例如，在还没有分页机制的时候，也就是没有多个进程利用多套虚拟地址空间使用同一个比如是4G的空间时，多个进程之间是如何共享内存的？如果没有保护，进程A访问了进程B的空间，并且修改了进程B的某个非常重要的参数，那么进程B可能会因此直接gg。程序员需要自己定义一个段，然后不允许其他进程访问。再例如，在面向对象的语言中，你可以把某个类的所有实例都写到一个段里，设置不是本类的成员方法不能对该段进行访问，这样就可以很好地管理一个类。说了半天，也就是，实现一套保护机制十分重要。那么到底是怎么实现的呢？（参考网址 http://www.techbulo.com/708.html） 保护模式的实现除了CS,SS,DS,ES,FS,GS这6个段寄存器，还用到了GDT表和LDT表以及跟这两个表对应的两个寄存器：GDTR，LDTR。 可能你现在想知道一个段的描述信息到底存放在哪，现在明确告诉你，对于某个段的描述信息来说，在内核中的某个线性地址，有一块连续内存，这块内存的起始地址可以由两个方法确定 段寄存器中的段选择子 + GDTR中的GDT的起始位置 = 一个段的描述信息的描述信息。 LDTR指向的内存地址。 LDT1和LDT2等就是一个段的描述信息。GTD中存放的就是一个段的描述信息的描述信息。GDTＲ中存放GDT的起始地址，ＬＤＴＲ中存放某个段描述信息的起始地址。段寄存器中存放GDT的索引。而某个段描述信息中就有这个段的起始地址，终止地址，访问权限等。保护机制大功告成。 但是linux并未使用如此细化的机制（参考网址：http://www.codesec.net/view/199560.html） 逻辑地址就是指令中的偏移量，程序使用的都是这个。本来在分段机制下，线性地址是逻辑地址加上由16位段寄存器和GDT找到段描述信息中段起始的值得来的。但linux内逻辑地址和线性地址是一样的，如何做到的呢？那就是，在linux下，使所有的段起始地址都为0，终止地址都为oxfffffff，也就是4GB。所以对于任何用户来说，用户代码段描述符和用户数据段描述符都是一样的，而当切换到内核态时，所有的内核代码段描述符和内核数据段描述符都是一样的。也就是说，所有进程的用户代码段都共享着一个段描述信息（由上面的方法找到），所有的用户数据段也都共享。内核的代码段和数据段也一样。 并且，只是通过段描述符中的DPL取值来进行权限管理。比如，内核代码段和数据段的DPL是0，那么就说明只有CPL为0时才能访问。而用户代码段和数据段的DPL为3。权限保护仅此而已，只是区分了内核态和用户态，并没有在多个进程之间进行保护。而进程之间更加细化的保护是页管理中进行的。 对分段分页的总结：http://blog.sina.com.cn/s/blog_5420e00001013b7o.html 这里有一个问题，分页既然能实现更细化的权限访问控制，那么就意味着分段的这点功能分页也完全能实现。那么为什么还非要强行使用分段，把逻辑地址转换为虚拟地址（线性地址），再使用分段，将虚拟地址再转换为物理地址？为什么不直接使用分页机制？ 因为linux是一个可以兼容多平台的操作系统。其中涉及到了对CPU的兼容。有些CPU，比如Intel的CPU，由于一是为了兼容其以前版本的CPU，二是由于分段存在了很长时间后才出现了分页，所以，CPU指令集中对寻址的指令会有这样一种逻辑：先分段，将逻辑转换为线性，再分页，将线性转换为物理。指令集使用的是逻辑地址，而Intel处理器对逻辑地址的定义是： 【段标识符：段内偏移量】， 也就是说，它硬性地规定了你的程序编译为二进制也就是机器语言后，必定是上面形式的逻辑地址，当程序运行后，它会把段内偏移量和由段标识符找到的段起始地址相加得到线性地址，然后放到地址总线上。也就是必须通过分段机制，才能得到线性地址，然后才能进行页映射。所以，linux为了兼容IntelCPU，也就必须使用分段机制。但是有些CPU，完全没有分段的概念，它的指令集里只有线性地址。那么这种矛盾怎么解决呢？linux巧妙地绕过了分段机制（让所有段起始地址为0，大小为4GB），而且还顺便利用了一下分段机制实现了用户和内核的分离（上面有讲）分页 分页管理分页管理其实比分段管理简单，要了解的概念也能少一点。首先，分页管理是将线性地址转换为物理地址。 上面分别是二级映射结构和四级映射结构的寻址方式。这里还是有多个硬件平台需要的映射结构不同。比如i386处理器支持二级映射方式，而有些CPU则需要三级甚至是四级。linux为了兼容各种平台，统一使用四级页表。具体二级和四级是怎么管理的. 参考：http://blog.sina.com.cn/s/blog_5420e00001013b7o.html CPU将线性地址放到地址总线上，但不是直接使用这个线性地址操作内存，它会先经过MMU。ＣＲ３寄存器存放了页目录的起始地址，ＭＭＵ根据页目录的信息，将收到的线性地址转换为物理地址，再放到地址总线上，进行读写内存操作。 分页实现的更细化的保护： 使用页表本身进行越界保护。每个进程只能映射到自己的物理内存。 在页表项中设置存取控制位。 在页表项中设置访问级别。 分页的好处：实现了虚拟存储器，可以更高效地管理内存。 虚拟存储器技术根据程序的局部性原理: 时间局部性：由于迭代循环等的存在，在ＣＰＵ访问后的单元在不久之后任然会受到多次循环访问。 空间局部性：对进程的某一空间的表或者对战数据进行集中访问。 顺序局部性：对于程序代码的执行，是顺序执行。即便使用了跳转指令跳转到另外一块程序，那么它任然会在跳转到的那块程序顺序访问。 也就是说，在某一时间内，程序只会被访问到一部分，那么只需要把这部分装入内存就行了，其他的可以先暂时在磁盘上存放。 虚拟存储技术需要考虑的点： 调入策略：请求页式管理 预调入 分配策略：分配空闲内存 置换策略：随机淘汰，轮询，先进先出，最近少用 抖动问题：由于设计问题，给一个进程在内存中分配的页面非常少，内存页面经常出现不足，就需要换出某些页。而如果置换算法设计的方法或者流程不好，则可能刚换出的页马上又要用到，频繁地进行这样的操作，使ＣＰＵ在整个时间片中大部分时间用在了页面换出换入上。这宗现象成为抖动。 消除方法： 根据实际情况，设计出一个合理的工作集。 挂起某些进程。 缺页频度法：根据缺页发生的频率动态地更改给进程分配的空间。]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 进程与线程]]></title>
    <url>%2F2017%2F03%2F05%2Flinux-%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[什么是进程？ 进程是资源分配和和独立运行的单位； 进程是操作系统中可执行程序的一次执行，换句话说进程就是拥有资源（cpu,内存，磁盘，进程ID，文件描述符，虚拟地址空间，端口号等）的程序；它是动态的； 一个进程是由程序控制块（pcb也就是task_struct结构体）,代码和数据组成；其中进程控制块是描述进程的资源和运行状态等；它有内核来管理； 在linux中可以通过ps，pstree来查看当前系统中的进程； 什么是线程？ 线程属于轻量级进程，一个进程可以拥有多个线程；linux下线程就是轻量级进程，所以线程的概念和进程是大同小异的。只不过是共享了大部分资源的进程罢了。 线程是进程的一个执行流，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程是进程中的最小调度单位； 用户线程指的是完全建立在用户空间的线程库，用户线程的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。因此这种线程的操作是极其快速的且低消耗的。 用户态线程和内核态线程；主要的区分就是“谁来管理”线程，用户态是用户管理，内核态是内核管理（但肯定要提供一些API，例如创建）。 线程的模型有哪些 n : 1 多个线程对应一个核心线程(进程); 线程的创建和销毁以及管理全部在用户层的线程库中实现，在内核层完全不知情，内核层看到的只是一个个进程。所以内核会以进程为单位调度任务运行。 1：1 一个线程对应核心线程(进程); 在1:1模式下，线程的创建，调度，销毁全由内核完成，而其他操作则由线程库完成。 m ：n ： 结合上面两种方式，如某些进程一一对应核内线程，其他线程完全在用户态实现。 linux是如何管理进程的？ 每个进程在linux内核拥有一个task_struct结构体（进程控制块的具体定义），里面包含了进程几乎所有的信息。在linux下，所谓的进程管理，就是反复操纵task_struct结构体的过程一点也不为过。 操作系统对进程的所有管理都是围绕task_struct结构体为中心构建的。 例如，给某个进程发送kill信息，操作系统就会根据task_struct结构体中的信息释放进程所占用的内存，信号量，打开文件相关的资源等等，然后当进程被切换出去时释放task_struct结构体，至此，系统再没有保存该进程的任意一点信息，标志着进程的死亡。 再例如，进程的调度，由于每个进程都有其自己的上下文环境，或者说是当前系统状态的总和。被切换出去进程的这种系统状态需要保存到task_struct结构体中，以便下次恢复。而被切换进来的进程的上下文环境从哪里来呢？显而易见，在这个被调度进来的进程在真正运行之前，调度程序会从该进程的task_struct结构体中找到之前保存的上下文环境，然后将系统恢复到之前保存的状态，被调度进来的程序才真正开始运行。 进程的创建过程： 操作系统给新进程分配一个全局唯一的pid号; 并在内核空间中创建和分配诸如task_struct结构体，kernel堆栈等必要的数据结构和物理资源。 然后复制父进程的与信号有关，与文件系统有关的运行环境。最后还会给task_struct结构体某些变量赋值，将来使用这些变量来将新进程运行的某些环境（如kernel栈的起始地址，EAX的初值等）设置为子进程自己独有的运行环境。并加入运行队列中，之后就是调度程序的事了。 这个过程中涉及到了写时拷贝技术。在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。 写时拷贝技术: http://blog.sina.cn/dpool/blog/s/blog_96757e4b01011b1n.html?vt=4 在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。 这就是分配内存的拖延战术，直到不得不做。操作系统中与此类似思想的还有页高速缓存器（page cache）。也就是，当有程序试图将数据写入文件的时候，linux操作系统并不会马上将数据写入disk中，而是将它们临时放在memory的一块区域。这块区域就叫做page cache。只有在关闭文件或者关机时，才有内核线程将page cache中的数据刷到磁盘中。这也就是非正常退出时，数据会损坏的原因。 在Linux中主要提供了fork、vfork、clone三个进程创建方法。 以下总结来源:http://www.360doc.com/content/14/1231/11/14530056_437075775.shtml 在linux源码中这三个调用的执行过程是执行fork(),vfork(),clone()时，通过一个系统调用表映射到sys_fork(),sys_vfork(),sys_clone(),再在这三个函数中去调用do_fork()去做具体的创建进程工作。 fork创建一个进程时，子进程只是完全复制父进程的资源，复制出来的子进程有自己的task_struct结构和pid,但却复制父进程其它所有的资源。这样看来，fork是一个开销十分大的系统调用，这些开销并不是所有的情况下都是必须的，比如某进程fork出一个子进程后，其子进程仅仅是为了调用exec执行另一个可执行文件，那么在fork过程中对于虚存空间的复制将是一个多余的过程。但由于现在Linux中是采取了copy-on-write(COW写时复制)技术，为了降低开销，fork最初并不会真的产生两个不同的拷贝，因为在那个时候，大量的数据其实完全是一样的。写时复制是在推迟真正的数据拷贝。所以有了写时复制后呢，vfork其实现意义就不大了。 vfork系统调用不同于fork，用vfork创建的子进程与父进程共享地址空间，也就是说子进程完全运行在父进程的地址空间上，如果这时子进程修改了某个变量，这将影响到父进程。但此处有一点要注意的是用vfork()创建的子进程必须显示调用exit()来结束，否则子进程将不能结束，而fork()则不存在这个情况。用 vfork创建子进程后，父进程会被阻塞直到子进程调用exec(exec，将一个新的可执行文件载入到地址空间并执行之。)或exit。vfork的好处是在子进程被创建后往往仅仅是为了调用exec执行另一个程序，因为它就不会对父进程的地址空间有任何引用，所以对地址空间的复制是多余的 ，因此通过vfork共享内存可以减少不必要的开销。 clone :系统调用fork()和vfork()是无参数的，而clone()则带有参数。fork()是全部复制，vfork()是共享内存，而clone() 是则可以将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些资源给子进程，由参数列表中的 clone_flags来决定。另外，clone()返回的是子进程的pid。所以，这个就和上面说的轻量级进程联系起来，也可以这样说，linux通过clone调用生成线程。 fork，vfork，clone的区别 fork出来的子进程是父进程的一个拷贝，即，子进程从父进程得到了数据段和堆栈段的拷贝，这些需要分配新的内存；而对于只读的代码段，通常使用共享内存的方式访问；而vfork则是子进程与父进程共享内存空间, 子进程对虚拟地址空间任何数据的修改同样为父进程所见；clone则由用户通过参clone_flags 的设置来决定哪些资源共享，哪些资源拷贝。 fork不对父子进程的执行次序进行任何限制，fork返回后，子进程和父进程都从调用fork函数的下一条语句开始行，但父子进程运行顺序是不定的，它取决于内核的调度算法；而在vfork调用中，子进程先运行，父进程挂起，直到子进程调用了exec或exit之后，父子进程的执行次序才不再有限制；clone中由标志CLONE_VFORK来决定子进程在执行时父进程是阻塞还是运行，若没有设置该标志，则父子进程同时运行，设置了该标志，则父进程挂起，直到子进程结束为止。他们成功执行时，父进程中返回子进程的进程号，在子进程中返回0。 进程的调度主要结构就是运行队列(双向循环链表)。为什么会有运行队列的存在呢?当Linux内核要寻找一个新的进程在CPU上运行时，必须只考虑处于可运行状态的进程，（即在TASK_RUNNING状态的进程），因为扫描整个进程链表是相当低效的，所以引入了可运行状态进程的双向循环链表，也叫运行队列（runqueue）。运行队列容纳了系统中所有可以运行的进程，它是一个双向循环队列。 也就是说，为了实现进程的调度，内核维护了一个叫做运行队列的数据结构。在这个数据结构中，active，expired，arrays是主要的三个结构。目前，咱们几个了解这三个就足够了。arrays也就是一个拥有两个成员的数组，每个数组有140个双向链表（也就是说，所有的就绪进程，按照时间片是否用完分成两个部分），对应了0~139 的140个优先级。active和expired分别指向arrays的两个成员。进程调度时，从active指针选择下一个要运行的程序。active中时间片用完的进程会被移动到expired队列，并且时间片会被重新计算，若active队列再无成员，则两个指针指向互换。 linux进程主要分为 实时进程（例如键盘中输入字母或者鼠标点击之类的） 和 交互式进程与批处理进程（例如word程序，你总是写一会停一会）。内核不会动态调整前者的优先级，如需调整，则需要调用特殊的系统调用。而且，前者的优先级别最高。只有没有实时进程的时候，交互式或者批处理才会被调度执行。而后者的优先级会被内核动态调整。 进程有哪些调度策略？这时候你分开说。对于实时进程，一般采用的是FIFO或者RR（轮询）机制。而对于交互式或者批处理进程，则采用动态调整优先级加运行队列机制来执行调度。这里有个大原则，如果有实时进程，那么交互式或者批处理则不会被执行。这个从进程优先级就可以看出来：实时（0~99），交互式批处理（100~139）。这时，你还可以举个例子。比如，你正在复制100文件，文件是一个一个被复制的，当复制到第50个的时候，你点了一下停止符号，它不会说是继续第51个文件的复制，而是直接停止。说明你鼠标的点击被插入到第51个文件之前了。所以实时进程永远比后者优先级高。 进程会在什么时候被调度?调度一般在进程退出内核态时，因为这时进程已经释放了可能导致内核死锁的资源。除了时间片用完触发调度，内核线程会在执行一些比较费时的任务时，自己调用调度函数，使其他进程有机会执行。 首先进程调度不应该产生内核死锁之类的问题。如果进程在内核态，则它可能会占有产生死锁的资源（比如，进程想要操纵硬件必须使用系统调用。想想这样一种情况：用户想要使用打印机这种独占资源，内核线程，也就是代表用户进程在内核状态执行的那个线程，它一定改变了代表打印机的结构的某个标志位，或者持有打印机结构体内的自旋锁，互斥锁之类的资源，标志着打印机正在被使用，本来打算在返回用户态时释放这种互斥锁资源，但调度函数来了，我不管，我就要让你现在退出。然后该进程带着互斥锁退出。当下一个进程进来，也要使用打印机，这时，该进程向内核申请打印机，而内核却发现打印机正在被使用，所以内核等待打印机退出，而持有互斥锁的进程已经被内核踢出cpu了，谈何释放？所以这时，所有的进程都在等，被调度进来进程陷入内核出不来了,整条逻辑陷入了无限循环，如果是单核，那么死锁便产生了）。 关于僵尸进程僵尸进程指的是那些虽然已经终止的进程，但仍然保留一些信息，等待其父进程为其收尸。 生的原因：父进程调用fork创建子进程后，子进程运行直至其终止，它立即从内存中移除，但进程描述符仍然保留在内存中（进程描述符占有极少的内存空间）。子进程的状态变成EXIT_ZOMBIE，并且向父进程发送SIGCHLD 信号，父进程此时应该调用 wait() 系 统调用来获取子进程的退出状态以及其它的信息。在 wait 调用之后，僵尸进程就完全从内存中移除。因此一个僵尸存在于其终止到父进程调用 wait 等函数这个时间的间隙，一般很快就消失，但如果编程不合理，父进程从不调用 wait 等系统调用来收集僵尸进程，那么这些进程会一直存在内存中。比如父进程死了，或者父进程忽略了SIGCHLD信号，或者父进程对SIGCHLD信号定义的信号处理函数有误。 如何避免：不能使用 kill 后接 SIGKILL 信号这样的命令像杀死普通进程一样杀死僵尸进程，因为僵尸进程是已经死掉的进程，它不能再接收任何信号。事实上，如果系统中僵尸进程并不多的话，我们也无需去消除它们，少数的僵尸进程并不会对系统的性能有什么影响。 那么在编程时，如果能避免系统中大量产生僵尸进程呢？根据上面描述的，子进程在终止时会向父进程发 SIGCHLD 信号，Linux 默认是忽略该信号的，我们可以显示安装该信号，在信号处理函数中调用 wait 等函数来为其收尸，这样就能避免僵尸进程长期存在于系统中了。以上都是复制下面这个链接的， http://www.cnblogs.com/hazir/p/zombie_process.html 危害： 僵尸进程的pid不会释放，意味着如果有海量的僵尸进程，则会占满进程表项，是的后续进程无法执行fork（） 内核栈无法释放，这个资源是很珍贵的。根本原因在于，task_stauct结构体没有释放。]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>线程</tag>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 文件系统]]></title>
    <url>%2F2017%2F03%2F05%2Flinux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[文件系统概念：是操作系统的一部分，用来管理磁盘空间，向外提供操纵接口。比如fread，fwrite，fopen等系统调用就是文件系统提供的功能。 作用：管理用户的逻辑文件，替用户保存逻辑文件到存储块的映射。并提供缓存机制，做到存取速度快，存储空间利用率高，数据安全性好。 NFS（Network File System）即网络文件系统NTFS (New Technology File System)FAT是文件配置表（英语：File Allocation Table，首字母缩略字：FAT）EXT4是第四代扩展文件系统（英语：Fourth extended filesystem，缩写为 ext4） 文件系统中存储的最小单位是块（Block）Ext2文件系统将整个分区划成若干个同样大小的块组（Block Group），如图1所示，每个块组都由以下部分组成： 1. Super Block（超级块）描述整个分区的文件系统信息，例如块大小、文件系统版本号、上次mount的时间等等。超级块在每个块组的开头都有一份拷贝。 先介绍几个结构体： file结构体：存在于task_struct的 文件描述符表 的每个元素指向的内存中。fd为文件描述符表的索引。文件描述符表 是个指针数组，每个元素指向一个file结构体。 文件结构体代表一个打开的文件，系统中的每个打开的文件在内核空间都有一个关联的 struct file。它由内核在打开文件时创建，并传递给在文件上进行操作的任何函数。在文件的所有实例都关闭后，内核释放这个数据结构。并且一个文件即使是在一个进程中多次打开，也会存在多个file结构。（http://blog.sina.com.cn/s/blog_7943319e01018m3w.html） 为什么要设置file结构体？ 因为linux下，文件是共享的。意味着多个进程对这个文件的读写有着不同的偏移量。首先文件偏移量不能放在inode，因为多个进程可能会共享一个inode。所以只能创建一个中间结构struct file 来保存文件偏移量。即使是这样，父进程和子进程还是有这方面问题的矛盾。因为子进程会继承父进程打开的文件，也就是说，子进程的文件描述符表和父进程的文件描述符表指向的是同一组file结构（仅仅增加了file结构体中的引用计数）。所以，子进程对文件偏移量的操作必然会影响到父进程。所以，一般在父进程和子进程之间需要同步机制或者在父子进程中分别关闭不用的文件，以免互相影响。(详细见http://woshiniezhenhua.blog.163.com/blog/static/191376928201291344920408/ http://www.tuicool.com/articles/I3AZF3）几个比较重要的元素： f_flag：文件标志， O_RDONLY, O_NONBLOCK, 和 O_SYNC. 驱动应当检查O_NONBLOCK 标志来看是否是请求非阻塞操作。 f_count：引用计数 f_pos：文件偏移量 f_dentry：关联到文件的目录入口( dentry )结构. 设备驱动编写者正常地不需要关心 dentry 结构, 除了作为 filp-&gt;f_dentry-&gt;d_inode 存取 inode 结构. 说道这里，文件是怎么共享的？ 静态共享和动态共享静态共享分为硬链接和软链接。 二者的区别是，硬链接修改文件目录项，把两个不同名的文件的inode指针指向同一个inode。而软链接则是使用另外一个独立的文件，只不过文件内容是需要指向文件的路径名。然后使用某个系统调用，利用路径名打开指向的文件，实现共享。 硬链接的优点是简单，但是不能跨越文件系统。 软链接的优点是可以跨越文件系统，但是要占用额外的空间和inode，而且容易形成死链的情况。 最重要的是，无论是硬链接还是软连接，都属于静态链接，他们最终映射到同一个inode，但是两个进程持有不同的file结构，也就是说，静态链接不能实现共享偏移量。动态共享 为什么会出现动态共享，是为了解决上面说的不能共享读写偏移量的问题。现实生活中，有两种需求。一种是需要共享读写指针，另一种是不需要共享。为了实现前者，linux系统提出了系统打开文件表的概念。主要是将一些需要被共享的file结构体统一放在系统打开文件表中。如果两个进程希望共享文件读写指针，则使二者的文件描述符表指向系统打开文件表中的同一个file结构体。而如果不需要共享，则指向不同的系统打开文件表即可。 dentry结构体，只需要知道其中有指向inode的指针即可 open函数的执行过程（http://blog.chinaunix.net/uid-25968088-id-3426026.html）（1）task_sruct中保存有该进程可以使用的但是未使用的文件描述符，先通过某个函数获取一个文件描述符。（2）在task_struct的文件描述符表中文件描述符对应的位置初始化一个file指针，并分配一个全新的file结构体。（3）利用传入的参数查找或者建立dentry，并绑定inode，至此，file结构的初始化到此为止。（4）建立fd与file结构的关系，返回fd、网络教程： 找到一个本进程没有使用的文件描述符fd（int型） 分配一个全新的struct file结构体 根据传人的pathname查找或建立对应的dentry 建立fd到这个struct file结构体的联系 read函数的执行过程（http://blog.csdn.net/lwj103862095/article/details/38518069） 图1显示了 read 系统调用在核心空间中所要经历的层次模型。从图中看出：对于磁盘的一次读请求，首先经过虚拟文件系统层（vfs layer），其次是具体的文件系统层（例如 ext2），接下来是 cache 层（page cache 层）、通用块层（generic block layer）、IO 调度层（I/O scheduler layer）、块设备驱动层（block device driver layer），最后是物理块设备层（block device layer） 虚拟文件系统层的作用：屏蔽下层具体文件系统操作的差异，为上层的操作提供一个统一的接口。正是因为有了这个层次，所以可以把设备抽象成文件，使得操作设备就像操作文件一样简单。 在具体的文件系统层中，不同的文件系统（例如 ext2 和 NTFS）具体的操作过程也是不同的。每种文件系统定义了自己的操作集合。关于文件系统的更多内容，请参见参考资料。 引入 cache 层的目的是为了提高 linux 操作系统对磁盘访问的性能。 Cache 层在内存中缓存了磁盘上的部分数据。当数据的请求到达时，如果在 cache 中存在该数据且是最新的，则直接将数据传递给用户程序，免除了对底层磁盘的操作，提高了性能。 通用块层的主要工作是：接收上层发出的磁盘请求，并最终发出 IO 请求。该层隐藏了底层硬件块设备的特性，为块设备提供了一个通用的抽象视图。 IO 调度层的功能：接收通用块层发出的 IO 请求，缓存请求并试图合并相邻的请求（如果这两个请求的数据在磁盘上是相邻的）。并根据设置好的调度算法，回调驱动层提供的请求处理函数，以处理具体的 IO 请求。 驱动层中的驱动程序对应具体的物理块设备。它从上层中取出 IO 请求，并根据该 IO 请求中指定的信息，通过向具体块设备的设备控制器发送命令的方式，来操纵设备传输数据。 设备层中都是具体的物理设备。定义了操作具体设备的规范。 相关的内核数据结构： Dentry ： 联系了文件名和文件的 i 节点 inode ： 文件 i 节点，保存文件标识、权限和内容等信息 file ： 保存文件的相关信息和各种操作文件的函数指针集合 file_operations ：操作文件的函数接口集合 address_space ：描述文件的 page cache 结构以及相关信息，并包含有操作 page cache 的函数指针集合 address_space_operations ：操作 page cache 的函数接口集合 bio ： IO 请求的描述 图5显示了一个文件的 page cache 结构。文件被分割为一个个以 page 大小为单元的数据块,这些数据块（页）被组织成一个多叉树（称为 radix 树）。此树的层次可以从0层到6层，所支持的文件大小从0字节到16 T 个字节。树的根节点指针可以从和文件相关的 address_space 对象（该对象保存在和文件关联的 inode 对象中）中取得 （1）产生系统调用，in0x80，根据中断号，在中断向量表中找到read函数的入口地址，将cpu执行权给read系统调用。（2）read通过传入的fd，取出file结构体中的文件偏移量，并通过dentry找到inode结构。（3）inode中存放着该文件对应的page cache的结构以及相关信息，并且有一组操纵page cache结构的函数指针。read在真正向底层发送读取信息之前，会先操纵page cache 来查看其中有没有需要读取的页。如果有，有专门函数讲page chache 中的数据拷贝到用户空间，read调用链到此结束。如果没有，lock计算出的页，则向下层发送添页请求，当再次lock成功时，说明数据已经在page cache 中了，拷贝到用户空间，结束。 文件操作的一般步骤： 根据路径名找到对应的dentry结构，并绑定inode。 根据dentry找到inode 根据inode中的某个数组获得对应文件的信息存放在哪些数据块上。 调用文件系统函数向更下一层发送命令，从而从磁盘读取数据。page cache机制： linux访问文件的方式分为直接IO和非直接IO两大类。其中，非直接IO就会用到page cache。上层程序写的数据先写到page cache，再有内核线程定期刷到磁盘。用户程序需要读的数据，先读到page cache，再从page cache拷贝到用户空间。 ext2文件系统ext2文件系统会将磁盘空间格式化为几个部分，分别保存 MBR ：MBR的作用是把操作系统自己的引导程序读入内存并跳转到操作系统的引导程序。本身与任何操作系统无关。MBR前446字节是主引导记录，后64字节是分区表。最后2个字节是结束标志。（具体我讲） inode信息 真正的数据 但是如果一个文件系统容量很大，那么将所有的inode和block都放在一起管理很不明智的。所以便有了块组的概念。 超级块描述了整个文件系统的信息，比如大小，inode/block的总数,已使用数量和剩余数量，其他文件系统的信息。block块组描述符则也类似，描述了一个块组的信息，例如在这个块组中从哪里开始是inode表，从哪里开始是数据块，空闲的inode和数据块还有多少个等等。块描述符和超级块一样，在每个块组开头都有一份拷贝，系统一般只使用到第0组的拷贝。一个块组中的所有inode组成了一个inode表。这里还有块位图，inode位图的概念。 lvm磁盘组织结构图]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ 类的四大函数]]></title>
    <url>%2F2017%2F03%2F05%2Fc-%E7%B1%BB%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[类与对象 类是用户自定义的一种数据类型，定义类时描述它可以提供的信息及能够执行的操作；即类是一种具有属性和行为的自定义的数据类型； 对象就是封装了数据结构，及施加这些数据结构上的操作的封装体； 类与对象的关系：类之于对象如同类型之于变量，因此类只是描述了数据格式和方法，而对象则是根据规范创建的实体；换句话说类就像图纸，而对象则是根据图纸盖起的大楼。 类与结构体的区别唯一的区别在于struct的默认访问权限是public,而类是private; C++中的类所占内存分析： 类所占内存的大小是由成员变量（静态变量除外）决定的，成员函数（这是笼统的说，后面会细说）是不计算在内的。成员函数还是以一般的函数一样的存在。a.fun()是通过fun(a.this)来调用的。 所谓成员函数只是在名义上是类里的。其实成员函数的大小不在类的对象里面，同一个类的多个对象共享函数代码。而我们访问类的成员函数是通过类里面的一个指针实现，而这个指针指向的是一个table， table里面记录的各个成员函数的地址（当然不同的编译可能略有不同的实现）。所以我们访问成员函数是间接获得地址的。所以这样也就增加了一定的时间开销，这也就是为什么我们提倡把一些简短的，调用频率高的函数声明为inline形式（内联函数）。 总结：空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。 类内部的成员变量： 普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。 static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。 类内部的成员函数： 普通函数：不占用内存。 虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的。 C++类中的四大函数：构造函数、拷贝构造函数、析构函数和赋值函数: 四个函数一般系统都会默认。但是往往系统默认的并不是我们所期望的，为此我们有必要自己编写符合要求的函数，参看String.cpp; 把对象的初始化工作放在构造函数中，当对象被创建时，构造函数被自动执行。 把清除工作放在析构函数中。当对象消亡时，析构函数被自动执行，把一切内存垃圾清理，可见他的重要。如果没有析构函数或析构函数不正确就会发生内存泄露等问题，后果非常危险 每个类只有一个析构函数和一个赋值函数，但可以有多个构造函数（包含一个拷贝构造函数，其它的称为普通构造函数）。 构造函数和赋值函数有着很大的区别，构造函数是在对象创建时调用的；而赋值函数使对象已经创建好了存在之后再赋值时调用的。有时候我们懒得写赋值函数和拷贝构造函数，又不允许别人使用编译器生成的缺省函数，那么我们可以只需将拷贝构造函数和赋值函数声明为私有函数，函数体为空即可； 使用对象前正确初始化 并不是所有的编译器都对象对象的内置类型成员会被自动初始化为0。永远在使用对象之前先将它初始化。确保每一个构造函数都将对象的每一个成员初始化。 别把赋值错当成初始化。C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前（对于内置类型对象可能不确定），这点对于非内置类型对象来说尤其关键。如果你没有在成员初始化列表（member initialization list）为其初始化，它们将调用自己的默认构造函数，然后才进入构造函数内部（很可能你会在这里给他们赋值）。在成员初始化列表中的初始化只是调用了拷贝构造函数一次，而在构造函数内部再为其赋值则在调用默认构造函数后又调用了一次拷贝构造函数。因此初始化列表将更为高效 所以，请用成员初始化列表进行初始化，虽然效率提高只针对于非内置类型成员，但是规定总是在初值列中列出所有成员变量，这样就省的有些未被列出的内置类型成员被忘记初始化。而有些时候，即使成员变量是内置类型，也必须要用成员初始化列表（成员变量为const或者reference，它们一定要有初值，而且不能被赋值）。 构造函数 使用构造函数的原因：由于类的封装性,不能象普通变量一样初始化 构造函数的作用：是在对象被创建时使用特定的值构造对象，或者说将对象初始化为一个特定的状态。 调用时刻：在对象创建时由系统自动调用。如果程序中未声明，则系统自动产生出一个缺省形式的构造函数 条件约束：允许为内联函数、重载函数、带缺省形参值的函数；但不允许是虚函数因为在刚开始对象还未被创建，内部什么都没有，更不用说虚表，虚表指针。因此无法调用虚函数。 拷贝构造函数（是一种特殊的构造函数，其形参为本类的对象引用）。 作用：使用一个对象（参数指定的对象），去初始化一个正在被建立的同类型对象（如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个拷贝构造函数。） 调用时刻： 当用类的一个对象去初始化该类的另一个对象时系统自动调用它实现拷贝赋值。 若函数的形参为类对象，调用函数时，实参赋值给形参，系统自动调用拷贝构造函数。 当函数的返回值是类对象时，系统自动调用拷贝构造函数。析构函数作用：完成对象被删除前的一些清理工作。调用时刻：在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间。如果程序中未声明析构函数，编译器将自动产生一个缺省的析构函数。 注意事项： 析构函数也不被继承，派生类自行声明。 声明方法与一般（无继承关系时）类的析构函数相同。 不需要显式地调用基类的析构函数，系统会自动隐式调用。 析构函数的调用次序与构造函数相反。 类组合的构造函数调用 构造函数调用顺序：先调用内嵌对象的构造函数（按内嵌时的声明顺序，先声明者先构造）。然后调用本类的构造函数。（析构函数的调用顺序相反） 若调用缺省构造函数（即无形参的），则内嵌对象的初始化也将调用相应的缺省构造函数。 多继承且有内嵌对象时的构造函数调用次序 调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。 调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序。 静态数据成员在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。 使用静态数据成员可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。 静态数据成员的使用方法和注意事项如下： 静态数据成员在定义或说明时前面加关键字static。 静态成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式如下： &lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt; 这表明： 初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆。 初始化时不加该成员的访问权限控制符private，public等。 初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员。 静态数据成员是静态存储的，它是静态生存期，必须对它进行初始化。 引用静态数据成员时，采用如下格式：&lt;类名&gt;::&lt;静态成员名&gt; 静态成员函数 静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。 在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。如果静态成员函数中要引用非静态成员时，可通过对象来引用。 调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;); 类外代码可以使用类名和作用域操作符来调用静态成员函数。 静态成员函数只能引用属于该类的静态数据成员或静态成员函数。 Inline函数C++ inline函数 ： inline int min(int first, int secend) {/****/}; inline函数对编译器而言必须是可见的，以便它能够在调用点内展开该函数。与非inline函数不同的是，inline函数必须在调用该函数的每个文本文件中定义。 关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。（所以说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。） 慎用内联：内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联： 如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。 内联函数和#define 宏的区别：内联函数总是对参数只精确地进行一次求值，从而避免了那声名狼藉的宏错误。换句话说，调用内联函数和调用正规函数是等价的，差别仅仅是更快 常函数的调用是这样的：常量对象只能调用常成员函数，非常量对象即可以调常成员函数，也可以调一般成员函数，但当某个函数有const和非const两个版本时，const对象调const版本，非const对象调非const版本。 二义性的问题 在多继承时，基类与派生类之间，或基类之间出现同名成员时，将出现访问时的二义性（不确定性）——采用虚函数（第8章）或支配（同名覆盖）原则来解决。 当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性——采用虚基类来解决。 虚基类引入 用于有共同基类的场合声明 以virtual修饰说明基类 例：class B1:virtual public B 作用： 主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题. 为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝 注意： 在第一级继承时就要将共同基类设计为虚基类。 虚基类及其派生类构造函数 建立对象时所指定的类称为最（远）派生类。 虚基类的成员是由最派生类的构造函数通过调用虚基类的构造函数进行初始化的。 在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中给出对虚基类的构造函数的调用。如果未列出，则表示调用该虚基类的缺省构造函数。 在建立对象时，只有最派生类的构造函数调用虚基类的构造函数，该派生类的其它基类对虚基类构造函数的调用被忽略。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>类</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ 继承]]></title>
    <url>%2F2017%2F03%2F05%2Fc-%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承与派生： 保持已有类的特性而构造新类的过程称为继承。 在已有类的基础上新增自己的特性而产生新类的过程称为派生。 继承的目的：实现代码重用。 派生的目的：当新的问题出现，原有程序无法解决（或不能完全解决）时，需要对原有程序进行改造。 三种继承方式 公有继承；私有继承；保护继承不同继承方式的影响主要体现在: 派生类成员对基类成员的访问控制。 派生类对象对基类成员的访问控制。 1.公有继承： 继承方式：基类的public和protected成员的访问属性在派生类中保持不变，但基类的private成员不可访问。 类内： 派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。 类外：通过派生类的对象只能访问基类的public成员。 2.私有继承： 继承方式：基类的public和protected成员都以private身份出现在派生类中，但基类的private成员不可访问。 类内：派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。 类外：通过派生类的对象不能访问基类中的任何成员。 3.保护继承： 继承方式：基类的public和protected成员都以protected身份出现在派生类中，但基类的private成员不可访问。 类内：派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。 类外：通过派生类的对象不能访问基类中的任何成员 4.protected 成员的特点与作用： 对建立其所在类对象的模块来说（水平访问时），它与 private 成员的性质相同。 对于其派生类来说（垂直访问时），它与 public 成员的性质相同。 . 既实现了数据隐藏，又方便继承，实现代码重用； 基类与派生类的对应关系 单继承: 派生类只从一个基类派生。 多继承：派生类从多个基类派生。 多重派生: 由一个基类派生出多个不同的派生类。 多层派生: 派生类又作为基类，继续派生新的类。 继承时的构造函数 基类的构造函数不被继承，需要在派生类中自行声明。 声明构造函数时，只需要对本类中新增成员进行初始化，对继承来的基类成员的初始化由基类完成。 多重继承构造函数的调用次序 调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。 调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序。 派生类的构造函数体中的内容。 多重继承时的析构函数 析构函数也不被继承，派生类自行声明。 声明方法与一般（无继承关系时）类的析构函数相同。 不需要显式地调用基类的析构函数，系统会自动隐式调用。 析构函数的调用次序与构造函数相反。 二义性问题 在多继承时，基类与派生类之间，或基类之间出现同名成员时，将出现访问时的二义性（不确定性）——采用虚函数或支配（同名覆盖）原则来解决。 当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性——采用虚基类来解决。（菱形继承） 虚基类声明: 以virtual修饰说明基类 例：class B1:virtual public B 作用： 主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题. 为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝 注意：在第一级继承时就要将共同基类设计为虚基类。 赋值兼容原则一个公有派生类的对象在使用上可以被当作基类的对象，反之则禁止。具体表现在： 派生类的对象可以被赋值给基类对象。 派生类的对象可以初始化基类的引用。 指向基类的指针也可以指向派生类。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>继承</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ 多态]]></title>
    <url>%2F2017%2F03%2F05%2Fc-%E7%9A%84%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[C和C++的区别： C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制）。C的优势在于编写的程序更接近于硬件，仅次于汇编语言，所以他相对其他编程语言高效的多，但同时程序员负责一切不安全，如内存泄露等。但正是由于这样的风险的存在，对程序员的紧密思维要求更高。 C++是有C，面向对象，泛型编程，stl组成。用面向对象来编程首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。 所以C与C++的最大区别在于它们的用于解决问题的思想方法不一样。之所以说C++比C更先进，是因为“ 设计这个概念已经被融入到C++之中 ”。 面向对象的三大特性：封装，继承，多态 封装：将对象的属性和方法封装在对象内部，形成一个个独立的单元模块，对外通访问权限控制管理对象数据的交互。(访问权限：（private，protected,public) 保证封装性的关键)目的：增强代码的安全性和简化编程，让使用者不必了解类具体的实现细节，只要通过外部接口，以特定的权限来使用类的方法即可。 继承：一个对象获得另一对象的特性的过程。是将一群类组织起来，定义了父子关系，实现了代码的重用，父类定义了所有子类的的共有借口和私有实现，同时子类都可以增加或覆盖继承来的东西，以实现独有的行为。 多态：它是建立在了继承的基础上；简单来说，就是一个接口，多个方法.具体来说：它是指不同子类在继承父类后分别覆盖了父类的方法多态性使得同一属性或者行为在基类及其子类间有不同的语义；多态性丰富了对象的内容，增强了软件的灵活性和可重用性；C++的多态性有两种：编译时的多态（函数重载），运行时多态（虚函数）（联编（binding)或称为绑定:是指计算机程序自身彼此关联的过程联编工作在编译连接阶段完成的情况称为：静态联编联编在程序运行阶段完成的情况称为：动态联编。） c++ 重载 覆盖 隐藏的区别和执行方式 : 成员函数被重载的特征:相同的范围（在同一个类中）；函数名字相同；参数不同； virtual 关键字可有可无。 覆盖是指派生类函数覆盖基类函数，特征是:不同的范围（分别位于派生类与基类）； 函数名字相同； 参数相同； 基类函数必须有virtual 关键字。 “隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下:如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆） 3种情况怎么执行：重载：看参数;隐藏：用什么就调用什么;覆盖：调用派生类; 虚函数的工作原理：编译器处理虚函数的方法是.给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。而这个数组称为虚函数表，虚函数表中存储了为类对象进行声明的虚函数的地址。 单继承时 虚函数指针在对象的最前面的位置； 虚函数地址按照声明的顺序存放于虚表中； 父类虚函数地址在子类虚函数地址的前面； 子类如果覆盖父类的虚函数，则被放到虚表中原父类虚函数的位置 没有被覆盖的函数依旧在原位。 多重继承的特殊地方： 每个父类都有自己的虚表时，子类的虚函数成员只被放到第一个父类中。 子类有多个虚表指针，位于类的最前面，分别指向不同的父类的虚表，（按继承的顺序）。 如果有覆盖情况，则替换所有被覆盖的父类虚函数地址。 父类访问子类中成员函数只能通过虚函数，覆盖的方法。否则无法访问。但我们可以通过函数指针强行访问虚表里的函数。本人就是通过此方法的出的以上结论。 虚函数特性： 虚函数是动态联编的基础。 是非静态的成员函数。 在类的声明中，在函数原型之前写virtual。 virtual 只用来说明类声明中的原型，不能用在函数实现时。 具有继承性，基类中声明了虚函数，派生类中无论是否说明，同原型函数都自动为虚函数。 本质：不是重载声明而是覆盖。 调用方式：通过基类指针或引用，执行时会根据指针指向的对象的类，决定调用哪个函数。 虚函数的限制 只有类的成员函数才能说明为虚函数，因为虚函数仅适用于继承关系的 类对象，所以普通函数不能说明为虚函数。 内联函数不能是虚函数，因为内联函数是在编译时决 定其位置。 构造函数不能是虚函数，因为构造时对象还是一片未 定型的空间，就没有虚指针，虚表。。 析构函数可以是虚函数，而且通常声明为虚函数。纯虚函数与抽象类 带有纯虚函数的类称为抽象类: 1class 类名 &#123; virtual 类型 函数名(参数表)=0; //纯虚函 ... &#125;; 作用： 抽象类为抽象和设计的目的而建立，将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为。 对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现。主要作用是通过它为一个类族建立一个公共的接口，使它们能够更有效地发挥多态特性。 注意：抽象类只能作为基类来使用;不能声明抽象类的对象;但可以声明一个指针]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>多态</tag>
        <tag>面向对象</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++ 模板]]></title>
    <url>%2F2017%2F03%2F05%2Fc-%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[模板是C++支持参数化多态的工具，使用模板可以使用户为类或者函数声明一种一般模式，使得类中的某些数据成员或者成员函数的参数、返回值取得任意类型。 模板是一种对类型进行参数化的工具；通常有两种形式：函数模板和类模板；函数模板针对仅参数类型不同的函数；类模板针对仅数据成员和成员函数类型不同的类。 使用模板的目的：就是能够让程序员编写与类型无关的代码。 注意：模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。 1.函数模板定义格式:template &lt;class 形参名，class 形参名，......&gt; 返回类型 函数名(参数列表) { 函数体 } 模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。 2.函数模板 函数模板可以用来创建一个通用功能的函数，以支持多种不同形参，进一步简化重载函数的函数体设计。 函数模板提供一个种用来自动生成各种类型函数实例的算法，程序员对于函数接口参数和返回类型中的全部或者部分类型进行参数化(parameterize)，而函数体保持不变。 注意：模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。 注意：对于函数模板而言不存在 h(int,int) 这样的调用，不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行，即只能进行 h(2,3) 这样的调用，或者int a, b; h(a,b) 函数模板实例化 函数模板只是声明了一个函数的描述即模板，不是一个可以直接执行的函数，只有根据实际情况用实参的数据类型代替类型参数标识符之后，才能产生真正的函数。 函数模板的数据类型参数标识符实际上是一个类型形参，在使用函数模板时，要将这个形参实例化为确定的数据类型。将类型形参实例化的参数称为模板实参，用模板实参实例化的函数称为模板函数。模板函数的生成就是将函数模板的类型形参实例化的过程。 函数模板在它被调用或取其地址时被实例化 模板函数类似于重载函数，但两者有很大区别：函数重载时，每个函数体内可以执行不同的动作，但同一个函数模板实例化后的模板函数都必须执行相同的动作 3.函数模板与同名的非模板函数重载时，应遵循下列调用原则： 寻找一个参数完全匹配的函数，若找到就调用它。若参数完全匹配的函数多于一个，则这个调用是一个错误的调用。 寻找一个函数模板，若找到就将其实例化生成一个匹配的模板函数并调用它。 若上面两条都失败，则使用函数重载的方法，通过类型转换产生参数匹配，若找到就调用它。 若上面三条都失败，还没有找都匹配的函数，则这个调用是一个错误的调用 4.类模板定义：template&lt;class 形参名，class 形参名，…&gt; class 类名 {... }; 类模板和函数模板都是以template开始后接模板形参列表组成，模板形参不能为空，一但声明了类模板就可以用类模板的形参名声明类中的成员变量和成员函数，即可以在类中使用内置类型的地方都可以使用模板形参名来声明。比如: template&lt;class T&gt; class A{public: T a; T b; T hy(T c, T &amp;d);}; 5.类模板对象的创建： 比如一个模板类A，则使用类模板创建对象的方法为A m;在类A后面跟上一个&lt;&gt;尖括号并在里面填上相应的类型，这样的话类A中凡是用到模板形参的地方都会被int 所代替。当类模板有两个模板形参时创建对象的方法为A m;类型之间用逗号隔开。 对于类模板，模板形参的类型必须在类名后的尖括号中明确指定。比如A m;用这种方法把模板形参设置为int是错误的（编译错误：error C2079: ‘a’ uses undefined class ‘A‘），类模板形参不存在实参推演的问题。也就是说不能把整型值2推演为int 型传递给模板形参。要把类模板形参调置为int 型必须这样指定A m。 6.在类模板外部定义成员函数的方法为：template&lt;模板形参列表&gt; 函数返回类型 类名&lt;模板形参名&gt;::函数名(参数列表){函数体}； 比如有两个模板形参T1，T2的类A中含有一个void h()函数，则定义该函数的语法为： template&lt;class T1,class T2&gt; void A&lt;T1,T2&gt;::h(){}。 注意：当在类外面定义类的成员时template后面的模板形参应与要定义的类的模板形参一致。 7.模板的实例化：类模板在引用实际模板类类型时实例化 定义模板类对象时 通过类指针或引用指向一个类模板实例时，只有当检查这个指针或引用指的那个对象时(访问数据成员或成员函数)，才会实例化 当类模板被实例化时，类模板的成员函数并不自动被实例化。只有该函数被调用或取地址时，才被实例化。 静态数据成员只有被使用时才实例化。 8.类模板和函数模板区别 函数模板允许重载 ，而类模板不允许重载(类无重载概念，即不存在同名类模板)。 类模板可以进行全特化和偏特化，而函数模板仅能够全特化 。 类模板支持默认参数，函数模板不支持]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F02%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
