<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[程序员自我修养简记]]></title>
      <url>%2F2017%2F03%2F05%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E7%AE%80%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[计算机基础 对于系统程序开发者来说，计算机三个部件最为关键：CPU、内存、I/O控制芯片。 高速的北桥芯片：为了协调CPU、内存和高速的图形设备。此时慢速的I/O总线已经无法满足需求。 低速设备的南桥芯片：由于北桥芯片运行速度非常高，于是人们有设计了低速设备的南桥芯片，磁盘、usb、键盘、鼠标等设备都连接在南桥芯片上，由南桥芯片将他们汇总后链接到北桥上。 SMP(对称多处理器)多CPU的计算机；简单的来讲就是每个CPU在系统中所处的地位和发挥的功能是一样的，是相互对称的。使用场景：大型数据库、网络服务器上，他们要求同时处理大量的请求，而这些请求时相互独立的，所以多处理器就可以最大效能的发挥作用。多处理器最多的应用场合时这些商用的服务器和需要处理大量计算的环境。（CPU频率碰到了天花板4GHZ,才出现了SMP）. 多核处理器：实际上就是SMP的简化版。这是由于多处理器成本高，所以厂商将多个处理器“合并在一起打包出售”，这些被打包的处理器之间共享比较昂贵的缓存部件，只保留多个核心；并且以一个处理器的外包装进行出售，价格比单核处理器只贵一点。当然他们在缓存共享方面有细微的差别，但是从程序员的角度来看，他们的区别很小，逻辑上看他们是完全相同的。 系统软件：传统意义上一般将用于管理计算机本身的软件称为系统软件，以区别普通的应用程序。系统软件可以分为两块；一块是平台性的，比如，操作系统内核、驱动程序、运行库和数以千记得系统工具；另一块是用于程序开发的，比如，编译器、链接器、汇编器等开发工具和开发库。 计算机系统软件体系结构采用一种层的结构：计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。 接口：每个层次之间都必须要相互通信，则需要一个通信协议，我们一般将其称为接口。接口下面那层是提供者，上层是使用者。除了硬件和应用程序，其他层都是中间层，每个中间层都是对它下面的那层的包装与扩展。正是由于这些中间层的存在，使得应用程序和硬件之间保持相对独立。 在软件体系结构中：位于最高层的是应用程序。从整个层次结构上来看，开发工具与应用程序属于同一层，因为他们都使用同一接口，那就是操作系统应用程序编程接口。应用程序接口的提供者是运行库。运行库使用操作系统提供的系统调用接口，系统调用接口往往以软中断的方式提供；比如，linux使用0x80号中断作为系统调用接口。硬件规格: 操作系统内核层对于硬件层来说是硬件接口的使用者，而硬件是接口的定义者，硬件的接口的定义决定了操作系统的内核，具体来讲就是驱动程序如何操作硬件，如何与硬件通讯，这种接口被叫做硬件规格。 操作系统：一个功能是提供抽象的接口，另外一个主要功能就是管理硬件资源。 多道程序的设计：编写一个监控程序，当某个程序暂时无需使用CPU时，监控程序就把另外的正在等待CPU资源的程序启动起来，使得CPU能够充分利用起来，这种被称为多到程序。 分时系统：每个程序运行一段时间后都主动让出CPU给其他的程序，使得一段时间内每个程序都有机会运行一小段时间。 多任务系统：操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别，每个进程都有自己的独立空间，使得进程之间的地址相互隔离。CPU由操作系统同一分配，每个进程都会根据进程优先级的高低都有机会得到CPU.但是，如果运行超出了一定的时间，操作系统会暂停该进程，将CPU资源分配给其他的等待运行的进程，这种CPU分配方式为抢占式。 驱动程序可以看做事操作系统的一部分，它往往和系统内核一起运行在特权级别，但他与操作系统内核之间有一定的独立性，使得驱动程序有较好的灵活性。操作系统开发者为硬件生产商提供了一系列接口和框架，凡是按照这个接口和框架开发的驱动程序都可以在该操作系统上使用。 进程的总体目标是希望每个进程从逻辑上看都可以独占计算机的资源。操作系统的多任务功能使得CPU能够在多个进程之间共享；从进程的角度看好像是他独占了CPU而不用考虑与其他进程分享CPU的事。操作系统的I/O抽象模型也很好的实现I/O设备的共享和抽象。内存通过虚拟地址空间；分段分页来实现共享。 为什么要虚拟内存：如果程序直接在物理内存上使用，直接访问物理地址将带来很多问题： 地址空间不隔离：所有程序都访问物理地址，程序所使用的内存空间不相互隔离，恶意的程序可以很容易改写其他程序的内存数据，以达到破坏的目的。有些非恶意、但有臭虫的程序可能不小心修改ill其他程序的数据，就会使其他程序崩溃。而使用虚拟地址空间可保证一个任务的失败不影响其他任务的执行。 内存使用效率低：由于没有有效的内存管理机制，通常需要一个程序执行时，监控程序就将整个程序装载进内存然后执行。内存不够时会发生大量的数据交换，效率低下。 程序运行的地址不稳定：因为程序每次需要装入运行时，我们都需要给他从内存中分配一块足够大的内存空间区域，这个区域位置不确定；这给程序的编写造成一定的麻烦，因为程序在编写时，它访问的数据和指令跳转时的目标地址很多都市固定的，这涉及到重定位问题。 解决问题的思路就是增加中间层，即使用一种间接地址访问方法。我们把程序给出的地址看作是一种虚拟地址，然后通过某种映射，将虚拟地址转 换为物理地址。这样，只要我们能够妥善控制这个虚拟地址到物理地址的映射过程，就可以保证任意一个程序所能够访问的物理内存区域跟另一个程序相互不重叠，以达到地址空间隔离的效果。物理地址空间是真真实实存在的；虚拟地址空间是指虚拟的，而且每个进程只能访问自己的地址空间，这样就有效的做到了进程的隔离。 分段：解决了第一个和第三个问题。首先，它做到了地址的隔离，如果程序访问越界，将会被硬件判断为非法访问，拒绝这个地址请求，并将这个请求报告给操作系统或者监控程序。再者，对于每个程序员来说，无论他们被分配到物理地址的那个区域，对于程序来说都是透明的。他们不需要关心物理地址的变化。 但分段没有解决内存使用效率问题；分段对内存区域的映射还是按照程序为单位；如果内存不足，被换入换出到磁盘的都是整个程序，这样势必会造成大量的磁盘访问操作，从而严重影响速度。这种方法换是显得比较粗糙，粒度比较大。事实上，根据程序的局部性原理，当一个程序在运行时，在某个段内，它只是频繁的用到一小部分数据，也就是说，程序的很多数据其实在一段时间内都是不会被用到的。人们很自然的想到了更小粒度的内存分割和映射的方法，使得程序的局部性原理得到充分的利用，大大提高了内存使用率，这种方法就是分页。 分页：提高了内存的使用率，减少了内存碎片的产生；保护也是页映射的目的之一。简单来说就是每个页可以设置权限属性，只有操作系统有权限修改这些属性。MMU都集成在CPU的内部了，不会以独立的部件存在。 线程基础线程：有时被称为轻量级的进程（LWP）,是程序执行流的最小单位。一个标准的线程是由线程ID\当前指令指针（PC）、寄存器集合和堆栈组成。通常意义上，一个进程由一到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）以及一些进程级的资源（打开的文件和信号）。 使用多线程的原因： 某个操作可能会陷入长时间的等待，等待的线程会进入睡眠状态，无法继续执行，多线程执行可以有效的利用等待的时间。典型的例子是等待网络响应，这可能要花费数秒。 某个操作（计算）会消耗大量的时间，如果只有一个线程，程序和用户之间的交互会中断。多线程可以让一个线程负责交互，另一个线程负责计算。 程序本身就要求并发操作。、 多CPU或多核计算机，本身具备同时执行多个线程的能力，因此单个线程程序无法全面的发挥计算机的全部计算能力。 相对于多进程应用，多线程在数据共享方面效率要高得多。 线程的访问权限线程的访问非常自由，它可以访问进程内存空间内的所有数据，甚至包括其他线程的堆栈（如果他知道其他线程的堆栈地址，这是很少见的情况），但实际运用中线程也拥有自己的私有存储空间： 栈：尽管并非完全无法被其他线程访问，但一般情况下仍然可以认为是私有数据。 线程局部存储，是某些操作系统为线程单独提供的私有空间，但通常只具有很有限的容量。 寄存器：寄存器是执行流的基本数据，因此为线程私有。 从C程序员的角度看，数据在线程之间是否私有：私有：局部变量、函数参数、TLS线程局部存储数据 线程之间共享进程所有：全局变量、堆上的数据、函数里的静态变量、程序代码，任何程序都有权读取并执行任何代码、打开的文件。 线程调度：一个不断在处理器上切换不同线程的的行为。线程通常至少拥有三种状态：运行、就绪、等待。 IO密集型线程：频繁等待的线程；CPU密集型线程：很少等待的线程；IO密集型的线程总比cpu密集型的线程容易得到优先级的提升。 对于linux来说，线程并不是一个通用的概念；linux对多线程支持颇为贫乏；事实上，在linux内核中并不存在真正意义上的线程的概念。Linux将所有可执行的实体称为任务（TASK）,无论是进程换是线程。每一个任务概念上都类似于一个单进程的线程，具有内存空间、执行实体、文件资源。不过，linux下不同任务之间可以选择共享内存空间，因而在实际意义上，共享同一个内存空间的多个任务构成了一个进程，这些任务也就成为了这个进程里的线程。在linux下，用以下方法可以创建一个新的任务。 系统调用 作用 效果 fork 复制当前进程 新的任务启动并和本任务一起从fork返回，本任务返回的是新任务的pid,新任务返回0。Fork速度非常快，因为采用了写时复制。Fork只能产生本任务的镜像。 exec 使用新的可执行映像覆盖当前可执行映像 Fork+exec启动别的新任务。 Clone 创建子进程并从指定位置开始执行 产生新的线程使用clone。从指定的位置开始执行，并且（可选）共享当前的内存空间和文件等。如此就可以在实际效果上产生一个线程。 线程安全同步：为了避免多个线程同时读写同一个数据而产生不可预料的结果，我们需要将各个线程对同一个数据的访问同步。所谓的同步，既是指在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。如此，对数据的访问被原子化了。同步的方式： 锁、 二元信号量、（多元）信号量（对于允许多个线程并发访问的资源，它是一个很好的选择；一个初始值为n的信号量允许N个线程并发访问。） 互斥量：和二元信号量很类似，资源进同时只能被一个线程访问。不同的是，信号量在整个系统可以被任意线程获取并释放。而互斥量则要求那个线程获取了互斥量，那个线程就要负责释放这个锁。 临界区：是比互斥量更加严格的同步手段。把临界区的锁获取称为进入临界区，释放称为离开临界区。临界区和互斥量与信号量的区别在于，互斥量和信号量在系统的任何进程里都是可见的，也就是说，一个进程创建了一个互斥量或者信号量，另一个进程试图获取该锁是合法的。然而，临界区的作用范围仅限于本进程，其他进程无法获取该锁。除此之外，临界区胡互斥量具有相同的性质。 读写锁：适用于读频繁写少的情况。对于一段数据，多个线程同时读取总是没有问题的，写时必须上锁。 条件变量：作用类似一个栅栏。线程有两种操作，等待与唤醒。使用条件变量可以让许多线程一起等待某个事件的发生，当时间发生时，条件变量被唤醒，所有的线程可以一起恢复执行。 可重入与线程安全一个函数要被重入只有两种情况：一是多个线程同时执行这个函数；二是函数自身调用自身。一个函数被重入表示这个函数没有被执行完成，由于外部因素或者内部调用，又一次进入函数执行。一个函数可重入，表明函数重入后不会产生任何不良的后果。一个函数要成为可重入的，必须具有 如下几个特点： 不使用任何（局部）静态或全局的非const变量。 不返回任何（局部）静态或者全局的非const变量的指针。 仅依赖于调用方提供的参数。 不依赖任何单个资源的锁。 不调用任何可重入的函数。 可重入是并发的强力保障，一个可重入的函数可以在多线程环境下放心使用。 过度优化Volatile关键字:一是阻止编译器为了提高速度将一个变量缓存到寄存器中而不写回；二是阻止编译器调整volatile变量的指令顺序。Barrier：因为即使volatile可以阻止编译器调整顺序，也无法阻止CPU动态调度换序。现在并不存在可移植的阻止换序的方法。通常情况下是通过调用CPU提供的一条指令，这条指令被称为barrier。它可以阻止cpu将该指令之前的指令交换到它之后，反之亦然。Barrier指令的作用类似于一个拦水坝，阻止换序穿透这个大坝。 三种线程模型Windows和linux，都是在内核里提供线程的支持。内核线程，这里的内核线程和linux内核里的kernel_thread并不是一回事，它和我们之前讨论的一样，由多个处理器或调度器来实现并发。然而用户实际使用的的线程不是内核线程，而是存在于用户态的用户线程。用户线程并不一定在操作系统内核内对应着同样数量的内核线程。用户态多线程库的实现 一对一模型：用户线程具有和内核线程一致的优点，线程之间的并发，是真正的并发。一个线程阻塞，其他线程不会受到影响。一对一模型可以让多线程程序在多处理器的系统上有跟好的体现。一般直接使用API或系统调用创建的线程均为一对一的线程。 缺点：一是由于许多操作系统限制了内核线程的数量，因此一对一线程会让用户的线程数量受到限制。二是许多操作系统内核线程调度时，上下文切换开销大，导致用户线程的执行效率下降。 多对一模型：线程间的切换由用户态的代码来进行，线程切换的速度要快许多，但是一个用户线程阻塞，那么所有线程都将无法执行，因此此时内核里的线程也随之阻塞了。多对一模型的好处就是高效的上下文切换和几乎无限制的线程数量。 多对多模型：一个用户线程阻塞并不会使得所有用户线程阻塞，因为此时还有别的线程可以被调度来执行。另外，多对多模型对用户线程的数量没有什么限制，在多处理器上，线程也能得到一定性能的提升。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux 基础常识]]></title>
      <url>%2F2017%2F03%2F05%2Flinux-%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%AF%86%2F</url>
      <content type="text"><![CDATA[概要 Linux可划分为：linux内核、GNU工具、图形化桌面环境、应用软件。 内核主要负责：系统内存管理、软件程序管理、硬件设备管理、文件系统管理。 交换空间：内核通过硬盘上的存储空间来实现虚拟内存的这块区域。 linux内核1.内存管理:分段分页 2.软件程序管理：内核控制着linux系统如何管理运行在系统上的所有进程。内核创建的第一个进程称为init进程，它是用来启动系统上所有其他进程的。当内核启动时，它会将init进程加载到虚拟内存中。内核在启动任何其他进程，都会在虚拟内存中给新进程分配一块专有的区域来存储该进程用到的数据和代码。 一些linux发行版使用一个表来管理在系统开机时要启动的进程。在linux上这个表通常位于专门文件/etc/inittab中。Ubuntu则采用/etc/init.d目录，将开机时启动或者停止某个应用脚本放在这个目录下。这个脚本通过/etc/rcX.d目录下的入口启动，这里X代表运行级别。Linux操作系统的init系统采用了运行级别。运行级别决定了init进程运行/etc/inittab文件或/etc/rcX.d目录中定义好的某些特定的进程。Linux操作系统有5个启动运行级别。 运行级别为一时，只启动基本的系统进程以及一个控制台终端进程，我们称之为单用户模式。单用户模式通常用来在系统有问题的时候进行紧急的文件系统维护。 标准的启动运行级别是3，在这个运行级别上，大多数应用软件，比如网络支持程序都会启动。运行级别5上系统启动图形化的X window系统，允许用户通过图形化桌面窗口登录系统。 硬件设备管理：任何linux系统需要与之通讯的设备，都需要在内核代码中加入其驱动程序代码。驱动程序代码相当于应用程序和硬件设备的中间人，允许内核与设备之间交互数据。在linux内核中有两种方法用于插入设备驱动的代码，第一，编译进内核的设备驱动代码，第二，可插入内核的设备驱动代码。Linux将硬件设备当成特殊的文件，称为设备文件。设备文件有：字符型设备文件、块设备文件、网络设备文件。 文件系统管理：linux内核支持不同类型的文件系统从硬盘中读取数据。 类型 描述 Ext Linux 扩展文件系统，最早的linux文件系统 Ext2 第二扩展文件系统，在ext的基础上提供了更多的功能。 Ext3 第三扩展文件系统，支持日志功能。 Ext4 第四扩展文件系统，支持高级日志功能。 Hpfs Os/2高性能文件系统。 Nfs 网络文件系统 Proc 访问系统信息 ReiserFS 高级linux文件系统，能够提供更好的性能和硬盘恢复功能 Linux内核采用虚拟文件系统（VFS）作为和每个文件系统交互的接口。这为linux内核同任何类型的文件系统通信提供了一个标准的接口。当每个文件系统都被挂载和使用的时候，VFS将信息都缓存在内存中。 GNU工具GNU(GNU‘s Not Unix 的缩写) linux 内核和GNU工具的结合成为linux 核心GNU工具：GNU项目的主旨在于为UNIX系统管理员设计出一套类似于UNIX的环境。这个目标促使该项目移植了很多常见的unix系统命令行工具。供linux系统使用的这组核心工具被称为coreutils(core utilities)软件包。它由三部分构成：处理文件的工具、操作文本的工具、管理进程的工具。 ShellGNU/Linux shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在linux系统上的进程的途径。Shell的核心是命令提示符。命令提示符是设立负责交互的部分。它允许你输入文本命令，然后解释命令，并在内核中运行。 Shell包含一组内部命令，它也允许你输入程序的名称，将程序名称传递给内核以启动它。 所有linux发行版本默认的shell都是bash shell。Bash shell 由GNU项目开发，被当作标准的Unix shell(bourne shell以创建者命名)的替代品。Bash shell 的名字就是针对bourne shell 的拼写玩的一个文字游戏，称为bourne again shell。 shell 描述 Ash 一个运行在内存受限环境中简单的轻量级的shell，但和bash shell 完全兼容 Korn 一种与bourne shell 兼容的编程shell，但支持一些高级编程特性：关联数组和浮点运算 Tcsh 一种将C语言中的一些元素引入shell脚本中的shell。 Zsh 一种结合了bash tcsh korn 的特性，同时提供了高级编程特性，共享历史文件和主题的高级shell。 linux桌面环境 x window系统:它是直接和PC上的显示器以及显卡打交道的底层程序。它控制这linux程序如何在电脑上显示漂亮的窗口和图形。 KDE(K Desktop Enivironment): 它允许你把应用程序图标和文件图标放置在桌面上。单击应用程序图标，linux就会运行该应用程序。 GNOME（the GNU Network Object Model Environment, GNU网络对象模型环境），用的最多是Red Hat Linux. Unity桌面：ubuntu的桌面环境。目标为工作站、平板电脑以及移动设备提供一致的桌面体验。 Linux发行版通常分为三类： 完整的核心linux发行版 特定用途的发行版 LiveCD测试发行版 核心linux发行版含有内核、一个多个图形化桌面环境以编译好的几乎所有能见到的linux应用。它提供了一站式完整的安装。比较流行的版本有 发行版 描述 Debian 在linux专家和商用linux产品中流行的发行版。 OpenSUSE 用于商用和家用的发行版 Slackware 最早的linux发行版的一员，在linux极客中比较流行。 Red Hat 主要用于Internet服务器的商业发行版 Fedora 从RedHat分离出的家用发行版 Gentoo 为高级linux用户设计的发行版，仅包含Linux源码。 特殊用途的linux发行版：他们通常基于某个主流发行版，但仅包含主流发行版的一小部分用于某种特定用途的应用程序。定制化发行版还尝试通过自动检测和自动配置常见的硬件来帮助新手安装linux。 发行版 描述 Centos 基于Red Hat企业版linux源代码构建的免费发行版 Ubuntu 用于学校和家庭的免费发行版 PClinuxOS 用于家庭和办公 Mint 用于家庭娱乐]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux 进程与线程]]></title>
      <url>%2F2017%2F03%2F05%2Flinux-%E6%9D%82%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[什么是进程？ 进程是资源分配和和独立运行的单位； 进程是操作系统中可执行程序的一次执行，换句话说进程就是拥有资源（cpu,内存，磁盘，进程ID，文件描述符，虚拟地址空间，端口号等）的程序；它是动态的； 一个进程是由程序控制块（pcb也就是task_struct结构体）,代码和数据组成；其中进程控制块是描述进程的资源和运行状态等；它有内核来管理； 在linux中可以通过ps，pstree来查看当前系统中的进程； 什么是线程？ 线程属于轻量级进程，一个进程可以拥有多个线程；linux下线程就是轻量级进程，所以线程的概念和进程是大同小异的。只不过是共享了大部分资源的进程罢了。 线程是进程的一个执行流，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程是进程中的最小调度单位； 用户线程指的是完全建立在用户空间的线程库，用户线程的建立，同步，销毁，调度完全在用户空间完成，不需要内核的帮助。因此这种线程的操作是极其快速的且低消耗的。 用户态线程和内核态线程；主要的区分就是“谁来管理”线程，用户态是用户管理，内核态是内核管理（但肯定要提供一些API，例如创建）。 线程的模型有哪些 n : 1 多个线程对应一个核心线程(进程); 线程的创建和销毁以及管理全部在用户层的线程库中实现，在内核层完全不知情，内核层看到的只是一个个进程。所以内核会以进程为单位调度任务运行。 1：1 一个线程对应核心线程(进程); 在1:1模式下，线程的创建，调度，销毁全由内核完成，而其他操作则由线程库完成。 m ：n ： 结合上面两种方式，如某些进程一一对应核内线程，其他线程完全在用户态实现。 linux是如何管理进程的？ 每个进程在linux内核拥有一个task_struct结构体（进程控制块的具体定义），里面包含了进程几乎所有的信息。在linux下，所谓的进程管理，就是反复操纵task_struct结构体的过程一点也不为过。 操作系统对进程的所有管理都是围绕task_struct结构体为中心构建的。 例如，给某个进程发送kill信息，操作系统就会根据task_struct结构体中的信息释放进程所占用的内存，信号量，打开文件相关的资源等等，然后当进程被切换出去时释放task_struct结构体，至此，系统再没有保存该进程的任意一点信息，标志着进程的死亡。 再例如，进程的调度，由于每个进程都有其自己的上下文环境，或者说是当前系统状态的总和。被切换出去进程的这种系统状态需要保存到task_struct结构体中，以便下次恢复。而被切换进来的进程的上下文环境从哪里来呢？显而易见，在这个被调度进来的进程在真正运行之前，调度程序会从该进程的task_struct结构体中找到之前保存的上下文环境，然后将系统恢复到之前保存的状态，被调度进来的程序才真正开始运行。 进程的创建过程： 操作系统给新进程分配一个全局唯一的pid号; 并在内核空间中创建和分配诸如task_struct结构体，kernel堆栈等必要的数据结构和物理资源。 然后复制父进程的与信号有关，与文件系统有关的运行环境。最后还会给task_struct结构体某些变量赋值，将来使用这些变量来将新进程运行的某些环境（如kernel栈的起始地址，EAX的初值等）设置为子进程自己独有的运行环境。并加入运行队列中，之后就是调度程序的事了。 这个过程中涉及到了写时拷贝技术。在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。 写时拷贝技术: http://blog.sina.cn/dpool/blog/s/blog_96757e4b01011b1n.html?vt=4 在Linux程序中，fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。在fork之后exec之前两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个。当子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间。 这就是分配内存的拖延战术，直到不得不做。操作系统中与此类似思想的还有页高速缓存器（page cache）。也就是，当有程序试图将数据写入文件的时候，linux操作系统并不会马上将数据写入disk中，而是将它们临时放在memory的一块区域。这块区域就叫做page cache。只有在关闭文件或者关机时，才有内核线程将page cache中的数据刷到磁盘中。这也就是非正常退出时，数据会损坏的原因。 在Linux中主要提供了fork、vfork、clone三个进程创建方法。 以下总结来源:http://www.360doc.com/content/14/1231/11/14530056_437075775.shtml 在linux源码中这三个调用的执行过程是执行fork(),vfork(),clone()时，通过一个系统调用表映射到sys_fork(),sys_vfork(),sys_clone(),再在这三个函数中去调用do_fork()去做具体的创建进程工作。 fork创建一个进程时，子进程只是完全复制父进程的资源，复制出来的子进程有自己的task_struct结构和pid,但却复制父进程其它所有的资源。这样看来，fork是一个开销十分大的系统调用，这些开销并不是所有的情况下都是必须的，比如某进程fork出一个子进程后，其子进程仅仅是为了调用exec执行另一个可执行文件，那么在fork过程中对于虚存空间的复制将是一个多余的过程。但由于现在Linux中是采取了copy-on-write(COW写时复制)技术，为了降低开销，fork最初并不会真的产生两个不同的拷贝，因为在那个时候，大量的数据其实完全是一样的。写时复制是在推迟真正的数据拷贝。所以有了写时复制后呢，vfork其实现意义就不大了。 vfork系统调用不同于fork，用vfork创建的子进程与父进程共享地址空间，也就是说子进程完全运行在父进程的地址空间上，如果这时子进程修改了某个变量，这将影响到父进程。但此处有一点要注意的是用vfork()创建的子进程必须显示调用exit()来结束，否则子进程将不能结束，而fork()则不存在这个情况。用 vfork创建子进程后，父进程会被阻塞直到子进程调用exec(exec，将一个新的可执行文件载入到地址空间并执行之。)或exit。vfork的好处是在子进程被创建后往往仅仅是为了调用exec执行另一个程序，因为它就不会对父进程的地址空间有任何引用，所以对地址空间的复制是多余的 ，因此通过vfork共享内存可以减少不必要的开销。 clone :系统调用fork()和vfork()是无参数的，而clone()则带有参数。fork()是全部复制，vfork()是共享内存，而clone() 是则可以将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些资源给子进程，由参数列表中的 clone_flags来决定。另外，clone()返回的是子进程的pid。所以，这个就和上面说的轻量级进程联系起来，也可以这样说，linux通过clone调用生成线程。 fork，vfork，clone的区别 fork出来的子进程是父进程的一个拷贝，即，子进程从父进程得到了数据段和堆栈段的拷贝，这些需要分配新的内存；而对于只读的代码段，通常使用共享内存的方式访问；而vfork则是子进程与父进程共享内存空间, 子进程对虚拟地址空间任何数据的修改同样为父进程所见；clone则由用户通过参clone_flags 的设置来决定哪些资源共享，哪些资源拷贝。 fork不对父子进程的执行次序进行任何限制，fork返回后，子进程和父进程都从调用fork函数的下一条语句开始行，但父子进程运行顺序是不定的，它取决于内核的调度算法；而在vfork调用中，子进程先运行，父进程挂起，直到子进程调用了exec或exit之后，父子进程的执行次序才不再有限制；clone中由标志CLONE_VFORK来决定子进程在执行时父进程是阻塞还是运行，若没有设置该标志，则父子进程同时运行，设置了该标志，则父进程挂起，直到子进程结束为止。他们成功执行时，父进程中返回子进程的进程号，在子进程中返回0。 进程的调度主要结构就是运行队列(双向循环链表)。为什么会有运行队列的存在呢?当Linux内核要寻找一个新的进程在CPU上运行时，必须只考虑处于可运行状态的进程，（即在TASK_RUNNING状态的进程），因为扫描整个进程链表是相当低效的，所以引入了可运行状态进程的双向循环链表，也叫运行队列（runqueue）。运行队列容纳了系统中所有可以运行的进程，它是一个双向循环队列。 也就是说，为了实现进程的调度，内核维护了一个叫做运行队列的数据结构。在这个数据结构中，active，expired，arrays是主要的三个结构。目前，咱们几个了解这三个就足够了。arrays也就是一个拥有两个成员的数组，每个数组有140个双向链表（也就是说，所有的就绪进程，按照时间片是否用完分成两个部分），对应了0~139 的140个优先级。active和expired分别指向arrays的两个成员。进程调度时，从active指针选择下一个要运行的程序。active中时间片用完的进程会被移动到expired队列，并且时间片会被重新计算，若active队列再无成员，则两个指针指向互换。 linux进程主要分为 实时进程（例如键盘中输入字母或者鼠标点击之类的） 和 交互式进程与批处理进程（例如word程序，你总是写一会停一会）。内核不会动态调整前者的优先级，如需调整，则需要调用特殊的系统调用。而且，前者的优先级别最高。只有没有实时进程的时候，交互式或者批处理才会被调度执行。而后者的优先级会被内核动态调整。 进程有哪些调度策略？这时候你分开说。对于实时进程，一般采用的是FIFO或者RR（轮询）机制。而对于交互式或者批处理进程，则采用动态调整优先级加运行队列机制来执行调度。这里有个大原则，如果有实时进程，那么交互式或者批处理则不会被执行。这个从进程优先级就可以看出来：实时（0~99），交互式批处理（100~139）。这时，你还可以举个例子。比如，你正在复制100文件，文件是一个一个被复制的，当复制到第50个的时候，你点了一下停止符号，它不会说是继续第51个文件的复制，而是直接停止。说明你鼠标的点击被插入到第51个文件之前了。所以实时进程永远比后者优先级高。 进程会在什么时候被调度?调度一般在进程退出内核态时，因为这时进程已经释放了可能导致内核死锁的资源。除了时间片用完触发调度，内核线程会在执行一些比较费时的任务时，自己调用调度函数，使其他进程有机会执行。 首先进程调度不应该产生内核死锁之类的问题。如果进程在内核态，则它可能会占有产生死锁的资源（比如，进程想要操纵硬件必须使用系统调用。想想这样一种情况：用户想要使用打印机这种独占资源，内核线程，也就是代表用户进程在内核状态执行的那个线程，它一定改变了代表打印机的结构的某个标志位，或者持有打印机结构体内的自旋锁，互斥锁之类的资源，标志着打印机正在被使用，本来打算在返回用户态时释放这种互斥锁资源，但调度函数来了，我不管，我就要让你现在退出。然后该进程带着互斥锁退出。当下一个进程进来，也要使用打印机，这时，该进程向内核申请打印机，而内核却发现打印机正在被使用，所以内核等待打印机退出，而持有互斥锁的进程已经被内核踢出cpu了，谈何释放？所以这时，所有的进程都在等，被调度进来进程陷入内核出不来了,整条逻辑陷入了无限循环，如果是单核，那么死锁便产生了）。 关于僵尸进程僵尸进程指的是那些虽然已经终止的进程，但仍然保留一些信息，等待其父进程为其收尸。 生的原因：父进程调用fork创建子进程后，子进程运行直至其终止，它立即从内存中移除，但进程描述符仍然保留在内存中（进程描述符占有极少的内存空间）。子进程的状态变成EXIT_ZOMBIE，并且向父进程发送SIGCHLD 信号，父进程此时应该调用 wait() 系 统调用来获取子进程的退出状态以及其它的信息。在 wait 调用之后，僵尸进程就完全从内存中移除。因此一个僵尸存在于其终止到父进程调用 wait 等函数这个时间的间隙，一般很快就消失，但如果编程不合理，父进程从不调用 wait 等系统调用来收集僵尸进程，那么这些进程会一直存在内存中。比如父进程死了，或者父进程忽略了SIGCHLD信号，或者父进程对SIGCHLD信号定义的信号处理函数有误。 如何避免：不能使用 kill 后接 SIGKILL 信号这样的命令像杀死普通进程一样杀死僵尸进程，因为僵尸进程是已经死掉的进程，它不能再接收任何信号。事实上，如果系统中僵尸进程并不多的话，我们也无需去消除它们，少数的僵尸进程并不会对系统的性能有什么影响。 那么在编程时，如果能避免系统中大量产生僵尸进程呢？根据上面描述的，子进程在终止时会向父进程发 SIGCHLD 信号，Linux 默认是忽略该信号的，我们可以显示安装该信号，在信号处理函数中调用 wait 等函数来为其收尸，这样就能避免僵尸进程长期存在于系统中了。以上都是复制下面这个链接的， http://www.cnblogs.com/hazir/p/zombie_process.html 危害： 僵尸进程的pid不会释放，意味着如果有海量的僵尸进程，则会占满进程表项，是的后续进程无法执行fork（） 内核栈无法释放，这个资源是很珍贵的。根本原因在于，task_stauct结构体没有释放。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[c++ 类的四大函数]]></title>
      <url>%2F2017%2F03%2F05%2Fc-%E7%B1%BB%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[类与对象 类是用户自定义的一种数据类型，定义类时描述它可以提供的信息及能够执行的操作；即类是一种具有属性和行为的自定义的数据类型； 对象就是封装了数据结构，及施加这些数据结构上的操作的封装体； 类与对象的关系：类之于对象如同类型之于变量，因此类只是描述了数据格式和方法，而对象则是根据规范创建的实体；换句话说类就像图纸，而对象则是根据图纸盖起的大楼。 类与结构体的区别唯一的区别在于struct的默认访问权限是public,而类是private; C++中的类所占内存分析： 类所占内存的大小是由成员变量（静态变量除外）决定的，成员函数（这是笼统的说，后面会细说）是不计算在内的。成员函数还是以一般的函数一样的存在。a.fun()是通过fun(a.this)来调用的。 所谓成员函数只是在名义上是类里的。其实成员函数的大小不在类的对象里面，同一个类的多个对象共享函数代码。而我们访问类的成员函数是通过类里面的一个指针实现，而这个指针指向的是一个table， table里面记录的各个成员函数的地址（当然不同的编译可能略有不同的实现）。所以我们访问成员函数是间接获得地址的。所以这样也就增加了一定的时间开销，这也就是为什么我们提倡把一些简短的，调用频率高的函数声明为inline形式（内联函数）。 总结：空的类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。 类内部的成员变量： 普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。 static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。 类内部的成员函数： 普通函数：不占用内存。 虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的。 C++类中的四大函数：构造函数、拷贝构造函数、析构函数和赋值函数: 四个函数一般系统都会默认。但是往往系统默认的并不是我们所期望的，为此我们有必要自己编写符合要求的函数，参看String.cpp; 把对象的初始化工作放在构造函数中，当对象被创建时，构造函数被自动执行。 把清除工作放在析构函数中。当对象消亡时，析构函数被自动执行，把一切内存垃圾清理，可见他的重要。如果没有析构函数或析构函数不正确就会发生内存泄露等问题，后果非常危险 每个类只有一个析构函数和一个赋值函数，但可以有多个构造函数（包含一个拷贝构造函数，其它的称为普通构造函数）。 构造函数和赋值函数有着很大的区别，构造函数是在对象创建时调用的；而赋值函数使对象已经创建好了存在之后再赋值时调用的。有时候我们懒得写赋值函数和拷贝构造函数，又不允许别人使用编译器生成的缺省函数，那么我们可以只需将拷贝构造函数和赋值函数声明为私有函数，函数体为空即可； 使用对象前正确初始化 并不是所有的编译器都对象对象的内置类型成员会被自动初始化为0。永远在使用对象之前先将它初始化。确保每一个构造函数都将对象的每一个成员初始化。 别把赋值错当成初始化。C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前（对于内置类型对象可能不确定），这点对于非内置类型对象来说尤其关键。如果你没有在成员初始化列表（member initialization list）为其初始化，它们将调用自己的默认构造函数，然后才进入构造函数内部（很可能你会在这里给他们赋值）。在成员初始化列表中的初始化只是调用了拷贝构造函数一次，而在构造函数内部再为其赋值则在调用默认构造函数后又调用了一次拷贝构造函数。因此初始化列表将更为高效 所以，请用成员初始化列表进行初始化，虽然效率提高只针对于非内置类型成员，但是规定总是在初值列中列出所有成员变量，这样就省的有些未被列出的内置类型成员被忘记初始化。而有些时候，即使成员变量是内置类型，也必须要用成员初始化列表（成员变量为const或者reference，它们一定要有初值，而且不能被赋值）。 构造函数 使用构造函数的原因：由于类的封装性,不能象普通变量一样初始化 构造函数的作用：是在对象被创建时使用特定的值构造对象，或者说将对象初始化为一个特定的状态。 调用时刻：在对象创建时由系统自动调用。如果程序中未声明，则系统自动产生出一个缺省形式的构造函数 条件约束：允许为内联函数、重载函数、带缺省形参值的函数；但不允许是虚函数因为在刚开始对象还未被创建，内部什么都没有，更不用说虚表，虚表指针。因此无法调用虚函数。 拷贝构造函数（是一种特殊的构造函数，其形参为本类的对象引用）。 作用：使用一个对象（参数指定的对象），去初始化一个正在被建立的同类型对象（如果程序员没有为类声明拷贝初始化构造函数，则编译器自己生成一个拷贝构造函数。） 调用时刻： 当用类的一个对象去初始化该类的另一个对象时系统自动调用它实现拷贝赋值。 若函数的形参为类对象，调用函数时，实参赋值给形参，系统自动调用拷贝构造函数。 当函数的返回值是类对象时，系统自动调用拷贝构造函数。析构函数作用：完成对象被删除前的一些清理工作。调用时刻：在对象的生存期结束的时刻系统自动调用它，然后再释放此对象所属的空间。如果程序中未声明析构函数，编译器将自动产生一个缺省的析构函数。 注意事项： 析构函数也不被继承，派生类自行声明。 声明方法与一般（无继承关系时）类的析构函数相同。 不需要显式地调用基类的析构函数，系统会自动隐式调用。 析构函数的调用次序与构造函数相反。 类组合的构造函数调用 构造函数调用顺序：先调用内嵌对象的构造函数（按内嵌时的声明顺序，先声明者先构造）。然后调用本类的构造函数。（析构函数的调用顺序相反） 若调用缺省构造函数（即无形参的），则内嵌对象的初始化也将调用相应的缺省构造函数。 多继承且有内嵌对象时的构造函数调用次序 调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。 调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序。 静态数据成员在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。 使用静态数据成员可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。 静态数据成员的使用方法和注意事项如下： 静态数据成员在定义或说明时前面加关键字static。 静态成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式如下： &lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt; 这表明： 初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆。 初始化时不加该成员的访问权限控制符private，public等。 初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员。 静态数据成员是静态存储的，它是静态生存期，必须对它进行初始化。 引用静态数据成员时，采用如下格式：&lt;类名&gt;::&lt;静态成员名&gt; 静态成员函数 静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。 在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。如果静态成员函数中要引用非静态成员时，可通过对象来引用。 调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;); 类外代码可以使用类名和作用域操作符来调用静态成员函数。 静态成员函数只能引用属于该类的静态数据成员或静态成员函数。 Inline函数C++ inline函数 ： inline int min(int first, int secend) {/****/}; inline函数对编译器而言必须是可见的，以便它能够在调用点内展开该函数。与非inline函数不同的是，inline函数必须在调用该函数的每个文本文件中定义。 关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。（所以说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。） 慎用内联：内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联： 如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。 内联函数和#define 宏的区别：内联函数总是对参数只精确地进行一次求值，从而避免了那声名狼藉的宏错误。换句话说，调用内联函数和调用正规函数是等价的，差别仅仅是更快 常函数的调用是这样的：常量对象只能调用常成员函数，非常量对象即可以调常成员函数，也可以调一般成员函数，但当某个函数有const和非const两个版本时，const对象调const版本，非const对象调非const版本。 二义性的问题 在多继承时，基类与派生类之间，或基类之间出现同名成员时，将出现访问时的二义性（不确定性）——采用虚函数（第8章）或支配（同名覆盖）原则来解决。 当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性——采用虚基类来解决。 虚基类引入 用于有共同基类的场合声明 以virtual修饰说明基类 例：class B1:virtual public B 作用： 主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题. 为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝 注意： 在第一级继承时就要将共同基类设计为虚基类。 虚基类及其派生类构造函数 建立对象时所指定的类称为最（远）派生类。 虚基类的成员是由最派生类的构造函数通过调用虚基类的构造函数进行初始化的。 在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中给出对虚基类的构造函数的调用。如果未列出，则表示调用该虚基类的缺省构造函数。 在建立对象时，只有最派生类的构造函数调用虚基类的构造函数，该派生类的其它基类对虚基类构造函数的调用被忽略。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[c++ 继承]]></title>
      <url>%2F2017%2F03%2F05%2Fc-%E7%BB%A7%E6%89%BF%2F</url>
      <content type="text"><![CDATA[继承与派生： 保持已有类的特性而构造新类的过程称为继承。 在已有类的基础上新增自己的特性而产生新类的过程称为派生。 继承的目的：实现代码重用。 派生的目的：当新的问题出现，原有程序无法解决（或不能完全解决）时，需要对原有程序进行改造。 三种继承方式 公有继承；私有继承；保护继承不同继承方式的影响主要体现在: 派生类成员对基类成员的访问控制。 派生类对象对基类成员的访问控制。 1.公有继承： 继承方式：基类的public和protected成员的访问属性在派生类中保持不变，但基类的private成员不可访问。 类内： 派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。 类外：通过派生类的对象只能访问基类的public成员。 2.私有继承： 继承方式：基类的public和protected成员都以private身份出现在派生类中，但基类的private成员不可访问。 类内：派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。 类外：通过派生类的对象不能访问基类中的任何成员。 3.保护继承： 继承方式：基类的public和protected成员都以protected身份出现在派生类中，但基类的private成员不可访问。 类内：派生类中的成员函数可以直接访问基类中的public和protected成员，但不能访问基类的private成员。 类外：通过派生类的对象不能访问基类中的任何成员 4.protected 成员的特点与作用： 对建立其所在类对象的模块来说（水平访问时），它与 private 成员的性质相同。 对于其派生类来说（垂直访问时），它与 public 成员的性质相同。 . 既实现了数据隐藏，又方便继承，实现代码重用； 基类与派生类的对应关系 单继承: 派生类只从一个基类派生。 多继承：派生类从多个基类派生。 多重派生: 由一个基类派生出多个不同的派生类。 多层派生: 派生类又作为基类，继续派生新的类。 继承时的构造函数 基类的构造函数不被继承，需要在派生类中自行声明。 声明构造函数时，只需要对本类中新增成员进行初始化，对继承来的基类成员的初始化由基类完成。 多重继承构造函数的调用次序 调用基类构造函数，调用顺序按照它们被继承时声明的顺序（从左向右）。 调用成员对象的构造函数，调用顺序按照它们在类中声明的顺序。 派生类的构造函数体中的内容。 多重继承时的析构函数 析构函数也不被继承，派生类自行声明。 声明方法与一般（无继承关系时）类的析构函数相同。 不需要显式地调用基类的析构函数，系统会自动隐式调用。 析构函数的调用次序与构造函数相反。 二义性问题 在多继承时，基类与派生类之间，或基类之间出现同名成员时，将出现访问时的二义性（不确定性）——采用虚函数或支配（同名覆盖）原则来解决。 当派生类从多个基类派生，而这些基类又从同一个基类派生，则在访问此共同基类中的成员时，将产生二义性——采用虚基类来解决。（菱形继承） 虚基类声明: 以virtual修饰说明基类 例：class B1:virtual public B 作用： 主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题. 为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝 注意：在第一级继承时就要将共同基类设计为虚基类。 赋值兼容原则一个公有派生类的对象在使用上可以被当作基类的对象，反之则禁止。具体表现在： 派生类的对象可以被赋值给基类对象。 派生类的对象可以初始化基类的引用。 指向基类的指针也可以指向派生类。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[c++ 多态]]></title>
      <url>%2F2017%2F03%2F05%2Fc-%E7%9A%84%E5%A4%9A%E6%80%81%2F</url>
      <content type="text"><![CDATA[C和C++的区别： C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制）。C的优势在于编写的程序更接近于硬件，仅次于汇编语言，所以他相对其他编程语言高效的多，但同时程序员负责一切不安全，如内存泄露等。但正是由于这样的风险的存在，对程序员的紧密思维要求更高。 C++是有C，面向对象，泛型编程，stl组成。用面向对象来编程首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。 所以C与C++的最大区别在于它们的用于解决问题的思想方法不一样。之所以说C++比C更先进，是因为“ 设计这个概念已经被融入到C++之中 ”。 面向对象的三大特性：封装，继承，多态 封装：将对象的属性和方法封装在对象内部，形成一个个独立的单元模块，对外通访问权限控制管理对象数据的交互。(访问权限：（private，protected,public) 保证封装性的关键)目的：增强代码的安全性和简化编程，让使用者不必了解类具体的实现细节，只要通过外部接口，以特定的权限来使用类的方法即可。 继承：一个对象获得另一对象的特性的过程。是将一群类组织起来，定义了父子关系，实现了代码的重用，父类定义了所有子类的的共有借口和私有实现，同时子类都可以增加或覆盖继承来的东西，以实现独有的行为。 多态：它是建立在了继承的基础上；简单来说，就是一个接口，多个方法.具体来说：它是指不同子类在继承父类后分别覆盖了父类的方法多态性使得同一属性或者行为在基类及其子类间有不同的语义；多态性丰富了对象的内容，增强了软件的灵活性和可重用性；C++的多态性有两种：编译时的多态（函数重载），运行时多态（虚函数）（联编（binding)或称为绑定:是指计算机程序自身彼此关联的过程联编工作在编译连接阶段完成的情况称为：静态联编联编在程序运行阶段完成的情况称为：动态联编。） c++ 重载 覆盖 隐藏的区别和执行方式 : 成员函数被重载的特征:相同的范围（在同一个类中）；函数名字相同；参数不同； virtual 关键字可有可无。 覆盖是指派生类函数覆盖基类函数，特征是:不同的范围（分别位于派生类与基类）； 函数名字相同； 参数相同； 基类函数必须有virtual 关键字。 “隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下:如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆） 3种情况怎么执行：重载：看参数;隐藏：用什么就调用什么;覆盖：调用派生类; 虚函数的工作原理：编译器处理虚函数的方法是.给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。而这个数组称为虚函数表，虚函数表中存储了为类对象进行声明的虚函数的地址。 单继承时 虚函数指针在对象的最前面的位置； 虚函数地址按照声明的顺序存放于虚表中； 父类虚函数地址在子类虚函数地址的前面； 子类如果覆盖父类的虚函数，则被放到虚表中原父类虚函数的位置 没有被覆盖的函数依旧在原位。 多重继承的特殊地方： 每个父类都有自己的虚表时，子类的虚函数成员只被放到第一个父类中。 子类有多个虚表指针，位于类的最前面，分别指向不同的父类的虚表，（按继承的顺序）。 如果有覆盖情况，则替换所有被覆盖的父类虚函数地址。 父类访问子类中成员函数只能通过虚函数，覆盖的方法。否则无法访问。但我们可以通过函数指针强行访问虚表里的函数。本人就是通过此方法的出的以上结论。 虚函数特性： 虚函数是动态联编的基础。 是非静态的成员函数。 在类的声明中，在函数原型之前写virtual。 virtual 只用来说明类声明中的原型，不能用在函数实现时。 具有继承性，基类中声明了虚函数，派生类中无论是否说明，同原型函数都自动为虚函数。 本质：不是重载声明而是覆盖。 调用方式：通过基类指针或引用，执行时会根据指针指向的对象的类，决定调用哪个函数。 虚函数的限制 只有类的成员函数才能说明为虚函数，因为虚函数仅适用于继承关系的 类对象，所以普通函数不能说明为虚函数。 内联函数不能是虚函数，因为内联函数是在编译时决 定其位置。 构造函数不能是虚函数，因为构造时对象还是一片未 定型的空间，就没有虚指针，虚表。。 析构函数可以是虚函数，而且通常声明为虚函数。纯虚函数与抽象类 带有纯虚函数的类称为抽象类: 1class 类名 &#123; virtual 类型 函数名(参数表)=0; //纯虚函 ... &#125;; 作用： 抽象类为抽象和设计的目的而建立，将有关的数据和行为组织在一个继承层次结构中，保证派生类具有要求的行为。 对于暂时无法实现的函数，可以声明为纯虚函数，留给派生类去实现。主要作用是通过它为一个类族建立一个公共的接口，使它们能够更有效地发挥多态特性。 注意：抽象类只能作为基类来使用;不能声明抽象类的对象;但可以声明一个指针]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[c++ 模板]]></title>
      <url>%2F2017%2F03%2F05%2Fc-%E6%A8%A1%E6%9D%BF%2F</url>
      <content type="text"><![CDATA[模板是C++支持参数化多态的工具，使用模板可以使用户为类或者函数声明一种一般模式，使得类中的某些数据成员或者成员函数的参数、返回值取得任意类型。 模板是一种对类型进行参数化的工具；通常有两种形式：函数模板和类模板；函数模板针对仅参数类型不同的函数；类模板针对仅数据成员和成员函数类型不同的类。 使用模板的目的：就是能够让程序员编写与类型无关的代码。 注意：模板的声明或定义只能在全局，命名空间或类范围内进行。即不能在局部范围，函数内进行，比如不能在main函数中声明或定义一个模板。 1.函数模板定义格式:template &lt;class 形参名，class 形参名，......&gt; 返回类型 函数名(参数列表) { 函数体 } 模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。 2.函数模板 函数模板可以用来创建一个通用功能的函数，以支持多种不同形参，进一步简化重载函数的函数体设计。 函数模板提供一个种用来自动生成各种类型函数实例的算法，程序员对于函数接口参数和返回类型中的全部或者部分类型进行参数化(parameterize)，而函数体保持不变。 注意：模板形参不能为空。一但声明了模板函数就可以用模板函数的形参名声明类中的成员变量和成员函数，即可以在该函数中使用内置类型的地方都可以使用模板形参名。 注意：对于函数模板而言不存在 h(int,int) 这样的调用，不能在函数调用的参数中指定模板形参的类型，对函数模板的调用应使用实参推演来进行，即只能进行 h(2,3) 这样的调用，或者int a, b; h(a,b) 函数模板实例化 函数模板只是声明了一个函数的描述即模板，不是一个可以直接执行的函数，只有根据实际情况用实参的数据类型代替类型参数标识符之后，才能产生真正的函数。 函数模板的数据类型参数标识符实际上是一个类型形参，在使用函数模板时，要将这个形参实例化为确定的数据类型。将类型形参实例化的参数称为模板实参，用模板实参实例化的函数称为模板函数。模板函数的生成就是将函数模板的类型形参实例化的过程。 函数模板在它被调用或取其地址时被实例化 模板函数类似于重载函数，但两者有很大区别：函数重载时，每个函数体内可以执行不同的动作，但同一个函数模板实例化后的模板函数都必须执行相同的动作 3.函数模板与同名的非模板函数重载时，应遵循下列调用原则： 寻找一个参数完全匹配的函数，若找到就调用它。若参数完全匹配的函数多于一个，则这个调用是一个错误的调用。 寻找一个函数模板，若找到就将其实例化生成一个匹配的模板函数并调用它。 若上面两条都失败，则使用函数重载的方法，通过类型转换产生参数匹配，若找到就调用它。 若上面三条都失败，还没有找都匹配的函数，则这个调用是一个错误的调用 4.类模板定义：template&lt;class 形参名，class 形参名，…&gt; class 类名 {... }; 类模板和函数模板都是以template开始后接模板形参列表组成，模板形参不能为空，一但声明了类模板就可以用类模板的形参名声明类中的成员变量和成员函数，即可以在类中使用内置类型的地方都可以使用模板形参名来声明。比如: template&lt;class T&gt; class A{public: T a; T b; T hy(T c, T &amp;d);}; 5.类模板对象的创建： 比如一个模板类A，则使用类模板创建对象的方法为A m;在类A后面跟上一个&lt;&gt;尖括号并在里面填上相应的类型，这样的话类A中凡是用到模板形参的地方都会被int 所代替。当类模板有两个模板形参时创建对象的方法为A m;类型之间用逗号隔开。 对于类模板，模板形参的类型必须在类名后的尖括号中明确指定。比如A m;用这种方法把模板形参设置为int是错误的（编译错误：error C2079: ‘a’ uses undefined class ‘A‘），类模板形参不存在实参推演的问题。也就是说不能把整型值2推演为int 型传递给模板形参。要把类模板形参调置为int 型必须这样指定A m。 6.在类模板外部定义成员函数的方法为：template&lt;模板形参列表&gt; 函数返回类型 类名&lt;模板形参名&gt;::函数名(参数列表){函数体}； 比如有两个模板形参T1，T2的类A中含有一个void h()函数，则定义该函数的语法为： template&lt;class T1,class T2&gt; void A&lt;T1,T2&gt;::h(){}。 注意：当在类外面定义类的成员时template后面的模板形参应与要定义的类的模板形参一致。 7.模板的实例化：类模板在引用实际模板类类型时实例化 定义模板类对象时 通过类指针或引用指向一个类模板实例时，只有当检查这个指针或引用指的那个对象时(访问数据成员或成员函数)，才会实例化 当类模板被实例化时，类模板的成员函数并不自动被实例化。只有该函数被调用或取地址时，才被实例化。 静态数据成员只有被使用时才实例化。 8.类模板和函数模板区别 函数模板允许重载 ，而类模板不允许重载(类无重载概念，即不存在同名类模板)。 类模板可以进行全特化和偏特化，而函数模板仅能够全特化 。 类模板支持默认参数，函数模板不支持]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F02%2F10%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
